# Preview

```sh
$ for v in 1 2 3; do ( \
>   echo "Generating prose for Wasm $v.0..." && \
>   ../src/exe-spectec/main.exe ../../../../specification/wasm-$v.0/*.spectec -v -l --prose-rst && \
>   ../src/exe-spectec/main.exe ../../../../specification/wasm-$v.0/*.spectec -v -l --prose \
> ) done
Generating prose for Wasm 1.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[ n .. m ]` is :ref:`valid <valid-val>` with :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` is always :ref:`valid <valid-val>`.




The global type :math:`({\mathsf{mut}^?}~t)` is always :ref:`valid <valid-val>`.




The table type :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{16}}`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is :ref:`valid <valid-val>` if:


   * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The limits :math:`{}[ n_{11} .. n_{12} ]` :ref:`matches <match>` the limits :math:`{}[ n_{21} .. n_{22} ]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` :ref:`matches <match>` only itself.




The global type :math:`{\mathit{gt}}` :ref:`matches <match>` only itself.




The table type :math:`{\mathit{lim}}_1` :ref:`matches <match>` the table type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{externtype}}` :ref:`matches <match>` the external type :math:`{\mathit{externtype}'}` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{select}` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The number type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The number type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^?}` is of the form :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`{t^?}` is of the form :math:`C{.}\mathsf{labels}{}[l]`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`(\mathsf{call\_indirect}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^?}`.




The instruction :math:`(t{.}\mathsf{const}~c_t)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{unop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{binop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{testop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(t {.} {\mathit{relop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}'}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}'}` is of the form :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.

   * Or:

      * :math:`{\mathit{cvtop}'}` is of the form :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`\mathsf{memory{.}size}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`({{t'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t'''}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * Either:

      * The number type :math:`{t'}` is of the form :math:`t`.

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The number type :math:`{t'''}` is of the form :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The number type :math:`{t'}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The number type :math:`{t'''}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{t'}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{t''}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * Either:

      * The number type :math:`{t'}` is of the form :math:`t`.

      * The pack size :math:`{{\mathit{sz}}^?}` is absent.

      * The number type :math:`{t''}` is of the form :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The number type :math:`{t'}` is of the form :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}^?}` is of the form :math:`M`.

      * The number type :math:`{t''}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{load}~t~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{store}~t~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is empty.

      * The number type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The number type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The number type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t_1^\ast}`.

      * The number type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{{\mathit{instr}}^\ast}`.

      * The number type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t^\ast}~{t_1^\ast}`.

      * The number type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




:math:`{\mathit{instr}}` is constant if:


   * Either:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(t{.}\mathsf{const}~c)`.

   * Or:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`(t{.}\mathsf{const}~c)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is :ref:`valid <valid-val>`.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^?}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^?}]`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^?}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{gt}}` is of the form :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is :ref:`valid <valid-val>`.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is :ref:`valid <valid-val>`.




The table segment :math:`(\mathsf{elem}~{\mathit{expr}}~{x^\ast})` is :ref:`valid <valid-val>` if:


   * The limits :math:`C{.}\mathsf{tables}{}[0]` is of the form :math:`{\mathit{lim}}`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.

   * The length of :math:`{{\mathit{ft}}^\ast}` is equal to the length of :math:`{x^\ast}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}`, and corresponding :math:`x` in :math:`{x^\ast}`:

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The memory segment :math:`(\mathsf{data}~{\mathit{expr}}~{b^\ast})` is :ref:`valid <valid-val>` if:


   * The limits :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{lim}}`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` if:


   * The length of :math:`{{\mathit{ft}'}^\ast}` is equal to the length of :math:`{{\mathit{type}}^\ast}`.

   * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}`, and corresponding :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}'}`.

   * The length of :math:`{{\mathit{import}}^\ast}` is equal to the length of :math:`{{\mathit{ixt}}^\ast}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`, and corresponding :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{ixt}}`.

   * The length of :math:`{{\mathit{global}}^\ast}` is equal to the length of :math:`{{\mathit{gt}}^\ast}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, and corresponding :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}`.

   * The length of :math:`{{\mathit{ft}}^\ast}` is equal to the length of :math:`{{\mathit{func}}^\ast}`.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}`, and corresponding :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}`.

   * The length of :math:`{{\mathit{table}}^\ast}` is equal to the length of :math:`{{\mathit{tt}}^\ast}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, and corresponding :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * The table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * The length of :math:`{{\mathit{mem}}^\ast}` is equal to the length of :math:`{{\mathit{mt}}^\ast}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`, and corresponding :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * The memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

      * The table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * The memory segment :math:`{\mathit{data}}` is :ref:`valid <valid-val>`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * The length of :math:`{{\mathit{export}}^\ast}` is equal to the length of :math:`{{\mathit{xt}}^\ast}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, and corresponding :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.

   * The length of :math:`{{\mathit{tt}}^\ast}` is less than or equal to :math:`1`.

   * The length of :math:`{{\mathit{mt}}^\ast}` is less than or equal to :math:`1`.

   * The context :math:`C` is of the form :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The context :math:`{C'}` is of the form :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}`
.......................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.............................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` L from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~{n'}`
........................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let L be the topmost :math:`\mathsf{label}`.

#. Let :math:`n` be the arity of L

#. If :math:`{n'} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Jump to the continuation of L.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`{n'} \geq 1`, then:

      1) Let :math:`l` be the label index :math:`{n'} - 1`.

      #) Pop the :math:`\mathsf{label}` L from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of f

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let f be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of f

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` F from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`t {.} {\mathit{unop}}`
.............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{binop}}`
..............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{testop}}`
...............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{relop}}`
..............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{t_1}`
....................................................


1. Assert: Due to validation, a value of number type :math:`t_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}`.

#. Push the value :math:`(t_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}`
....................................................


1. Let :math:`n` be :math:`0`.

#. If :math:`{t^?}` is not defined, then:

   #. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

   a. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.

#. Let :math:`n` be :math:`1`.

#. If :math:`{t^?} \neq \epsilon`, then:

   #. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

   a. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}`
...................................................


#. Let L be the :math:`\mathsf{label}` whose continuation is the start of the block.

1. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]` is not defined, then:

   a. Trap.

#. Let :math:`a` be :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[x] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be the destructuring of :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Let f be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`n`.

#. Push the :math:`\mathsf{frame}` F.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`{{t'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{ao}}`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{t'}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{t'}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{t'}|} / 8]`.

   #. Push the value :math:`({t'}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{t'}` is :math:`{\mathsf{i}}{n}` and :math:`{{\mathit{loadop}}^?}` is defined, then:

   a. Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`({t'}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{t'}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`{{t'}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{ao}}`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({t''}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{t''}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{t'} = {t''}` and :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{t'} = {t''}` and :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{t''}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{t''}|} / 8] = {b^\ast}]`.

#. If :math:`{t''}` is :math:`{\mathsf{i}}{n}` and :math:`{t'} = {t''}` and :math:`{{\mathit{sz}}^?}` is defined, then:

   a. Let :math:`n` be :math:`{{\mathit{sz}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{t''}|}, n}(c))`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({{n''}^\ast})`
....................................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X^\ast}`.

#. Return :math:`w`.


:math:`{X^?}`
.............


1. If :math:`{X^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X^\ast})`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|{\mathit{valtype}}|}`
..............................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. Fail.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}'})}`
....................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}'})`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`
.............................................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{div}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{rem}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{shr}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`
.............................................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{lt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{gt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{le}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{ge}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{valtype}}, {\mathit{valtype}'}}}{({\mathit{iN}'})}`
..........................................................................................


1. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{extend}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{valtype}'} = \mathsf{i{\scriptstyle 64}}`, then:

      1) Return :math:`{{{{\mathrm{extend}}}_{32, 64}^{{\mathit{sx}}}}}{({\mathit{iN}'})}`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}` and :math:`{\mathit{valtype}'} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

   a. Return :math:`{{\mathrm{wrap}}}_{64, 32}({\mathit{iN}'})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{valtype}'}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{trunc}}}_{{|{\mathit{valtype}}|}, {|{\mathit{valtype}'}|}}^{{\mathit{sx}}}}}{({\mathit{iN}'})}`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{valtype}'} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

   a. Return :math:`{{\mathrm{promote}}}_{32, 64}({\mathit{iN}'})`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{valtype}'} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

   a. Return :math:`{{\mathrm{demote}}}_{64, 32}({\mathit{iN}'})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{valtype}'}` is :math:`{\mathsf{f}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{convert}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{{|{\mathit{valtype}}|}, {|{\mathit{valtype}'}|}}^{{\mathit{sx}}}}}{({\mathit{iN}'})}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{valtype}}|} = {|{\mathit{valtype}'}|}`, then:

      1) Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{valtype}}, {\mathit{valtype}'}}({\mathit{iN}'})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}'}` is :math:`{\mathsf{i}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{valtype}'}|} = {|{\mathit{valtype}}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{valtype}}, {\mathit{valtype}'}}({\mathit{iN}'})`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = a]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`a`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n)`
..............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ],\; \mathsf{refs}~{a^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{a^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{ti}'}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ {i'} .. j ],\; \mathsf{refs}~{a^\ast}~{\epsilon^{n}} \}\end{array}`.

   #. Return :math:`{\mathit{ti}'}`.

#. Fail.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ],\; \mathsf{bytes}~{b^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{mi}'}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ {i'} .. j ],\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

   #. Return :math:`{\mathit{mi}'}`.

#. Fail.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}''}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}''}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}''}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be the function instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}''}^\ast})`
.................................................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be the global instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})`
...........................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[ i .. j ])`
..............................................


1. Let :math:`{\mathit{ti}}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ],\; \mathsf{refs}~{\epsilon^{i}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}''}^\ast})`
................................................................


1. If :math:`{{\mathit{tabletype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[ i .. j ])`
............................................


1. Let :math:`{\mathit{mi}}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ],\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}''}^\ast})`
............................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`
.........................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}` for all :math:`i_{\mathit{func}}` from :math:`0` to :math:`n_{\mathit{func}} - 1`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{|s{.}\mathsf{globals}|} + i_{\mathit{global}}` for all :math:`i_{\mathit{global}}` from :math:`0` to :math:`n_{\mathit{global}} - 1`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{|s{.}\mathsf{tables}|} + i_{\mathit{table}}` for all :math:`i_{\mathit{table}}` from :math:`0` to :math:`n_{\mathit{table}} - 1`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}` for all :math:`i_{\mathit{mem}}` from :math:`0` to :math:`n_{\mathit{mem}} - 1`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}, {{\mathit{funcaddr}}^\ast})`
..................................................................................................................................


1. If :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast} = \epsilon` and :math:`{{\mathit{funcaddr}}^\ast} = \epsilon`, then:

   a. Return.

#. Assert: :math:`{|{{\mathit{funcaddr}}^\ast}|} \geq 1`.

#. Let :math:`{a^\ast}~{{{a'}^\ast}^\ast}` be :math:`{{\mathit{funcaddr}}^\ast}`.

#. Assert: :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{tables}{}[{\mathit{moduleinst}}{.}\mathsf{tables}{}[0]]{.}\mathsf{refs}{}[i : {|{a^\ast}|}]` with :math:`{a^\ast}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{a'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}, {{\mathit{byte}}^\ast})`
..............................................................................................................................


1. If :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast} = \epsilon` and :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Return.

#. Assert: :math:`{|{{\mathit{byte}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

#. Assert: :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{mems}{}[{\mathit{moduleinst}}{.}\mathsf{mems}{}[0]]{.}\mathsf{bytes}{}[i : {|{b^\ast}|}]` with :math:`{b^\ast}`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{b'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be the length of :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{(\mathsf{start}~{x'})^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{(\mathsf{data}~{\mathit{expr}}_{\mathsf{d}}~{b^\ast})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{expr}}_{\mathsf{e}}~{x^\ast})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be the state :math:`(s, f_{\mathit{init}})`.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{d}})^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{d}}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{e}})^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{\mathit{val}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`.

#. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathsf{e}}^\ast}, {{{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]^\ast}^\ast})`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathsf{d}}^\ast}, {{b^\ast}^\ast})`.

#. Let f be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` F.

#. If :math:`{(\mathsf{call}~{x'})^?}` is defined, then:

   a. Let :math:`{\mathit{instr}}_0` be :math:`{(\mathsf{call}~{x'})^?}`.

   #. Execute the instruction :math:`{\mathit{instr}}_0`.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}`.

#. Let F be the :math:`\mathsf{frame}` :math:`(s, f)`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be the destructuring of :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :math:`\mathsf{frame}` _f from the stack.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let f be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` F.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2? is always valid.

Globaltype_ok
- the global type (MUT? t) is always valid.

Tabletype_ok
- the table type limits is valid if:
  - limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits is valid if:
  - limits is valid with (2 ^ 16).

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches only itself.

Globaltype_sub
- the global type gt matches only itself.

Tabletype_sub
- the table type lim_1 matches the table type lim_2 if:
  - lim_1 matches lim_2.

Memtype_sub
- the memory type lim_1 matches the memory type lim_2 if:
  - lim_1 matches lim_2.

Externtype_sub
- the external type externtype matches the external type externtype' if:
  - Either:
    - externtype is (FUNC ft_1).
    - externtype' is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype is (GLOBAL gt_1).
    - externtype' is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype is (TABLE tt_1).
    - externtype' is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype is (MEM mt_1).
    - externtype' is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction SELECT is valid with the function type [t, t, I32] -> [t].

Instr_ok/block
- the instruction (BLOCK t? instr*) is valid with the function type [] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr* is valid with [] -> t?.

Instr_ok/loop
- the instruction (LOOP t? instr*) is valid with the function type [] -> t? if:
  - the instruction sequence instr* is valid with the function type [] -> [].

Instr_ok/if
- the instruction (IF t? instr_1* ELSE instr_2*) is valid with the function type [I32] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr_1* is valid with the function type [] -> t?.
  - Under the context C', the instruction sequence instr_2* is valid with [] -> t?.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t? :: [I32] -> t? if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t? :: [I32] -> t_2* if:
  - the result type C.LABELS[l'] exists.
  - the result type t? is C.LABELS[l'].
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - t? is C.LABELS[l].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2? if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2?.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x) is valid with the function type t_1* :: [I32] -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.RETURN is ?(t?).

Instr_ok/const
- the instruction (t.CONST c_t) is valid with the function type [] -> [t].

Instr_ok/unop
- the instruction (UNOP t unop_t) is valid with the function type [t] -> [t].

Instr_ok/binop
- the instruction (BINOP t binop_t) is valid with the function type [t, t] -> [t].

Instr_ok/testop
- the instruction (TESTOP t testop_t) is valid with the function type [t] -> [I32].

Instr_ok/relop
- the instruction (RELOP t relop_t) is valid with the function type [t, t] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop') is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop' is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop' is cvtop.

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/load
- the instruction (LOAD t' loadop_? memarg) is valid with the function type [I32] -> [t'''] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type t' is t.
    - loadop_? is ?().
    - the number type t''' is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t' is Inn.
    - loadop_? is ?(M _ sx).
    - t''' is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE t' sz? memarg) is valid with the function type [I32, t''] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type t' is t.
    - the pack size sz? is ?().
    - the number type t'' is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t' is Inn.
    - sz? is ?(M).
    - t'' is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD t ?() memarg) is valid with the function type [I32] -> [t] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE t ?() memarg) is valid with the function type [I32, t] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instrs_ok
- the instruction sequence instr'* is valid with the function type valtype* -> valtype'* if:
  - Either:
    - instr'* is [].
    - the number type sequence valtype* is [].
    - the number type sequence valtype'* is [].
  - Or:
    - instr'* is [instr_1] :: instr_2*.
    - valtype* is t_1*.
    - valtype'* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr'* is instr*.
    - valtype* is t* :: t_1*.
    - valtype'* is t* :: t_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t? if:
  - instr* is valid with the function type [] -> t?.

Instr_const
- the instruction instr is constant if:
  - Either:
    - instr is (t.CONST c).
  - Or:
    - instr is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (t.CONST c) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2?] with .RETURN appended by ?(t_2?), the expression expr is valid with the result type t_2?.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the number type ?(t).
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elem_ok
- the table segment (ELEM expr x*) is valid if:
  - the limits C.TABLES[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.
  - |ft*| is |x*|.
  - For all x in x*:
    - the function type C.FUNCS[x] exists.
  - For all ft in ft*, and corresponding x in x*:
    - C.FUNCS[x] is ft.

Data_ok
- the memory segment (DATA expr b*) is valid if:
  - the limits C.MEMS[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (FUNC x).
    - externtype is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data* start? export*) is valid if:
  - |ft'*| is |type*|.
  - For all ft' in ft'*, and corresponding type in type*:
    - the type type is valid with the function type ft'.
  - |import*| is |ixt*|.
  - For all import in import*, and corresponding ixt in ixt*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - |global*| is |gt*|.
  - For all global in global*, and corresponding gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |ft*| is |func*|.
  - For all ft in ft*, and corresponding func in func*:
    - the function func is valid with the function type ft.
  - |table*| is |tt*|.
  - For all table in table*, and corresponding tt in tt*:
    - the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem*, and corresponding mt in mt*:
    - the memory mem is valid with the memory type mt.
  - For all elem in elem*:
    - the table segment elem is valid.
  - For all data in data*:
    - the memory segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |xt*|.
  - For all export in export*, and corresponding xt in xt*:
    - the export export is valid with the external type xt.
  - |tt*| is less than or equal to 1.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; RETURN: ?() }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if t? instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK t? instr_1*).
4. Else:
  a. Execute the instruction (BLOCK t? instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br n'
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
3. If (n' = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the label (LABEL_ _ { _ }) from the stack.
  e. Push the values val^n to the stack.
  f. Execute the sequence instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n' >= 1), then:
    1) Let l be (n' - 1).
    2) Pop the label (LABEL_ _ { _ }) from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop t unop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$unop_(t, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(t, unop, c_1).
5. Push the value (t.CONST c) to the stack.

Step_pure/binop t binop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. If (|$binop_(t, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(t, binop, c_1, c_2).
7. Push the value (t.CONST c) to the stack.

Step_pure/testop t testop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. Let c be $testop_(t, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop t relop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. Let c be $relop_(t, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop t_2 t_1 cvtop
1. Assert: Due to validation, a value of value type t_1 is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(t_1, t_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(t_1, t_2, cvtop, c_1).
5. Push the value (t_2.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block t? instr*
1. Let n be 0.
2. If t? is not defined, then:
  a. Enter instr* with label (LABEL_ n { [] }).
3. Let n be 1.
4. If (t? =/= ?()), then:
  a. Enter instr* with label (LABEL_ n { [] }).

Step_read/loop t? instr*
1. Enter instr* with label (LABEL_ 0 { [(LOOP t? instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, 0).REFS|), then:
  a. Trap.
5. If $table(z, 0).REFS[i] is not defined, then:
  a. Trap.
6. Let ?(a) be $table(z, 0).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, x) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let (LOCAL t)* be local_0*.
6. Assert: Due to validation, there are at least k values on the top of the stack.
7. Pop the values val^k from the stack.
8. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
9. Push the frame (FRAME_ n { f }) to the stack.
10. Enter instr* with label (LABEL_ n { [] }).

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/load t' loadop_? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(t') / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let c be $bytes__1^-1(t', $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t') / 8)]).
  c. Push the value (t'.CONST c) to the stack.
5. If (t' is Inn /\ loadop_? is defined), then:
  a. Let ?(loadop__0) be loadop_?.
  b. Let n _ sx be loadop__0.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  d. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
  e. Push the value (t'.CONST $extend__(n, $size(t'), sx, c)) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/store t' sz? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (t''.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((((i + ao.OFFSET) + ($size(t'') / 8)) > |$mem(z, 0).BYTES|) /\ ((t' = t'') /\ sz? is not defined)), then:
  a. Trap.
7. If ((t' = t'') /\ sz? is not defined), then:
  a. Let b* be $bytes_(t'', c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t'') / 8), b*).
8. If (t'' is Inn /\ ((t' = t'') /\ sz? is defined)), then:
  a. Let ?(n) be sz?.
  b. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let b* be $ibytes_(n, $wrap__($size(t''), n, c)).
  d. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X*| = 1).
3. Let [w] be X*.
4. Return ?(w).

list_ `X X?
1. If X? is not defined, then:
  a. Return [].
2. Let ?(w) be X?.
3. Return [w].

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

signif N
1. If (N = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N = 64).
3. Return 52.

expon N
1. If (N = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size valtype
1. If (valtype = I32), then:
  a. Return 32.
2. If (valtype = I64), then:
  a. Return 64.
3. If (valtype = F32), then:
  a. Return 32.
4. If (valtype = F64), then:
  a. Return 64.
5. Fail.

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ valtype unop_ iN'
1. If valtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($size(valtype), iN')].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($size(valtype), iN')].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($size(valtype), iN')].
2. Assert: Due to validation, valtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($size(valtype), iN').
4. If (unop_ = NEG), then:
  a. Return $fneg_($size(valtype), iN').
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($size(valtype), iN').
6. If (unop_ = CEIL), then:
  a. Return $fceil_($size(valtype), iN').
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($size(valtype), iN').
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($size(valtype), iN').
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($size(valtype), iN').

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

binop_ valtype binop_ iN_1' iN_2'
1. If valtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($size(valtype), iN_1', iN_2')].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($size(valtype), iN_1', iN_2')].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($size(valtype), iN_1', iN_2')].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $list_(`val_((Inn : Inn <: valtype)), $idiv_($size(valtype), sx, iN_1', iN_2')).
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $list_(`val_((Inn : Inn <: valtype)), $irem_($size(valtype), sx, iN_1', iN_2')).
  f. If (binop_ = AND), then:
    1) Return [$iand_($size(valtype), iN_1', iN_2')].
  g. If (binop_ = OR), then:
    1) Return [$ior_($size(valtype), iN_1', iN_2')].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($size(valtype), iN_1', iN_2')].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($size(valtype), iN_1', iN_2')].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($size(valtype), sx, iN_1', iN_2')].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($size(valtype), iN_1', iN_2')].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($size(valtype), iN_1', iN_2')].
2. Assert: Due to validation, valtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($size(valtype), iN_1', iN_2').
4. If (binop_ = SUB), then:
  a. Return $fsub_($size(valtype), iN_1', iN_2').
5. If (binop_ = MUL), then:
  a. Return $fmul_($size(valtype), iN_1', iN_2').
6. If (binop_ = DIV), then:
  a. Return $fdiv_($size(valtype), iN_1', iN_2').
7. If (binop_ = MIN), then:
  a. Return $fmin_($size(valtype), iN_1', iN_2').
8. If (binop_ = MAX), then:
  a. Return $fmax_($size(valtype), iN_1', iN_2').
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($size(valtype), iN_1', iN_2').

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

testop_ Inn EQZ iN
1. Return $ieqz_($size(Inn), iN).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

relop_ valtype relop_ iN_1' iN_2'
1. If valtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($size(valtype), iN_1', iN_2').
  b. If (relop_ = NE), then:
    1) Return $ine_($size(valtype), iN_1', iN_2').
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($size(valtype), sx, iN_1', iN_2').
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($size(valtype), sx, iN_1', iN_2').
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($size(valtype), sx, iN_1', iN_2').
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($size(valtype), sx, iN_1', iN_2').
2. Assert: Due to validation, valtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($size(valtype), iN_1', iN_2').
4. If (relop_ = NE), then:
  a. Return $fne_($size(valtype), iN_1', iN_2').
5. If (relop_ = LT), then:
  a. Return $flt_($size(valtype), iN_1', iN_2').
6. If (relop_ = GT), then:
  a. Return $fgt_($size(valtype), iN_1', iN_2').
7. If (relop_ = LE), then:
  a. Return $fle_($size(valtype), iN_1', iN_2').
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($size(valtype), iN_1', iN_2').

cvtop__ valtype valtype' cvtop iN'
1. If cvtop is some EXTEND, then:
  a. Let (EXTEND sx) be cvtop.
  b. If ((valtype = I32) /\ (valtype' = I64)), then:
    1) Return [$extend__(32, 64, sx, iN')].
2. If ((valtype = I64) /\ ((valtype' = I32) /\ (cvtop = WRAP))), then:
  a. Return [$wrap__(64, 32, iN')].
3. If (valtype is Fnn /\ (valtype' is Inn /\ cvtop is some TRUNC)), then:
  a. Let (TRUNC sx) be cvtop.
  b. Return $list_(`val_((Inn : Inn <: valtype)), $trunc__($size(valtype), $size(valtype'), sx, iN')).
4. If ((valtype = F32) /\ ((valtype' = F64) /\ (cvtop = PROMOTE))), then:
  a. Return $promote__(32, 64, iN').
5. If ((valtype = F64) /\ ((valtype' = F32) /\ (cvtop = DEMOTE))), then:
  a. Return $demote__(64, 32, iN').
6. If (valtype is Inn /\ valtype' is Fnn), then:
  a. If cvtop is some CONVERT, then:
    1) Let (CONVERT sx) be cvtop.
    2) Return [$convert__($size(valtype), $size(valtype'), sx, iN')].
  b. If ((cvtop = REINTERPRET) /\ ($size(valtype) = $size(valtype'))), then:
    1) Return [$reinterpret__(valtype, valtype', iN')].
7. Assert: Due to validation, valtype is Fnn.
8. Assert: Due to validation, valtype' is Inn.
9. Assert: Due to validation, (cvtop = REINTERPRET).
10. Assert: Due to validation, ($size(valtype') = $size(valtype)).
11. Return [$reinterpret__(valtype, valtype', iN')].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

default_ valtype
1. If (valtype = I32), then:
  a. Return (I32.CONST 0).
2. If (valtype = I64), then:
  a. Return (I64.CONST 0).
3. If (valtype = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. Assert: Due to validation, (valtype = F64).
5. Return (F64.CONST $fzero(64)).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $funcsxa(xv*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $globalsxa(xv*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $tablesxa(xv*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i a
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with ?(a).

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

growtable ti n
1. Let { TYPE: ([ i .. j ]); REFS: ?(a)* } be ti.
2. Let i' be (|a*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: ([ i' .. j ]); REFS: ?(a)* :: ?()^n }.
  b. Return ti'.
4. Fail.

growmemory mi n
1. Let { TYPE: ([ i .. j ]); BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]); BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.
4. Fail.

funcs externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $funcs(externaddr'*).

globals externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $globals(externaddr'*).

tables externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $tables(externaddr'*).

mems externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s ([ i .. j ])
1. Let ti be { TYPE: ([ i .. j ]); REFS: ?()^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tabletype''*
1. If (tabletype''* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype''*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ])
1. Let mi be { TYPE: ([ i .. j ]); BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

instexport fa* ga* ta* ma* (EXPORT name externidx)
1. If externidx is some FUNC, then:
  a. Let (FUNC x) be externidx.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM x) be externidx.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val*
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem* data* start? export*) be module.
2. Let (MEMORY memtype)^n_mem be mem_3*.
3. Let (TABLE tabletype)^n_table be table_2*.
4. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
5. Let (TYPE ft)* be type_0*.
6. Let fa_ex* be $funcs(externaddr*).
7. Let ga_ex* be $globals(externaddr*).
8. Let ma_ex* be $mems(externaddr*).
9. Let ta_ex* be $tables(externaddr*).
10. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
11. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
12. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
13. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
14. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
15. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; EXPORTS: xi* }.
16. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
17. Assert: Due to validation, (funcaddr_0* = fa*).
18. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
19. Assert: Due to validation, (globaladdr_0* = ga*).
20. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
21. Assert: Due to validation, (tableaddr_0* = ta*).
22. Let memaddr_0* be $allocmems(s, memtype^n_mem).
23. Assert: Due to validation, (memaddr_0* = ma*).
24. Return moduleinst.

initelem s moduleinst u32* funcaddr*
1. If ((u32* = []) /\ (funcaddr* = [])), then:
  a. Return.
2. Assert: Due to validation, (|funcaddr*| >= 1).
3. Let [a*] :: a'** be funcaddr*.
4. Assert: Due to validation, (|u32*| >= 1).
5. Let [i] :: i'* be u32*.
6. Replace s.TABLES[moduleinst.TABLES[0]].REFS[i : |a*|] with ?(a)*.
7. Perform $initelem(s, moduleinst, i'*, a'**).
8. Return.

initdata s moduleinst u32* byte*
1. If ((u32* = []) /\ (byte* = [])), then:
  a. Return.
2. Assert: Due to validation, (|byte*| >= 1).
3. Let [b*] :: b'** be byte*.
4. Assert: Due to validation, (|u32*| >= 1).
5. Let [i] :: i'* be u32*.
6. Replace s.MEMS[moduleinst.MEMS[0]].BYTES[i : |b*|] with b*.
7. Perform $initdata(s, moduleinst, i'*, b'**).
8. Return.

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let (TYPE functype)* be type*.
3. Let n_F be |func*|.
4. Let (START x')? be start?.
5. Let (DATA expr_D b*)* be data*.
6. Let (ELEM expr_E x*)* be elem*.
7. Let (GLOBAL globaltype expr_G)* be global*.
8. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
9. Let f_init be { MODULE: moduleinst_init }.
10. Let z be (s, f_init).
11. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
12. Let [(I32.CONST i_D)]* be $Eval_expr(z, expr_D)*.
13. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
14. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
15. Let [(I32.CONST i_E)]* be $Eval_expr(z, expr_E)*.
16. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
17. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
18. Let [val]* be $Eval_expr(z, expr_G)*.
19. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
20. Let moduleinst be $allocmodule(s, module, externaddr*, val*).
21. Let f be { MODULE: moduleinst }.
22. Perform $initelem(s, moduleinst, i_E*, moduleinst.FUNCS[x]**).
23. Perform $initdata(s, moduleinst, i_D*, b**).
24. Push the frame (FRAME_ 0 { f }) to the stack.
25. If (CALL x')? is defined, then:
  a. Let ?(instr_0) be (CALL x')?.
  b. Execute the instruction instr_0.
26. Pop the frame (FRAME_ 0 { f }) from the stack.
27. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the frame (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the frame (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the frame (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop the values val'^k from the stack.
10. Pop the frame (FRAME_ k { f }) from the stack.
11. Return val'^k.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 2.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[ n .. m ]` is :ref:`valid <valid-val>` with :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is always :ref:`valid <valid-val>`.




The global type :math:`({\mathsf{mut}^?}~t)` is always :ref:`valid <valid-val>`.




The table type :math:`({\mathit{limits}}~{\mathit{reftype}})` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}~\mathsf{page}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{16}}`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is :ref:`valid <valid-val>` if:


   * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The value type :math:`{t'}` :ref:`matches <match>` the value type :math:`t` if:


   * Either:

      * The value type :math:`{t'}` is of the form :math:`t`.

   * Or:

      * The value type :math:`{t'}` is of the form :math:`\mathsf{bot}`.




The value type :math:`t` :ref:`matches <match>` only itself.




The value type :math:`\mathsf{bot}` :ref:`matches <match>` the value type :math:`t`.




The result type :math:`{t_1^\ast}` :ref:`matches <match>` the result type :math:`{t_2^\ast}` if:


   * The length of :math:`{t_1^\ast}` is equal to the length of :math:`{t_2^\ast}`.

   * For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`t_2` in :math:`{t_2^\ast}`:

      * The value type :math:`t_1` :ref:`matches <match>` the value type :math:`t_2`.




The limits :math:`{}[ n_{11} .. n_{12} ]` :ref:`matches <match>` the limits :math:`{}[ n_{21} .. n_{22} ]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` :ref:`matches <match>` only itself.




The global type :math:`{\mathit{gt}}` :ref:`matches <match>` only itself.




The table type :math:`({\mathit{lim}}_1~{\mathit{rt}})` :ref:`matches <match>` the table type :math:`({\mathit{lim}}_2~{\mathit{rt}})` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1~\mathsf{page}` :ref:`matches <match>` the memory type :math:`{\mathit{lim}}_2~\mathsf{page}` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{externtype}}` :ref:`matches <match>` the external type :math:`{\mathit{externtype}'}` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}'}^\ast}~\rightarrow~{{\mathit{valtype}''}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{{\mathit{valtype}}^?}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}''}^\ast}` is of the form :math:`{{\mathit{valtype}}^?}`.

   * Or:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{\mathit{typeidx}}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}''}^\ast}` is of the form :math:`{t_2^\ast}`.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The block type :math:`{{\mathit{valtype}}^?}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}`.




The block type :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{select}~{{\mathit{valtype}}^?})` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * Either:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is of the form :math:`t`.

   * Or:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is absent.

      * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

      * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the result type :math:`C{.}\mathsf{labels}{}[l]`.

   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~\mathsf{funcref})`.

   * The function type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[y]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^\ast}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}'}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}'}` is of the form :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.

   * Or:

      * :math:`{\mathit{cvtop}'}` is of the form :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{\mathit{rt}}`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{funcref}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The instruction :math:`\mathsf{ref{.}is\_null}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{rt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}^?}}~i)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`(\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{lim}}_1~{\mathit{rt}})`.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is of the form :math:`({\mathit{lim}}_2~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}init}~x_1~x_2)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The element type :math:`C{.}\mathsf{elems}{}[x_2]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x_2]` is of the form :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x]` is of the form :math:`{\mathit{rt}}`.




The instruction :math:`\mathsf{memory{.}size}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}fill}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}copy}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.




The instruction :math:`(\mathsf{memory{.}init}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{valtype}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * Either:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}'}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{valtype}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * Either:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathit{nt}}`.

      * The pack size :math:`{{\mathit{sz}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}^?}` is of the form :math:`M`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{\mathit{vloadop}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * Either:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.

   * Or:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({n}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.
   * Or:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({n}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`(\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{select}~t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{select})` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

   * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{load}~{\mathit{nt}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{store}~{\mathit{nt}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{splat}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{zero}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{{\mathit{instr}}^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{{t'}_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{{t'}_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The result type :math:`{{t'}_1^\ast}` :ref:`matches <match>` the result type :math:`{t_1^\ast}`.

      * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{{\mathit{instr}}^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t^\ast}~{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{t'}_1^\ast}~\rightarrow~{{t'}_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The result type :math:`{{t'}_1^\ast}` :ref:`matches <match>` the result type :math:`{t_1^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^\ast}`.




:math:`{\mathit{val}}` is constant if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{nt}}{.}\mathsf{const}~c)`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{rt}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`({\mathit{nt}}{.}\mathsf{const}~c)` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is :ref:`valid <valid-val>`.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{gt}}` is of the form :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is :ref:`valid <valid-val>`.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is :ref:`valid <valid-val>`.




:math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * Either:

      * :math:`{\mathit{elemmode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{passive}`.
   * Or:

      * :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{declare}`.




:math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




:math:`\mathsf{declare}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}`.

      * :math:`{\mathit{expr}}` is constant.

   * :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




:math:`{\mathit{datamode}}` is :ref:`valid <valid-val>` if:


   * Either:

      * :math:`{\mathit{datamode}}` is of the form :math:`(\mathsf{active}~0~{\mathit{expr}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{datamode}}` is of the form :math:`\mathsf{passive}`.




:math:`(\mathsf{active}~0~{\mathit{expr}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is of the form :math:`{\mathit{mt}}`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is always :ref:`valid <valid-val>`.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is :ref:`valid <valid-val>` if:


   * :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>`.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^{n}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` if:


   * The length of :math:`{{\mathit{ft}'}^\ast}` is equal to the length of :math:`{{\mathit{type}}^\ast}`.

   * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}`, and corresponding :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}'}`.

   * The length of :math:`{{\mathit{import}}^\ast}` is equal to the length of :math:`{{\mathit{ixt}}^\ast}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`, and corresponding :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{ixt}}`.

   * The length of :math:`{{\mathit{global}}^\ast}` is equal to the length of :math:`{{\mathit{gt}}^\ast}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, and corresponding :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}`.

   * The length of :math:`{{\mathit{table}}^\ast}` is equal to the length of :math:`{{\mathit{tt}}^\ast}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, and corresponding :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * The length of :math:`{{\mathit{mem}}^\ast}` is equal to the length of :math:`{{\mathit{mt}}^\ast}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`, and corresponding :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * The length of :math:`{{\mathit{elem}}^\ast}` is equal to the length of :math:`{{\mathit{rt}}^\ast}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, and corresponding :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

      * Under the context :math:`{C'}`, the table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * Under the context :math:`{C'}`, the memory segment :math:`{\mathit{data}}` is :ref:`valid <valid-val>`.

   * The length of :math:`{{\mathit{ft}}^\ast}` is equal to the length of :math:`{{\mathit{func}}^\ast}`.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}`, and corresponding :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * The length of :math:`{{\mathit{export}}^\ast}` is equal to the length of :math:`{{\mathit{xt}}^\ast}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, and corresponding :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.

   * The length of :math:`{{\mathit{mt}}^\ast}` is less than or equal to :math:`1`.

   * The context :math:`C` is of the form :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~{{\mathit{rt}}^\ast},\; \mathsf{datas}~{\mathsf{ok}^{n}},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The context :math:`{C'}` is of the form :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` L from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~{n'}`
........................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let L be the topmost :math:`\mathsf{label}`.

#. Let :math:`n` be the arity of L

#. If :math:`{n'} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Jump to the continuation of L.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`{n'} \geq 1`, then:

      1) Let :math:`l` be the label index :math:`{n'} - 1`.

      #) Pop the :math:`\mathsf{label}` L from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of f

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let f be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of f

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` F from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{reftype}}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} \mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. If :math:`{({\mathit{ci}}_1 \neq 0)^\ast}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} {\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{N}}{({c'}, n)}^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}~{0^{32 - N}}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{\mathrm{irev}}}_{32}({\mathit{ci}}))` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, :math:`{({{\mathit{ci}}^\ast}{}[k] < {|{{c'}^\ast}|})^{k<M}}`.

#. Assert: Due to validation, :math:`{(k < {|{{\mathit{ci}}^\ast}|})^{k<M}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{(k < {|{i^\ast}|})^{k<N}}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_2)`.

#. Assert: Due to validation, :math:`{({i^\ast}{}[k] < {|{{c'}^\ast}|})^{k<N}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_1)^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}}{\mathsf{x}}{N}{.}\mathsf{extract\_lane}}{{{\mathit{sx}'}^?}}~i`
.............................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}'}^?}` is not defined and :math:`{\mathit{lanetype}}` is number type and :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1)|}`, then:

   a. Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1){}[i]`.

   #. Push the value :math:`({\mathit{lanetype}}{.}\mathsf{const}~c_2)` to the stack.

#. If :math:`{\mathit{lanetype}}` is packed type and :math:`{{\mathit{sx}'}^?}` is defined, then:

   a. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

   #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1)|}`, then:

      1) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_2)])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}}`
.............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextunop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextunop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}}`
...............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextbinop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextbinop}}, c_1, c_2)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}}({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}} {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}}`
....................................................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{\mathrm{halfop}}({\mathit{vcvtop}})` is defined, then:

   a. Let :math:`{\mathit{half}}` be :math:`{\mathrm{halfop}}({\mathit{vcvtop}})`.

   #. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, {M'}) : {M'}]`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

   #. If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else if :math:`{\mathrm{zeroop}}({\mathit{vcvtop}})` is not defined and :math:`{M'} = {M''}`, then:

   a. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}}(c_1)`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M''}}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

   #. If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M''}}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M''}}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathrm{zeroop}}({\mathit{vcvtop}}) = \mathsf{zero}` and :math:`{{\mathsf{i}}{n}}_{1'}` is number type and :math:`{{\mathsf{i}}{n}}_{2'}` is number type, then:

   a. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}}(c_1)`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_{1'}}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{{\mathrm{zero}}({{\mathsf{i}}{n}}_{2'})^{{M''}}}`.

   #. If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_{2'}}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`k` and whose continuation is the start of the block.

#. Enter the block :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` is not some :math:`\mathsf{ref{.}func\_addr}` :math:`{\mathit{funcaddr}}`, then:

   a. Trap.

#. Let :math:`(\mathsf{ref{.}func\_addr}~a)` be the destructuring of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[y] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be the destructuring of :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Let f be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`n`.

#. Push the :math:`\mathsf{frame}` F.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be the length of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{ao}}`
.............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}'}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}'}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}'}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}'}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathit{nt}'}` is :math:`{\mathsf{i}}{n}` and :math:`{{\mathit{loadop}}^?}` is defined, then:

   a. Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`({\mathit{nt}'}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathit{nt}'}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{{\mathit{vloadop}}^?}~{\mathit{ao}}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}^?}`.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`\mathsf{shape}` :math:`\mathbb{N}` :math:`\mathsf{x}` :math:`\mathbb{N}` :math:`\mathsf{\_}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{N}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}}) = z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<N}}`.

      #) If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`M \cdot 2` is :math:`{\mathsf{i}}{n}`, then:

         a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

         #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`\mathsf{splat}` :math:`\mathbb{N}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

         a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

         #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

         #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`\mathsf{zero}` :math:`\mathbb{N}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
...........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

   #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

   #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}fill}`.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}copy}`.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}{}[i])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x)`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be the table instance :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}'}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{ao}}`
..........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}''}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}''}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}'} = {\mathit{nt}''}` and :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{\mathit{nt}'} = {\mathit{nt}''}` and :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}''}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}''}|} / 8] = {b^\ast}]`.

#. If :math:`{\mathit{nt}''}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{nt}'} = {\mathit{nt}''}` and :math:`{{\mathit{sz}}^?}` is defined, then:

   a. Let :math:`n` be :math:`{{\mathit{sz}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathit{nt}''}|}, n}(c))`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{ao}}`
..................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

   #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c)|}`, then:

      1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c){}[j])`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({{n''}^\ast})`
....................................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X^\ast}`.

#. Return :math:`w`.


:math:`{X^?}`
.............


1. If :math:`{X^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X^\ast})`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X^\ast})`
.............................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X^\ast}, {{w^\ast}^\ast})`
.........................................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`{\Large\times}~{X^\ast}`
...............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, {\Large\times}~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|{\mathit{valtype}}|}`
..............................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`128`.

#. Fail.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathit{packtype}}|}`
...............................


1. If :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}|}`
...............................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{|{\mathit{lanetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{|{\mathit{lanetype}}|}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{n}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{zero}}({\mathit{numtype}})`
...........................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{n}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{n}|} \cdot N`.


:math:`{\mathrm{concat}}({{\mathit{byte}}^\ast})`
.................................................


1. If :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

#. Return :math:`{b^\ast}~{\mathrm{concat}}({{{b'}^\ast}^\ast})`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}})`
..............................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathit{lanetype}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{dataidx}}({\mathit{instr}})`
............................................


1. If :math:`{\mathit{instr}}` is some :math:`\mathsf{memory{.}init}` :math:`{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~x)` be the destructuring of :math:`{\mathit{instr}}`.

   #. Return :math:`x`.

#. If :math:`{\mathit{instr}}` is some :math:`\mathsf{data{.}drop}` :math:`{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{data{.}drop}~x)` be the destructuring of :math:`{\mathit{instr}}`.

   #. Return :math:`x`.

#. Return :math:`\epsilon`.


:math:`{\mathrm{dataidx}}({{\mathit{instr}''}^\ast})`
.....................................................


1. If :math:`{{\mathit{instr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{instr}}~{{\mathit{instr}'}^\ast}` be :math:`{{\mathit{instr}''}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{instr}})~{\mathrm{dataidx}}({{\mathit{instr}'}^\ast})`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`
................................................


1. Return :math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`.


:math:`{\mathrm{dataidx}}(\mathsf{func}~x~{{\mathit{loc}}^\ast}~e)`
...................................................................


1. Return :math:`{\mathrm{dataidx}}(e)`.


:math:`{\mathrm{dataidx}}({{\mathit{func}''}^\ast})`
....................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{func}})~{\mathrm{dataidx}}({{\mathit{func}'}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

   a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

   a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

   a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

   a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}'})}`
....................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}'})`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}` is some :math:`\mathsf{extend}` :math:`n`.

   #. Let :math:`(\mathsf{extend}~M)` be the destructuring of :math:`{\mathit{unop}}`.

   #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}'}))}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{iN}'})`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{iN}'})`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{iN}'})`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`
.............................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{div}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{rem}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{shr}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`
.............................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{lt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{gt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{le}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{ge}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{iN}}_{1'}, {\mathit{iN}}_{2'})`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{numtype}}, {\mathit{numtype}''}}}{({\mathit{iN}}_{1'})}`
...............................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

      1) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_{1'})`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

   #. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{cvtop}}` is some :math:`\mathsf{convert}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{convert}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{n}`, then:

   a. If :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

      1) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{iN}}_{1'})`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

      1) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{iN}}_{1'})`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}''}|}`, then:

   a. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}''}}({\mathit{iN}}_{1'})`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}''}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}''}}({\mathit{iN}}_{1'})`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({-{{\mathrm{signed}}}_{N}(i_1)})}`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

   a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}}(c)`
..................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{lanetype}})|}, {|{\mathit{lanetype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}}(c)`
....................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, {|{\mathrm{unpack}}({\mathit{lanetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{invlanes}}}_{{\mathit{sh}}}({c^\ast})`
.......................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{zeroop}}({\mathit{vcvtop}})`
............................................


1. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

   a. Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{{\mathit{zero}}^?}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{demote}` :math:`{\mathit{zero}}`, then:

   a. Let :math:`(\mathsf{demote}~{\mathit{zero}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{zero}}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\epsilon`.


:math:`{\mathrm{halfop}}({\mathit{vcvtop}})`
............................................


1. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{extend}~{\mathit{half}}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{half}}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{{\mathit{half}}^?}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{demote}` :math:`{\mathit{zero}}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\mathsf{low}`.


:math:`{\mathrm{half}}({\mathit{half}}, i, j)`
..............................................


1. If :math:`{\mathit{half}} = \mathsf{low}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{half}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.........................................................................................................................................................


1. If :math:`{\mathit{vvbinop}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathit{vunop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)}`
....................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{iabs}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{ineg}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}} = \mathsf{popcnt}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{ipopcnt}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fabs}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fneg}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{sqrt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fsqrt}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{ceil}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fceil}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{floor}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{ffloor}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{trunc}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{ftrunc}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vunop}} = \mathsf{nearest}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fnearest}}}_{N}({\mathit{lane}}_1)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vbinop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
..................................................................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{iadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{isub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{min}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imin}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{max}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imax}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{add\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{sub\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iavgr}}}_{N}^{\mathsf{u}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr\_sat}}}_{N}^{\mathsf{s}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fsub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{div}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fdiv}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{min}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{max}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmin}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fpmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}} = \mathsf{pmax}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fpmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vrelop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
..................................................................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ieq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ine}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{lt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{lt}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{gt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{gt}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{le}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{le}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{ge}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{ge}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{feq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fne}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{lt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{flt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{gt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fgt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{le}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fle}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}} = \mathsf{ge}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

#. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fge}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

#. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

#. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lanetype}'}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{iN}}_{1'})`
....................................................................................................................................................


1. If :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{extend}~{\mathit{half}}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

      #) Return :math:`{\mathit{iN}}_2`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

      #) Return :math:`{\mathit{fN}}_2`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

   a. Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_{1'})}`.

   #. Return :math:`{{\mathit{iN}}_2^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vcvtop}} = (\mathsf{demote}~\mathsf{zero})`, then:

   a. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{iN}}_{1'})`.

   #. Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{iN}}_{1'})`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{{\mathrm{vextunop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(\mathsf{extadd\_pairwise}~{\mathit{sx}}, c_1)`
............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` is :math:`{{{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{\mathrm{vextbinop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vextbinop}}, c_1, c_2)`
...............................................................................................................................................


1. If :math:`{\mathit{vextbinop}}` is some :math:`\mathsf{extmul}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vextbinop}}`.

   #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_1) : M_1]`.

   #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2){}[{\mathrm{half}}({\mathit{half}}, 0, M_1) : M_1]`.

   #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})`.

   #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}} = `.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{M}}{({\mathit{lane}}, n)}`
...................................................................................................


1. If :math:`{\mathit{vshiftop}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}` is some :math:`\mathsf{shr}` :math:`{\mathit{sx}}`.

#. Let :math:`(\mathsf{shr}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vshiftop}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{funcref}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~\mathsf{funcref})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{externref}`.

#. Return :math:`(\mathsf{ref{.}null}~\mathsf{externref})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n, r)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[ i .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{ti}'}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[ {i'} .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

   #. Return :math:`{\mathit{ti}'}`.

#. Fail.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ]~\mathsf{page},\; \mathsf{bytes}~{b^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{mi}'}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ {i'} .. j ]~\mathsf{page},\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

   #. Return :math:`{\mathit{mi}'}`.

#. Fail.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}})`
........................................................


1. If :math:`{\mathit{blocktype}} = ()`, then:

   a. Return :math:`\epsilon~\rightarrow~\epsilon`.

#. If :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`, then:

   a. Let :math:`{{\mathit{valtype}}_0^?}` be the block type :math:`{\mathit{blocktype}}`.

   #. If :math:`{{\mathit{valtype}}_0^?}` is defined, then:

      1) Let :math:`t` be :math:`{{\mathit{valtype}}_0^?}`.

      #) Return :math:`\epsilon~\rightarrow~t`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`.

#. Let :math:`x` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`z{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}''}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}''}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}''}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be the function instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}''}^\ast})`
.................................................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be the global instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})`
...........................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[ i .. j ]~{\mathit{rt}})`
............................................................


1. Let :math:`{\mathit{ti}}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[ i .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{(\mathsf{ref{.}null}~{\mathit{rt}})^{i}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}''}^\ast})`
................................................................


1. If :math:`{{\mathit{tabletype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[ i .. j ]~\mathsf{page})`
..........................................................


1. Let :math:`{\mathit{mi}}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[ i .. j ]~\mathsf{page},\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}''}^\ast})`
............................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`
.....................................................................


1. Let :math:`{\mathit{ei}}` be the element instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{rt}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{elems}`.

#. Append :math:`{\mathit{ei}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}(s, {{\mathit{reftype}}^\ast}, {{\mathit{ref}''}^\ast})`
....................................................................................


1. If :math:`{{\mathit{reftype}}^\ast} = \epsilon` and :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: :math:`{|{{\mathit{ref}''}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

#. Assert: :math:`{|{{\mathit{reftype}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{reftype}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`
.......................................................


1. Let :math:`{\mathit{di}}` be the data instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{datas}`.

#. Append :math:`{\mathit{di}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}(s, {{\mathit{byte}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{byte}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{byte}}^\ast}~{{{\mathit{byte}'}^\ast}^\ast}` be :math:`{{\mathit{byte}''}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}(s, {{{\mathit{byte}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`
.......................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}_4^\ast}~{{\mathit{data}}_5^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^{n_{\mathit{data}}}}` be :math:`{{\mathit{data}}_5^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}_2^\ast}~{\mathit{elemmode}})^{n_{\mathit{elem}}}}` be :math:`{{\mathit{elem}}_4^\ast}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}` for all :math:`i_{\mathit{func}}` from :math:`0` to :math:`n_{\mathit{func}} - 1`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{|s{.}\mathsf{globals}|} + i_{\mathit{global}}` for all :math:`i_{\mathit{global}}` from :math:`0` to :math:`n_{\mathit{global}} - 1`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{|s{.}\mathsf{tables}|} + i_{\mathit{table}}` for all :math:`i_{\mathit{table}}` from :math:`0` to :math:`n_{\mathit{table}} - 1`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}` for all :math:`i_{\mathit{mem}}` from :math:`0` to :math:`n_{\mathit{mem}} - 1`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{|s{.}\mathsf{elems}|} + i_{\mathit{elem}}` for all :math:`i_{\mathit{elem}}` from :math:`0` to :math:`n_{\mathit{elem}} - 1`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{|s{.}\mathsf{datas}|} + i_{\mathit{data}}` for all :math:`i_{\mathit{data}}` from :math:`0` to :math:`n_{\mathit{data}} - 1`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}^{n_{\mathit{elem}}}}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{\mathrm{allocdatas}}(s, {({{\mathit{byte}}^\ast})^{n_{\mathit{data}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{runelem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}, i)`
..........................................................................................................


1. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~i)`.

#. Assert: :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}` :math:`{\mathit{tableidx}}` :math:`{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~x~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{elemmode}}`.

#. Let :math:`n` be the length of :math:`{{\mathit{expr}}^\ast}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~x~i)~(\mathsf{elem{.}drop}~i)`.


:math:`{\mathrm{rundata}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}, i)`
.......................................................................................


1. If :math:`{\mathit{datamode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}` :math:`{\mathit{memidx}}` :math:`{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~{\mathit{memidx}}_0~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{datamode}}`.

#. Assert: Due to validation, :math:`{\mathit{memidx}}_0 = 0`.

#. Let :math:`n` be the length of :math:`{{\mathit{byte}}^\ast}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~i)~(\mathsf{data{.}drop}~i)`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{d}}` be the length of :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`n_{\mathsf{e}}` be the length of :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be the length of :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{\mathrm{rundata}}({{\mathit{data}}^\ast}{}[j], j)^{j<n_{\mathsf{d}}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{\mathrm{runelem}}({{\mathit{elem}}^\ast}{}[i], i)^{i<n_{\mathsf{e}}}}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be the state :math:`(s, f_{\mathit{init}})`.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{\mathit{val}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{{\mathit{ref}}^\ast}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Let f be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` F.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{(\mathsf{call}~x)^?}` is defined, then:

   a. Let :math:`{\mathit{instr}}_0` be :math:`{(\mathsf{call}~x)^?}`.

   #. Execute the instruction :math:`{\mathit{instr}}_0`.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}`.

#. Let F be the :math:`\mathsf{frame}` :math:`(s, f)`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be the destructuring of :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :math:`\mathsf{frame}` _f from the stack.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let f be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` F.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2* is always valid.

Globaltype_ok
- the global type (MUT? t) is always valid.

Tabletype_ok
- the table type (limits reftype) is valid if:
  - the limits limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with (2 ^ 16).

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Valtype_sub
- the value type t' matches the value type t if:
  - Either:
    - t' is t.
  - Or:
    - t' is BOT.

Valtype_sub/refl
- t matches only itself.

Valtype_sub/bot
- the value type BOT matches t.

Resulttype_sub
- the result type t_1* matches the result type t_2* if:
  - |t_1*| is |t_2*|.
  - For all t_1 in t_1*, and corresponding t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches only itself.

Globaltype_sub
- the global type gt matches only itself.

Tabletype_sub
- the table type (lim_1 rt) matches the table type (lim_2 rt) if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 PAGE matches the memory type lim_2 PAGE if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type externtype matches the external type externtype' if:
  - Either:
    - externtype is (FUNC ft_1).
    - externtype' is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype is (GLOBAL gt_1).
    - externtype' is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype is (TABLE tt_1).
    - externtype' is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype is (MEM mt_1).
    - externtype' is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Blocktype_ok
- the block type blocktype is valid with the function type valtype'* -> valtype''* if:
  - Either:
    - blocktype is (_RESULT valtype?).
    - the value type sequence valtype'* is [].
    - the value type sequence valtype''* is valtype?.
  - Or:
    - blocktype is (_IDX typeidx).
    - valtype'* is t_1*.
    - valtype''* is t_2*.
    - the function type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is t_1* -> t_2*.

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid with the function type [] -> valtype?.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is t_1* -> t_2*.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction (SELECT valtype?) is valid with the function type [t, t, I32] -> [t] if:
  - Either:
    - the value type sequence valtype? is ?([t]).
  - Or:
    - valtype? is ?().
    - the value type t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with t_1* -> t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with t_1* -> t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - the result type t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2* if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2*.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x y) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim FUNCREF).
  - the function type C.TYPES[y] exists.
  - C.TYPES[y] is t_1* -> t_2*.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the function type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the function type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the function type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the function type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the function type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop') is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop' is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop' is cvtop.

Instr_ok/ref.null
- the instruction (REF.NULL rt) is valid with the function type [] -> [rt].

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the function type [] -> [FUNCREF] if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the function type [rt] -> [I32].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the function type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the function type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the function type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the function type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop_sh) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop_sh) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop_sh) is valid with the function type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the function type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the function type [t] -> [V128] if:
  - Let t be the number type $shunpack(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the function type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the function type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the function type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the function type [I32] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the function type [I32, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the function type [] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the function type [rt, I32] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the function type [I32, rt, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim_1 rt).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (lim_2 rt).

Instr_ok/table.init
- the instruction (TABLE.INIT x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim rt).
  - the element type C.ELEMS[x_2] exists.
  - C.ELEMS[x_2] is rt.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the function type [] -> [] if:
  - the element type C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.fill
- the instruction MEMORY.FILL is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.copy
- the instruction MEMORY.COPY is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.init
- the instruction (MEMORY.INIT x) is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the function type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt' loadop_? memarg) is valid with the function type [I32] -> [valtype] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type nt' is nt.
    - loadop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt' is Inn.
    - loadop_? is ?(M _ sx).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt' sz? memarg) is valid with the function type [I32, valtype] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type nt' is nt.
    - the pack size sz? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt' is Inn.
    - sz? is ?(M).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?(vloadop) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - vloadop is (SHAPE M X N _ sx).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop is (SPLAT n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - Or:
    - vloadop is (ZERO n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/vstore
- the instruction (VSTORE V128 memarg) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the function type [t, t, I32] -> [t].

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the function type [t, t, I32] -> [t] if:
  - the value type t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD nt ?() memarg) is valid with the function type [I32] -> [nt] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() memarg) is valid with the function type [I32, nt] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instrs_ok
- the instruction sequence instr'* is valid with the function type valtype* -> valtype'* if:
  - Either:
    - instr'* is [].
    - the value type sequence valtype* is [].
    - the value type sequence valtype'* is [].
  - Or:
    - instr'* is [instr_1] :: instr_2*.
    - valtype* is t_1*.
    - valtype'* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr'* is instr*.
    - valtype* is t'_1*.
    - valtype'* is t'_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.
    - the result type t'_1* matches the result type t_1*.
    - the result type t_2* matches the result type t'_2*.
  - Or:
    - instr'* is instr*.
    - valtype* is t* :: t_1*.
    - valtype'* is t* :: t_2*.
    - instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the function type t'_1* -> t'_2* if:
  - instr* is valid with the function type t_1* -> t_2*.
  - the result type t'_1* matches the result type t_1*.
  - the result type t_2* matches the result type t'_2*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the function type [] -> t*.

Instr_const
- the value val is constant if:
  - Either:
    - val is (nt.CONST c).
  - Or:
    - val is (vt.CONST vc).
  - Or:
    - val is (REF.NULL rt).
  - Or:
    - val is (REF.FUNC x).
  - Or:
    - val is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (nt.CONST c) is constant.

Instr_const/vconst
- the instruction (vt.CONST vc) is constant.

Instr_const/ref.null
- the instruction (REF.NULL rt) is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2*.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elemmode_ok
- elemmode is valid with the reference type rt if:
  - Either:
    - elemmode is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (lim rt).
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode is PASSIVE.
  - Or:
    - elemmode is DECLARE.

Elemmode_ok/active
- (ACTIVE x expr) is valid with the reference type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- PASSIVE is valid with rt.

Elemmode_ok/declare
- DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM rt expr* elemmode) is valid with the reference type rt if:
  - For all expr in expr*:
    - the expression expr is valid with rt.
    - expr is constant.
  - elemmode is valid with rt.

Datamode_ok
- datamode is valid if:
  - Either:
    - datamode is (ACTIVE 0 expr).
    - the memory type C.MEMS[0] is mt.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode is PASSIVE.

Datamode_ok/active
- (ACTIVE 0 expr) is valid if:
  - the memory type C.MEMS[0] is mt.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- PASSIVE is always valid.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - datamode is valid.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (FUNC x).
    - externtype is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data^n start? export*) is valid if:
  - |ft'*| is |type*|.
  - For all ft' in ft'*, and corresponding type in type*:
    - the type type is valid with the function type ft'.
  - |import*| is |ixt*|.
  - For all import in import*, and corresponding ixt in ixt*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - |global*| is |gt*|.
  - For all global in global*, and corresponding gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |table*| is |tt*|.
  - For all table in table*, and corresponding tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem*, and corresponding mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |elem*| is |rt*|.
  - For all elem in elem*, and corresponding rt in rt*:
    - Under the context C', the table segment elem is valid with the reference type rt.
  - For all data in data*:
    - Under the context C', the memory segment data is valid.
  - |ft*| is |func*|.
  - For all ft in ft*, and corresponding func in func*:
    - the function func is valid with the function type ft.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |xt*|.
  - For all export in export*, and corresponding xt in xt*:
    - the export export is valid with the external type xt.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: rt*; DATAS: OK^n; RETURN: ?() }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br n'
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
3. If (n' = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the label (LABEL_ _ { _ }) from the stack.
  e. Push the values val^n to the stack.
  f. Execute the sequence instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n' >= 1), then:
    1) Let l be (n' - 1).
    2) Pop the label (LABEL_ _ { _ }) from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vvunop_(V128, vvunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vvbinop_(V128, vvbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vvternop_(V128, vvternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($size(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X N ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. If (ci_1 =/= 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X N vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X N, c_1).
6. Let c be $invlanes_(Jnn X N, $vshiftop_(Jnn X N, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X N
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)* :: 0^(32 - N)).
5. Push the value (I32.CONST $irev_(32, ci)) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $invlanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X N i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<N).
6. Let c'* be $lanes_(Pnn X N, c_1) :: $lanes_(Pnn X N, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<N).
8. Let c be $invlanes_(Pnn X N, c'*[i*[k]]^(k<N)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X N
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Let c be $invlanes_(Lnn X N, $packnum_(Lnn, c_1)^N).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype X N sx'? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx'? is not defined /\ (lanetype is numtype /\ (i < |$lanes_(lanetype X N, c_1)|))), then:
  a. Let c_2 be $lanes_(lanetype X N, c_1)[i].
  b. Push the value (lanetype.CONST c_2) to the stack.
4. If (lanetype is packtype /\ sx'? is defined), then:
  a. Let ?(sx) be sx'?.
  b. If (i < |$lanes_(lanetype X N, c_1)|), then:
    1) Let c_2 be $extend__($psize(lanetype), 32, sx, $lanes_(lanetype X N, c_1)[i]).
    2) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X N i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X N, $lanes_(Lnn X N, c_1) with [i] replaced by $packnum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_1 sh_2 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_1 sh_2 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X N_2 Jnn_1 X N_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X N_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X N_1, c_2).
7. Let cj_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1)*.
8. Let cj_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2)*.
9. Let c be $invlanes_(Jnn_2 X N_2, cj_1* :: cj_2*).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop Lnn_2' X M' Lnn_1' X M'' vcvtop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If $halfop(vcvtop) is defined, then:
  a. Let ?(half) be $halfop(vcvtop).
  b. Let ci* be $lanes_(Lnn_1' X M'', c_1)[$half(half, 0, M') : M'].
  c. Let cj** be $setproduct_(`lane_(Lnn_2), $vcvtop__(Lnn_1' X M'', Lnn_2' X M', vcvtop, ci)*).
  d. If (|$invlanes_(Lnn_2' X M', cj*)*| > 0), then:
    1) Let c be an element of $invlanes_(Lnn_2' X M', cj*)*.
    2) Push the value (V128.CONST c) to the stack.
4. Else if ($zeroop(vcvtop) is not defined /\ (M' = M'')), then:
  a. Let ci* be $lanes_(Lnn_1' X M'', c_1).
  b. Let cj** be $setproduct_(`lane_(Lnn_2), $vcvtop__(Lnn_1' X M'', Lnn_2' X M'', vcvtop, ci)*).
  c. If (|$invlanes_(Lnn_2' X M'', cj*)*| > 0), then:
    1) Let c be an element of $invlanes_(Lnn_2' X M'', cj*)*.
    2) Push the value (V128.CONST c) to the stack.
5. If (($zeroop(vcvtop) = ?(ZERO)) /\ (Lnn_1' is numtype /\ Lnn_2' is numtype)), then:
  a. Let ci* be $lanes_(Lnn_1' X M'', c_1).
  b. Let cj** be $setproduct_(`lane_((nt_2 : numtype <: lanetype)), $vcvtop__(Lnn_1' X M'', Lnn_2' X M', vcvtop, ci)* :: [$zero(Lnn_2')]^M'').
  c. If (|$invlanes_(Lnn_2' X M', cj*)*| > 0), then:
    1) Let c be an element of $invlanes_(Lnn_2' X M', cj*)*.
    2) Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ k { [(LOOP bt instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. If $table(z, x).REFS[i] is not REF.FUNC_ADDR, then:
  a. Trap.
6. Let (REF.FUNC_ADDR a) be $table(z, x).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, y) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let (LOCAL t)* be local_0*.
6. Assert: Due to validation, there are at least k values on the top of the stack.
7. Pop the values val^k from the stack.
8. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
9. Push the frame (FRAME_ n { f }) to the stack.
10. Enter instr* with label (LABEL_ n { [] }).

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Push the value (REF.FUNC_ADDR $funcaddr(z)[x]) to the stack.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$elem(z, y).REFS|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value $elem(z, y).REFS[i] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt' loadop_? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt') / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let c be $nbytes__1^-1(nt', $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt') / 8)]).
  c. Push the value (nt'.CONST c) to the stack.
5. If (nt' is Inn /\ loadop_? is defined), then:
  a. Let ?(loadop__0) be loadop_?.
  b. Let n _ sx be loadop__0.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  d. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
  e. Push the value (nt'.CONST $extend__(n, $size(nt'), sx, c)) to the stack.

Step_read/vload V128 vloadop? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|) /\ vloadop? is not defined), then:
  a. Trap.
5. If vloadop? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop_0) be vloadop?.
  b. If vloadop_0 is some SHAPE, then:
    1) Let (SHAPE M X N _ sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M * N) / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<N).
    4) If $lsize^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsize^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X N, $extend__(M, $lsize(Jnn), sx, j)^N).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is some SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is some ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction MEMORY.FILL.

Step_read/memory.copy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction MEMORY.COPY.

Step_read/memory.init x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$data(z, x).BYTES|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value (I32.CONST $data(z, x).BYTES[i]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt' sz? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (nt''.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((((i + ao.OFFSET) + ($size(nt'') / 8)) > |$mem(z, 0).BYTES|) /\ ((nt' = nt'') /\ sz? is not defined)), then:
  a. Trap.
7. If ((nt' = nt'') /\ sz? is not defined), then:
  a. Let b* be $nbytes_(nt'', c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt'') / 8), b*).
8. If (nt'' is Inn /\ ((nt' = nt'') /\ sz? is defined)), then:
  a. Let ?(n) be sz?.
  b. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let b* be $ibytes_(n, $wrap__($size(nt''), n, c)).
  d. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(V128) / 8), b*).

Step/vstore_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, 0, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X*| = 1).
3. Let [w] be X*.
4. Return ?(w).

list_ `X X?
1. If X? is not defined, then:
  a. Return [].
2. Let ?(w) be X?.
3. Return [w].

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

setproduct2_ `X w_1 X*
1. If (X* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X*.
3. Return [[w_1] :: w'*] :: $setproduct2_(`X, w_1, w**).

setproduct1_ `X X* w**
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setproduct2_(`X, w_1, w**) :: $setproduct1_(`X, w'*, w**).

setproduct_ `X X*
1. If (X* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X*.
3. Return $setproduct1_(`X, w_1*, $setproduct_(`X, w**)).

signif N
1. If (N = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N = 64).
3. Return 52.

expon N
1. If (N = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size valtype
1. If (valtype = I32), then:
  a. Return 32.
2. If (valtype = I64), then:
  a. Return 64.
3. If (valtype = F32), then:
  a. Return 32.
4. If (valtype = F64), then:
  a. Return 64.
5. If (valtype = V128), then:
  a. Return 128.
6. Fail.

isize Inn
1. Return $size(Inn).

psize packtype
1. If (packtype = I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype = I16).
3. Return 16.

lsize lanetype
1. If lanetype is numtype, then:
  a. Return $size(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $psize(lanetype).

lanetype Lnn X N
1. Return Lnn.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

zero numtype
1. If numtype is Inn, then:
  a. Return 0.
2. Assert: Due to validation, numtype is Fnn.
3. Return $fzero($size(numtype)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) * N).

concat_bytes byte*
1. If (byte* = []), then:
  a. Return [].
2. Let [b*] :: b'** be byte*.
3. Return b* :: $concat_bytes(b'**).

unpack lanetype
1. If lanetype is numtype, then:
  a. Return lanetype.
2. Assert: Due to validation, lanetype is packtype.
3. Return I32.

shunpack Lnn X N
1. Return $unpack(Lnn).

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

dataidx_instr instr
1. If instr is some MEMORY.INIT, then:
  a. Let (MEMORY.INIT x) be instr.
  b. Return [x].
2. If instr is some DATA.DROP, then:
  a. Let (DATA.DROP x) be instr.
  b. Return [x].
3. Return [].

dataidx_instrs instr''*
1. If (instr''* = []), then:
  a. Return [].
2. Let [instr] :: instr'* be instr''*.
3. Return $dataidx_instr(instr) :: $dataidx_instrs(instr'*).

dataidx_expr in*
1. Return $dataidx_instrs(in*).

dataidx_func (FUNC x loc* e)
1. Return $dataidx_expr(e).

dataidx_funcs func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Return $dataidx_func(func) :: $dataidx_funcs(func'*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

unop_ numtype unop_ iN'
1. If numtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($sizenn(numtype), iN')].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($sizenn(numtype), iN')].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(numtype), iN')].
  d. Assert: Due to validation, unop_ is some EXTEND.
  e. Let (EXTEND M) be unop_.
  f. Return [$extend__(M, $sizenn(numtype), S, $wrap__($sizenn(numtype), M, iN'))].
2. Assert: Due to validation, numtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($sizenn(numtype), iN').
4. If (unop_ = NEG), then:
  a. Return $fneg_($sizenn(numtype), iN').
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($sizenn(numtype), iN').
6. If (unop_ = CEIL), then:
  a. Return $fceil_($sizenn(numtype), iN').
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($sizenn(numtype), iN').
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($sizenn(numtype), iN').
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($sizenn(numtype), iN').

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

binop_ numtype binop_ iN_1' iN_2'
1. If numtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($sizenn(numtype), iN_1', iN_2')].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($sizenn(numtype), iN_1', iN_2')].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($sizenn(numtype), iN_1', iN_2')].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $list_(`num_((Inn : Inn <: numtype)), $idiv_($sizenn(numtype), sx, iN_1', iN_2')).
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $list_(`num_((Inn : Inn <: numtype)), $irem_($sizenn(numtype), sx, iN_1', iN_2')).
  f. If (binop_ = AND), then:
    1) Return [$iand_($sizenn(numtype), iN_1', iN_2')].
  g. If (binop_ = OR), then:
    1) Return [$ior_($sizenn(numtype), iN_1', iN_2')].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($sizenn(numtype), iN_1', iN_2')].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($sizenn(numtype), iN_1', iN_2')].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($sizenn(numtype), sx, iN_1', iN_2')].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($sizenn(numtype), iN_1', iN_2')].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($sizenn(numtype), iN_1', iN_2')].
2. Assert: Due to validation, numtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($sizenn(numtype), iN_1', iN_2').
4. If (binop_ = SUB), then:
  a. Return $fsub_($sizenn(numtype), iN_1', iN_2').
5. If (binop_ = MUL), then:
  a. Return $fmul_($sizenn(numtype), iN_1', iN_2').
6. If (binop_ = DIV), then:
  a. Return $fdiv_($sizenn(numtype), iN_1', iN_2').
7. If (binop_ = MIN), then:
  a. Return $fmin_($sizenn(numtype), iN_1', iN_2').
8. If (binop_ = MAX), then:
  a. Return $fmax_($sizenn(numtype), iN_1', iN_2').
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($sizenn(numtype), iN_1', iN_2').

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

relop_ numtype relop_ iN_1' iN_2'
1. If numtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($sizenn(numtype), iN_1', iN_2').
  b. If (relop_ = NE), then:
    1) Return $ine_($sizenn(numtype), iN_1', iN_2').
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($sizenn(numtype), sx, iN_1', iN_2').
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($sizenn(numtype), sx, iN_1', iN_2').
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($sizenn(numtype), sx, iN_1', iN_2').
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($sizenn(numtype), sx, iN_1', iN_2').
2. Assert: Due to validation, numtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($sizenn(numtype), iN_1', iN_2').
4. If (relop_ = NE), then:
  a. Return $fne_($sizenn(numtype), iN_1', iN_2').
5. If (relop_ = LT), then:
  a. Return $flt_($sizenn(numtype), iN_1', iN_2').
6. If (relop_ = GT), then:
  a. Return $fgt_($sizenn(numtype), iN_1', iN_2').
7. If (relop_ = LE), then:
  a. Return $fle_($sizenn(numtype), iN_1', iN_2').
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($sizenn(numtype), iN_1', iN_2').

cvtop__ numtype numtype'' cvtop iN_1'
1. If (numtype is Inn /\ numtype'' is Inn), then:
  a. If cvtop is some EXTEND, then:
    1) Let (EXTEND sx) be cvtop.
    2) Return [$extend__($sizenn1(numtype), $sizenn2(numtype''), sx, iN_1')].
  b. If (cvtop = WRAP), then:
    1) Return [$wrap__($sizenn1(numtype), $sizenn2(numtype''), iN_1')].
2. If (numtype is Fnn /\ numtype'' is Inn), then:
  a. If cvtop is some TRUNC, then:
    1) Let (TRUNC sx) be cvtop.
    2) Return $list_(`num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(numtype), $sizenn2(numtype''), sx, iN_1')).
  b. If cvtop is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be cvtop.
    2) Return $list_(`num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(numtype), $sizenn2(numtype''), sx, iN_1')).
3. If (numtype is Inn /\ (numtype'' is Fnn /\ cvtop is some CONVERT)), then:
  a. Let (CONVERT sx) be cvtop.
  b. Return [$convert__($sizenn1(numtype), $sizenn2(numtype''), sx, iN_1')].
4. If (numtype is Fnn /\ numtype'' is Fnn), then:
  a. If (cvtop = PROMOTE), then:
    1) Return $promote__($sizenn1(numtype), $sizenn2(numtype''), iN_1').
  b. If (cvtop = DEMOTE), then:
    1) Return $demote__($sizenn1(numtype), $sizenn2(numtype''), iN_1').
5. If (numtype is Inn /\ (numtype'' is Fnn /\ ((cvtop = REINTERPRET) /\ ($size(numtype) = $size(numtype''))))), then:
  a. Return [$reinterpret__(numtype, numtype'', iN_1')].
6. Assert: Due to validation, numtype is Fnn.
7. Assert: Due to validation, numtype'' is Inn.
8. Assert: Due to validation, (cvtop = REINTERPRET).
9. Assert: Due to validation, ($size(numtype) = $size(numtype'')).
10. Return [$reinterpret__(numtype, numtype'', iN_1')].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ineg_ N i_1
1. Return $invsigned_(N, (- $signed_(N, i_1))).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

iadd_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

packnum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $wrap__($size($unpack(lanetype)), $psize(lanetype), c).

unpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $extend__($psize(lanetype), $size($unpack(lanetype)), U, c).

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

zeroop vcvtop
1. If vcvtop is some EXTEND, then:
  a. Return ?().
2. If vcvtop is some CONVERT, then:
  a. Return ?().
3. If vcvtop is some TRUNC_SAT, then:
  a. Let (TRUNC_SAT sx zero?) be vcvtop.
  b. Return zero?.
4. If vcvtop is some DEMOTE, then:
  a. Let (DEMOTE zero) be vcvtop.
  b. Return ?(zero).
5. Assert: Due to validation, (vcvtop = PROMOTELOW).
6. Return ?().

halfop vcvtop
1. If vcvtop is some EXTEND, then:
  a. Let (EXTEND half sx) be vcvtop.
  b. Return ?(half).
2. If vcvtop is some CONVERT, then:
  a. Let (CONVERT half? sx) be vcvtop.
  b. Return half?.
3. If vcvtop is some TRUNC_SAT, then:
  a. Return ?().
4. If vcvtop is some DEMOTE, then:
  a. Return ?().
5. Assert: Due to validation, (vcvtop = PROMOTELOW).
6. Return ?(LOW).

half half i j
1. If (half = LOW), then:
  a. Return i.
2. Assert: Due to validation, (half = HIGH).
3. Return j.

vvunop_ V128 NOT v128
1. Return $inot_($size(V128), v128).

vvbinop_ V128 vvbinop v128_1 v128_2
1. If (vvbinop = AND), then:
  a. Return $iand_($size(V128), v128_1, v128_2).
2. If (vvbinop = ANDNOT), then:
  a. Return $iandnot_($size(V128), v128_1, v128_2).
3. If (vvbinop = OR), then:
  a. Return $ior_($size(V128), v128_1, v128_2).
4. Assert: Due to validation, (vvbinop = XOR).
5. Return $ixor_($size(V128), v128_1, v128_2).

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return $ibitselect_($size(V128), v128_1, v128_2, v128_3).

vunop_ lanetype X M vunop_ v128_1
1. If lanetype is Jnn, then:
  a. If (vunop_ = ABS), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $invlanes_(lanetype X M, $iabs_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
  b. If (vunop_ = NEG), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $invlanes_(lanetype X M, $ineg_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
  c. If (vunop_ = POPCNT), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $invlanes_(lanetype X M, $ipopcnt_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
2. Assert: Due to validation, lanetype is Fnn.
3. If (vunop_ = ABS), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fabs_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
4. If (vunop_ = NEG), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fneg_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
5. If (vunop_ = SQRT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fsqrt_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
6. If (vunop_ = CEIL), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fceil_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
7. If (vunop_ = FLOOR), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $ffloor_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
8. If (vunop_ = TRUNC), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $ftrunc_($sizenn(lanetype), lane_1)*).
  c. Let v128* be $invlanes_(lanetype X M, lane*)*.
  d. Return v128*.
9. Assert: Due to validation, (vunop_ = NEAREST).
10. Let lane_1* be $lanes_(lanetype X M, v128_1).
11. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fnearest_($sizenn(lanetype), lane_1)*).
12. Let v128* be $invlanes_(lanetype X M, lane*)*.
13. Return v128*.

vbinop_ lanetype X M vbinop_ v128_1 v128_2
1. If lanetype is Jnn, then:
  a. If (vbinop_ = ADD), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $invlanes_(lanetype X M, $iadd_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  b. If (vbinop_ = SUB), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $invlanes_(lanetype X M, $isub_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  c. If vbinop_ is some MIN, then:
    1) Let (MIN sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $invlanes_(lanetype X M, $imin_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  d. If vbinop_ is some MAX, then:
    1) Let (MAX sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $invlanes_(lanetype X M, $imax_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  e. If vbinop_ is some ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $invlanes_(lanetype X M, $iadd_sat_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  f. If vbinop_ is some SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $invlanes_(lanetype X M, $isub_sat_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  g. If (vbinop_ = MUL), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $invlanes_(lanetype X M, $imul_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  h. If (vbinop_ = AVGRU), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $invlanes_(lanetype X M, $iavgr_($lsizenn(lanetype), U, lane_1, lane_2)*).
    4) Return [v128].
  i. If (vbinop_ = Q15MULR_SATS), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $invlanes_(lanetype X M, $iq15mulr_sat_($lsizenn(lanetype), S, lane_1, lane_2)*).
    4) Return [v128].
2. Assert: Due to validation, lanetype is Fnn.
3. If (vbinop_ = ADD), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fadd_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
4. If (vbinop_ = SUB), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fsub_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
5. If (vbinop_ = MUL), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmul_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
6. If (vbinop_ = DIV), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fdiv_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
7. If (vbinop_ = MIN), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmin_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
8. If (vbinop_ = MAX), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmax_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
9. If (vbinop_ = PMIN), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fpmin_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(lanetype X M, lane*)*.
  e. Return v128*.
10. Assert: Due to validation, (vbinop_ = PMAX).
11. Let lane_1* be $lanes_(lanetype X M, v128_1).
12. Let lane_2* be $lanes_(lanetype X M, v128_2).
13. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fpmax_($sizenn(lanetype), lane_1, lane_2)*).
14. Let v128* be $invlanes_(lanetype X M, lane*)*.
15. Return v128*.

vrelop_ lanetype X M vrelop_ v128_1 v128_2
1. If lanetype is Jnn, then:
  a. If (vrelop_ = EQ), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $ieq_($lsizenn(lanetype), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(lanetype X M, lane_3*).
    5) Return v128.
  b. If (vrelop_ = NE), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $ine_($lsizenn(lanetype), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(lanetype X M, lane_3*).
    5) Return v128.
  c. If vrelop_ is some LT, then:
    1) Let (LT sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $ilt_($lsizenn(lanetype), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(lanetype X M, lane_3*).
    6) Return v128.
  d. If vrelop_ is some GT, then:
    1) Let (GT sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $igt_($lsizenn(lanetype), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(lanetype X M, lane_3*).
    6) Return v128.
  e. If vrelop_ is some LE, then:
    1) Let (LE sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $ile_($lsizenn(lanetype), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(lanetype X M, lane_3*).
    6) Return v128.
  f. If vrelop_ is some GE, then:
    1) Let (GE sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(lanetype), S, $ige_($lsizenn(lanetype), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(lanetype X M, lane_3*).
    6) Return v128.
2. Assert: Due to validation, lanetype is Fnn.
3. If (vrelop_ = EQ), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $feq_($sizenn(lanetype), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
4. If (vrelop_ = NE), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $fne_($sizenn(lanetype), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
5. If (vrelop_ = LT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $flt_($sizenn(lanetype), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
6. If (vrelop_ = GT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $fgt_($sizenn(lanetype), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
7. If (vrelop_ = LE), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $fle_($sizenn(lanetype), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
8. Assert: Due to validation, (vrelop_ = GE).
9. Let lane_1* be $lanes_(lanetype X M, v128_1).
10. Let lane_2* be $lanes_(lanetype X M, v128_2).
11. Let Inn be $isize^-1($size(lanetype)).
12. Let lane_3* be $extend__(1, $sizenn(lanetype), S, $fge_($sizenn(lanetype), lane_1, lane_2))*.
13. Let v128 be $invlanes_(Inn X M, lane_3*).
14. Return v128.

vcvtop__ lanetype' X M_1 lanetype X M_2 vcvtop iN_1'
1. If lanetype' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop.
    2) Let iN_2 be $extend__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1').
    3) Return [iN_2].
  b. If (lanetype is Fnn /\ vcvtop is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop.
    2) Let fN_2 be $convert__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1').
    3) Return [fN_2].
2. Assert: Due to validation, lanetype' is Fnn.
3. If (lanetype is Inn /\ vcvtop is some TRUNC_SAT), then:
  a. Let (TRUNC_SAT sx zero?) be vcvtop.
  b. Let iN_2? be $trunc_sat__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1').
  c. Return $list_(`lane_((Inn_2 : Inn <: lanetype)), iN_2?).
4. Assert: Due to validation, lanetype is Fnn.
5. If (vcvtop = (DEMOTE ZERO)), then:
  a. Let fN_2* be $demote__($lsizenn1(lanetype'), $lsizenn2(lanetype), iN_1').
  b. Return fN_2*.
6. Assert: Due to validation, (vcvtop = PROMOTELOW).
7. Let fN_2* be $promote__($lsizenn1(lanetype'), $lsizenn2(lanetype), iN_1').
8. Return fN_2*.

vextunop__ Inn_1 X M_1 Inn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Inn_2 X M_2, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(`iN($lsizenn1((Inn_1 : Inn <: lanetype))), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci)*).
3. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
4. Return c.

vextbinop__ Inn_1 X M_1 Inn_2 X M_2 vextbinop_ c_1 c_2
1. If vextbinop_ is some EXTMUL, then:
  a. Let (EXTMUL half sx) be vextbinop_.
  b. Let ci_1* be $lanes_(Inn_2 X M_2, c_1)[$half(half, 0, M_1) : M_1].
  c. Let ci_2* be $lanes_(Inn_2 X M_2, c_2)[$half(half, 0, M_1) : M_1].
  d. Let c be $invlanes_(Inn_1 X M_1, $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop_ = DOTS).
3. Let ci_1* be $lanes_(Inn_2 X M_2, c_1).
4. Let ci_2* be $lanes_(Inn_2 X M_2, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(`iN($lsizenn1((Inn_1 : Inn <: lanetype))), $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_2))*).
6. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop_ lane n
1. If (vshiftop_ = SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop_ is some SHR.
3. Let (SHR sx) be vshiftop_.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

default_ valtype
1. If (valtype = I32), then:
  a. Return (I32.CONST 0).
2. If (valtype = I64), then:
  a. Return (I64.CONST 0).
3. If (valtype = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. If (valtype = F64), then:
  a. Return (F64.CONST $fzero(64)).
5. If (valtype = V128), then:
  a. Return (V128.CONST 0).
6. If (valtype = FUNCREF), then:
  a. Return (REF.NULL FUNCREF).
7. Assert: Due to validation, (valtype = EXTERNREF).
8. Return (REF.NULL EXTERNREF).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $funcsxa(xv*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $globalsxa(xv*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $tablesxa(xv*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

eleminst (s, f)
1. Return s.ELEMS.

datainst (s, f)
1. Return s.DATAS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

growtable ti n r
1. Let { TYPE: (([ i .. j ]) rt); REFS: r'* } be ti.
2. Let i' be (|r'*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: (([ i' .. j ]) rt); REFS: r'* :: r^n }.
  b. Return ti'.
4. Fail.

growmemory mi n
1. Let { TYPE: ([ i .. j ]) PAGE; BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.
4. Fail.

blocktype z blocktype
1. If (blocktype = (_RESULT ?())), then:
  a. Return [] -> [].
2. If blocktype is some _RESULT, then:
  a. Let (_RESULT valtype_0?) be blocktype.
  b. If valtype_0? is defined, then:
    1) Let ?(t) be valtype_0?.
    2) Return [] -> [t].
3. Assert: Due to validation, blocktype is some _IDX.
4. Let (_IDX x) be blocktype.
5. Return $type(z, x).

funcs externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $funcs(externaddr'*).

globals externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $globals(externaddr'*).

tables externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $tables(externaddr'*).

mems externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (([ i .. j ]) rt)
1. Let ti be { TYPE: (([ i .. j ]) rt); REFS: (REF.NULL rt)^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tabletype''*
1. If (tabletype''* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype''*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ]) PAGE
1. Let mi be { TYPE: ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

allocelem s rt ref*
1. Let ei be { TYPE: rt; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append ei to the s.ELEMS.
4. Return a.

allocelems s reftype* ref''*
1. If ((reftype* = []) /\ (ref''* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref''*| >= 1).
3. Let [ref*] :: ref'** be ref''*.
4. Assert: Due to validation, (|reftype*| >= 1).
5. Let [rt] :: rt'* be reftype*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s byte*
1. Let di be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append di to the s.DATAS.
4. Return a.

allocdatas s byte''*
1. If (byte''* = []), then:
  a. Return [].
2. Let [byte*] :: byte'** be byte''*.
3. Let da be $allocdata(s, byte*).
4. Let da'* be $allocdatas(s, byte'**).
5. Return [da] :: da'*.

instexport fa* ga* ta* ma* (EXPORT name externidx)
1. If externidx is some FUNC, then:
  a. Let (FUNC x) be externidx.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM x) be externidx.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val* ref**
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem_4* data_5* start? export*) be module.
2. Let (DATA byte* datamode)^n_data be data_5*.
3. Let (ELEM rt expr_2* elemmode)^n_elem be elem_4*.
4. Let (MEMORY memtype)^n_mem be mem_3*.
5. Let (TABLE tabletype)^n_table be table_2*.
6. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
7. Let (TYPE ft)* be type_0*.
8. Let fa_ex* be $funcs(externaddr*).
9. Let ga_ex* be $globals(externaddr*).
10. Let ma_ex* be $mems(externaddr*).
11. Let ta_ex* be $tables(externaddr*).
12. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
13. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
14. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
15. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
16. Let ea* be (|s.ELEMS| + i_elem)^(i_elem<n_elem).
17. Let da* be (|s.DATAS| + i_data)^(i_data<n_data).
18. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
19. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; ELEMS: ea*; DATAS: da*; EXPORTS: xi* }.
20. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
21. Assert: Due to validation, (funcaddr_0* = fa*).
22. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
23. Assert: Due to validation, (globaladdr_0* = ga*).
24. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
25. Assert: Due to validation, (tableaddr_0* = ta*).
26. Let memaddr_0* be $allocmems(s, memtype^n_mem).
27. Assert: Due to validation, (memaddr_0* = ma*).
28. Let elemaddr_0* be $allocelems(s, rt^n_elem, ref**).
29. Assert: Due to validation, (elemaddr_0* = ea*).
30. Let dataaddr_0* be $allocdatas(s, byte*^n_data).
31. Assert: Due to validation, (dataaddr_0* = da*).
32. Return moduleinst.

runelem (ELEM reftype expr* elemmode) i
1. If (elemmode = PASSIVE), then:
  a. Return [].
2. If (elemmode = DECLARE), then:
  a. Return [(ELEM.DROP i)].
3. Assert: Due to validation, elemmode is some ACTIVE.
4. Let (ACTIVE x instr*) be elemmode.
5. Let n be |expr*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT x i), (ELEM.DROP i)].

rundata (DATA byte* datamode) i
1. If (datamode = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode is some ACTIVE.
3. Let (ACTIVE memidx_0 instr*) be datamode.
4. Assert: Due to validation, (memidx_0 = 0).
5. Let n be |byte*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT i), (DATA.DROP i)].

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let (TYPE functype)* be type*.
3. Let n_D be |data*|.
4. Let n_E be |elem*|.
5. Let n_F be |func*|.
6. Let (START x)? be start?.
7. Let (GLOBAL globaltype expr_G)* be global*.
8. Let (ELEM reftype expr_E* elemmode)* be elem*.
9. Let instr_D* be $concat_(`instr, $rundata(data*[j], j)^(j<n_D)).
10. Let instr_E* be $concat_(`instr, $runelem(elem*[i], i)^(i<n_E)).
11. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
12. Let f_init be { MODULE: moduleinst_init }.
13. Let z be (s, f_init).
14. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
15. Let [val]* be $Eval_expr(z, expr_G)*.
16. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
17. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
18. Let [ref]** be $Eval_expr(z, expr_E)**.
19. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
20. Let moduleinst be $allocmodule(s, module, externaddr*, val*, ref**).
21. Let f be { MODULE: moduleinst }.
22. Push the frame (FRAME_ 0 { f }) to the stack.
23. Execute the sequence instr_E*.
24. Execute the sequence instr_D*.
25. If (CALL x)? is defined, then:
  a. Let ?(instr_0) be (CALL x)?.
  b. Execute the instruction instr_0.
26. Pop the frame (FRAME_ 0 { f }) from the stack.
27. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the frame (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the frame (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the frame (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop the values val'^k from the stack.
10. Pop the frame (FRAME_ k { f }) from the stack.
11. Return val'^k.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 3.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Expand_use: `%~~_%%`(typeuse, context, comptype)



The number type :math:`{\mathit{numtype}}` is always :ref:`valid <valid-val>`.




The vector type :math:`{\mathit{vectype}}` is always :ref:`valid <valid-val>`.




The packed type :math:`{\mathit{packtype}}` is always :ref:`valid <valid-val>`.




The packed type :math:`{\mathit{packtype}}` :ref:`matches <match>` only itself.




The number type :math:`{\mathit{numtype}}` :ref:`matches <match>` only itself.




The vector type :math:`{\mathit{vectype}}` :ref:`matches <match>` only itself.




The heap type :math:`{\mathit{heaptype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The heap type :math:`{\mathit{heaptype}}` is of the form :math:`{\mathit{absheaptype}}`.

   * Or:

      * The heap type :math:`{\mathit{heaptype}}` is of the form :math:`{\mathit{typeuse}}`.

      * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.




The heap type :math:`{\mathit{absheaptype}}` is always :ref:`valid <valid-val>`.




The heap type :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})` is :ref:`valid <valid-val>` if:


   * The heap type :math:`{\mathit{heaptype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{numtype}}`.

      * The number type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{vectype}}`.

      * The vector type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{reftype}}`.

      * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`\mathsf{bot}`.




The value type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>` if:


   * The number type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>` if:


   * The vector type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>` if:


   * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.




The value type :math:`\mathsf{bot}` is always :ref:`valid <valid-val>`.




The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{\mathit{dt}}`.

   * Or:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`{\mathit{deftype}}`.

      * The defined type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`(\mathsf{rec}~i)`.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`{\mathit{st}}`.




The type use :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{\mathit{dt}}`.




The type use :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>` if:


   * The defined type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>`.




The type use :math:`(\mathsf{rec}~i)` is :ref:`valid <valid-val>` if:


   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`{\mathit{st}}`.




The result type :math:`{t^\ast}` is :ref:`valid <valid-val>` if:


   * For all :math:`t` in :math:`{t^\ast}`:

      * The value type :math:`t` is :ref:`valid <valid-val>`.




The field type :math:`({\mathsf{mut}^?}~{\mathit{storagetype}})` is :ref:`valid <valid-val>` if:


   * The storage type :math:`{\mathit{storagetype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{storagetype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{valtype}}`.

      * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{packtype}}`.

      * The packed type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>` if:


   * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>` if:


   * The packed type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.

      * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

         * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{array}~{\mathit{fieldtype}})`.

      * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})` is :ref:`valid <valid-val>` if:


   * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

      * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})` is :ref:`valid <valid-val>` if:


   * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{func}~{\mathit{functype}})` is :ref:`valid <valid-val>` if:


   * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>` if:


   * The result type :math:`{t_1^\ast}` is :ref:`valid <valid-val>`.

   * The result type :math:`{t_2^\ast}` is :ref:`valid <valid-val>`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{x^\ast}~{\mathit{comptype}})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x_0)})` if:


   * The length of :math:`{x^\ast}` is less than or equal to :math:`1`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The index :math:`x` is less than :math:`x_0`.

   * The length of :math:`{{\mathit{comptype}'}^\ast}` is equal to the length of :math:`{x^\ast}`.

   * The length of :math:`{{\mathit{comptype}'}^\ast}` is equal to the length of :math:`{{{x'}^\ast}^\ast}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`, and corresponding :math:`x` in :math:`{x^\ast}`, and corresponding :math:`{{x'}^\ast}` in :math:`{{{x'}^\ast}^\ast}`:

      * The sub type :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[x])` is of the form :math:`(\mathsf{sub}~{{x'}^\ast}~{\mathit{comptype}'})`.

   * The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}'}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{subtype}'}^\ast}` is empty.

   * Or:

      * The sub type sequence :math:`{{\mathit{subtype}'}^\ast}` is of the form :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1)})`.




The recursive type :math:`(\mathsf{rec})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})` if:


   * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1)})`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{compttype}})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * The length of :math:`{{\mathit{typeuse}}^\ast}` is less than or equal to :math:`1`.

   * For all :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`:

      * :math:`{\mathit{typeuse}} \prec x, i` is of the form true.

   * The length of :math:`{{\mathit{comptype}'}^\ast}` is equal to the length of :math:`{{\mathit{typeuse}}^\ast}`.

   * The length of :math:`{{\mathit{comptype}'}^\ast}` is equal to the length of :math:`{{{\mathit{typeuse}'}^\ast}^\ast}`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`, and corresponding :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`, and corresponding :math:`{{\mathit{typeuse}'}^\ast}` in :math:`{{{\mathit{typeuse}'}^\ast}^\ast}`:

      * The sub type :math:`{{\mathrm{unroll}}}_{C}({\mathit{typeuse}})` is of the form :math:`(\mathsf{sub}~{{\mathit{typeuse}'}^\ast}~{\mathit{comptype}'})`.

   * The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}'}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{subtype}'}^\ast}` is empty.

   * Or:

      * The sub type sequence :math:`{{\mathit{subtype}'}^\ast}` is of the form :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The defined type :math:`({\mathit{rectype}} {.} i)` is :ref:`valid <valid-val>` if:


   * The recursive type :math:`{\mathit{rectype}}` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})`.

   * The recursive type :math:`{\mathit{rectype}}` is of the form :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})`.

   * :math:`i` is less than :math:`n`.




The composite type :math:`{\mathit{comptype}}` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}'}` if:


   * Either:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{{\mathit{yt}'}_1^\ast})`.

      * The composite type :math:`{\mathit{comptype}'}` is of the form :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})`.

      * The length of :math:`{{\mathit{yt}}_1^\ast}` is equal to the length of :math:`{{\mathit{yt}}_2^\ast}`.

      * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}`, and corresponding :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

         * The field type :math:`{\mathit{yt}}_1` :ref:`matches <match>` the field type :math:`{\mathit{yt}}_2`.

   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{array}~{\mathit{yt}}_1)`.

      * The composite type :math:`{\mathit{comptype}'}` is of the form :math:`(\mathsf{array}~{\mathit{yt}}_2)`.

      * The field type :math:`{\mathit{yt}}_1` :ref:`matches <match>` the field type :math:`{\mathit{yt}}_2`.
   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The composite type :math:`{\mathit{comptype}'}` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{{\mathit{yt}'}_1^\ast})` :ref:`matches <match>` the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})` if:


   * The length of :math:`{{\mathit{yt}}_1^\ast}` is equal to the length of :math:`{{\mathit{yt}}_2^\ast}`.

   * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}`, and corresponding :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

      * The field type :math:`{\mathit{yt}}_1` :ref:`matches <match>` the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{array}~{\mathit{yt}}_1)` :ref:`matches <match>` the composite type :math:`(\mathsf{array}~{\mathit{yt}}_2)` if:


   * The field type :math:`{\mathit{yt}}_1` :ref:`matches <match>` the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{func}~{\mathit{ft}}_1)` :ref:`matches <match>` the composite type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * Either:

      * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is of the form :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.

   * Or:

      * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

      * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`i`.

      * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is of the form :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

   * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`i`.

   * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{heaptype}''}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}'''}` if:


   * Either:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{heaptype}}_1`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}_2`.

      * The heap type :math:`{\mathit{heaptype}'}` is :ref:`valid <valid-val>`.

      * The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}'}`.

      * The heap type :math:`{\mathit{heaptype}'}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{eq}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{i{\scriptstyle 31}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{struct}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{array}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{struct}`.

      * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{array}`.

      * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`\mathsf{func}`.

      * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{deftype}}_1`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{deftype}}_2`.

      * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{typeidx}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`(\mathsf{rec}~i)`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{{\mathit{typeuse}}^\ast}{}[j]`.

      * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`j`.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{none}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{nofunc}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{func}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{noexn}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{exn}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{noextern}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{extern}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}''}` is of the form :math:`\mathsf{bot}`.

      * The heap type :math:`{\mathit{heaptype}'''}` is of the form :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` only itself.




The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2` if:


   * The heap type :math:`{\mathit{heaptype}'}` is :ref:`valid <valid-val>`.

   * The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}'}`.

   * The heap type :math:`{\mathit{heaptype}'}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2`.




The heap type :math:`\mathsf{eq}` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{i{\scriptstyle 31}}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{struct}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{array}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{struct}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{array}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{func}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The heap type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{typeidx}}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`{\mathit{typeidx}}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.




The heap type :math:`(\mathsf{rec}~i)` :ref:`matches <match>` the type use :math:`{{\mathit{typeuse}}^\ast}{}[j]` if:


   * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`j`.

   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.




The heap type :math:`\mathsf{none}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{nofunc}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{func}`.




The heap type :math:`\mathsf{noexn}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{exn}`.




The heap type :math:`\mathsf{noextern}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{extern}`.




The heap type :math:`\mathsf{bot}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~{{\mathsf{null}^?}'}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.

   * Either:

      * :math:`{\mathsf{null}^?}` is absent.

      * :math:`{{\mathsf{null}^?}'}` is absent.

   * Or:

      * :math:`{\mathsf{null}^?}` is of the form :math:`{\mathsf{null}^?}`.

      * :math:`{{\mathsf{null}^?}'}` is of the form :math:`\mathsf{null}`.




The reference type :math:`(\mathsf{ref}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.




The value type :math:`{\mathit{valtype}'}` :ref:`matches <match>` the value type :math:`{\mathit{valtype}''}` if:


   * Either:

      * The value type :math:`{\mathit{valtype}'}` is of the form :math:`{\mathit{numtype}}_1`.

      * The value type :math:`{\mathit{valtype}''}` is of the form :math:`{\mathit{numtype}}_2`.

      * The number type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the number type :math:`{\mathit{numtype}}_2`.

   * Or:

      * The value type :math:`{\mathit{valtype}'}` is of the form :math:`{\mathit{vectype}}_1`.

      * The value type :math:`{\mathit{valtype}''}` is of the form :math:`{\mathit{vectype}}_2`.

      * The vector type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the vector type :math:`{\mathit{vectype}}_2`.
   * Or:

      * The value type :math:`{\mathit{valtype}'}` is of the form :math:`{\mathit{reftype}}_1`.

      * The value type :math:`{\mathit{valtype}''}` is of the form :math:`{\mathit{reftype}}_2`.

      * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.
   * Or:

      * The value type :math:`{\mathit{valtype}'}` is of the form :math:`\mathsf{bot}`.

      * The value type :math:`{\mathit{valtype}''}` is of the form :math:`{\mathit{valtype}}`.




The value type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{numtype}}_2` if:


   * The number type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the number type :math:`{\mathit{numtype}}_2`.




The value type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{vectype}}_2` if:


   * The vector type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the vector type :math:`{\mathit{vectype}}_2`.




The value type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{reftype}}_2` if:


   * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.




The value type :math:`\mathsf{bot}` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}`.




The result type :math:`{t_1^\ast}` :ref:`matches <match>` the result type :math:`{t_2^\ast}` if:


   * The length of :math:`{t_1^\ast}` is equal to the length of :math:`{t_2^\ast}`.

   * For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`t_2` in :math:`{t_2^\ast}`:

      * The value type :math:`t_1` :ref:`matches <match>` the value type :math:`t_2`.




The storage type :math:`{\mathit{storagetype}}` :ref:`matches <match>` the storage type :math:`{\mathit{storagetype}'}` if:


   * Either:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{valtype}}_1`.

      * The storage type :math:`{\mathit{storagetype}'}` is of the form :math:`{\mathit{valtype}}_2`.

      * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * Or:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{packtype}}_1`.

      * The storage type :math:`{\mathit{storagetype}'}` is of the form :math:`{\mathit{packtype}}_2`.

      * The packed type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the packed type :math:`{\mathit{packtype}}_2`.




The storage type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{valtype}}_2` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.




The storage type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{packtype}}_2` if:


   * The packed type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the packed type :math:`{\mathit{packtype}}_2`.




The field type :math:`({\mathsf{mut}^?}~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`({{\mathsf{mut}^?}'}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.

   * Either:

      * :math:`{\mathsf{mut}^?}` is absent.

      * :math:`{{\mathsf{mut}^?}'}` is absent.

   * Or:

      * :math:`{\mathsf{mut}^?}` is of the form :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}^?}'}` is of the form :math:`\mathsf{mut}`.

      * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The field type :math:`(\epsilon~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`(\epsilon~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.




The field type :math:`(\mathsf{mut}~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`(\mathsf{mut}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.

   * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The function type :math:`{t_{11}^\ast}~\rightarrow~{t_{12}^\ast}` :ref:`matches <match>` the function type :math:`{t_{21}^\ast}~\rightarrow~{t_{22}^\ast}` if:


   * The result type :math:`{t_{21}^\ast}` :ref:`matches <match>` the result type :math:`{t_{11}^\ast}`.

   * The result type :math:`{t_{12}^\ast}` :ref:`matches <match>` the result type :math:`{t_{22}^\ast}`.




The instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}` is :ref:`valid <valid-val>` if:


   * The result type :math:`{t_1^\ast}` is :ref:`valid <valid-val>`.

   * The result type :math:`{t_2^\ast}` is :ref:`valid <valid-val>`.

   * The length of :math:`{{{\mathit{lt}}}^\ast}` is equal to the length of :math:`{x^\ast}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}`, and corresponding :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`{{\mathit{lt}}}`.




The limits range :math:`{}[ n .. m ]` is :ref:`valid <valid-val>` within :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The global type :math:`({\mathsf{mut}^?}~t)` is :ref:`valid <valid-val>` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})` is :ref:`valid <valid-val>` if:


   * The limits range :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` within :math:`{2^{32}} - 1`.

   * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})` is :ref:`valid <valid-val>` if:


   * The limits range :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` within :math:`{2^{16}}`.




The tag type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>` if:


   * The defined type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>`.

   * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{typeuse}})`.

      * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

      * The :ref:`expansion <aux-expand-typeuse>` of the context :math:`C` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{typeuse}})`.

      * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

      * The :ref:`expansion <aux-expand-typeuse>` of the context :math:`C` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`(\mathsf{func}~{\mathit{typeuse}})` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

   * The :ref:`expansion <aux-expand-typeuse>` of the context :math:`C` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{tag}~{\mathit{typeuse}})` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

   * The :ref:`expansion <aux-expand-typeuse>` of the context :math:`C` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The instruction type :math:`{t_{11}^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_{12}^\ast}` :ref:`matches <match>` the instruction type :math:`{t_{21}^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_{22}^\ast}` if:


   * The result type :math:`{t_{21}^\ast}` :ref:`matches <match>` the result type :math:`{t_{11}^\ast}`.

   * The result type :math:`{t_{12}^\ast}` :ref:`matches <match>` the result type :math:`{t_{22}^\ast}`.

   * The local index sequence :math:`{x^\ast}` is of the form :math:`{x_2^\ast} \setminus {x_1^\ast}`.

   * The length of :math:`{t^\ast}` is equal to the length of :math:`{x^\ast}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * For all :math:`t` in :math:`{t^\ast}`, and corresponding :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`(\mathsf{set}~t)`.




The limits range :math:`{}[ n_1 .. m_1 ]` :ref:`matches <match>` the limits range :math:`{}[ n_2 .. m_2 ]` if:


   * :math:`n_1` is greater than or equal to :math:`n_2`.

   * :math:`m_1` is less than or equal to :math:`m_2`.




The global type :math:`({\mathsf{mut}^?}~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`({{\mathsf{mut}^?}'}~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * Either:

      * :math:`{\mathsf{mut}^?}` is absent.

      * :math:`{{\mathsf{mut}^?}'}` is absent.

   * Or:

      * :math:`{\mathsf{mut}^?}` is of the form :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}^?}'}` is of the form :math:`\mathsf{mut}`.

      * The value type :math:`{\mathit{valtype}}_2` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_1`.




The global type :math:`(\epsilon~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`(\epsilon~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.




The global type :math:`(\mathsf{mut}~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`(\mathsf{mut}~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * The value type :math:`{\mathit{valtype}}_2` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_1`.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~{\mathit{reftype}}_1)` :ref:`matches <match>` the table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~{\mathit{reftype}}_2)` if:


   * The limits range :math:`{\mathit{limits}}_1` :ref:`matches <match>` the limits range :math:`{\mathit{limits}}_2`.

   * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.

   * The reference type :math:`{\mathit{reftype}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_1`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~\mathsf{page})` :ref:`matches <match>` the memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~\mathsf{page})` if:


   * The limits range :math:`{\mathit{limits}}_1` :ref:`matches <match>` the limits range :math:`{\mathit{limits}}_2`.




The tag type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.

   * The defined type :math:`{\mathit{deftype}}_2` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_1`.




The external type :math:`{\mathit{externtype}}` :ref:`matches <match>` the external type :math:`{\mathit{externtype}'}` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{deftype}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{func}~{\mathit{deftype}}_2)`.

      * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}}_2)`.

      * The global type :math:`{\mathit{globaltype}}_1` :ref:`matches <match>` the global type :math:`{\mathit{globaltype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}}_2)`.

      * The table type :math:`{\mathit{tabletype}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tabletype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}}_2)`.

      * The memory type :math:`{\mathit{memtype}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{memtype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)`.

      * The external type :math:`{\mathit{externtype}'}` is of the form :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)`.

      * The tag type :math:`{\mathit{tagtype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{tagtype}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{deftype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{deftype}}_2)` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{globaltype}}_2)` if:


   * The global type :math:`{\mathit{globaltype}}_1` :ref:`matches <match>` the global type :math:`{\mathit{globaltype}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tabletype}}_2)` if:


   * The table type :math:`{\mathit{tabletype}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tabletype}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{memtype}}_2)` if:


   * The memory type :math:`{\mathit{memtype}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{memtype}}_2`.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)` if:


   * The tag type :math:`{\mathit{tagtype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{tagtype}}_2`.




The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{{\mathit{valtype}'}^\ast}~\rightarrow~{{\mathit{valtype}''}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{{\mathit{valtype}}^?}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}''}^\ast}` is of the form :math:`{{\mathit{valtype}}^?}`.

      * If :math:`{\mathit{valtype}}` is defined, then:

         * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{\mathit{typeidx}}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}''}^\ast}` is of the form :math:`{t_2^\ast}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The block type :math:`{{\mathit{valtype}}^?}` is :ref:`valid <valid-val>` as the instruction type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}` if:


   * If :math:`{\mathit{valtype}}` is defined, then:

      * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.




The block type :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The catch clause :math:`{\mathit{catch}}` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * Either:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch}~x~l)`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the tag :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.

   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_ref}~x~l)`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the tag :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

      * The result type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_all}~l)`.

      * The result type :math:`\epsilon` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_all\_ref}~l)`.

      * The result type :math:`(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch}~x~l)` is :ref:`valid <valid-val>` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the tag :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_ref}~x~l)` is :ref:`valid <valid-val>` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the tag :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all}~l)` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`\epsilon` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all\_ref}~l)` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The value type :math:`t` is defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is not absent.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{select}~{{\mathit{valtype}}^?})` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.

   * Either:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is of the form :math:`t`.

   * Or:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is absent.

      * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

      * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.

   * The label :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * The instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_on\_null}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}~(\mathsf{ref}~{\mathit{ht}})` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.

   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_on\_non\_null}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~(\mathsf{ref}~{\mathit{ht}})`.




The instruction :math:`(\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{t'}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.

   * Let :math:`{t'}` be the reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2`.




The instruction :math:`(\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_2` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the function :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_ref}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_2^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_2^\ast}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\rightarrow~{t_4^\ast}` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the function :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call\_ref}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_4^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_4^\ast}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{throw}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the tag :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{throw\_ref}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~\mathsf{exn})~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * For all :math:`{\mathit{catch}}` in :math:`{{\mathit{catch}}^\ast}`:

      * The catch clause :math:`{\mathit{catch}}` is :ref:`valid <valid-val>`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~{\mathit{dt}})` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.

   * :math:`x` is contained in :math:`C{.}\mathsf{refs}`.




The instruction :math:`\mathsf{ref{.}i{\scriptstyle 31}}` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.




The instruction :math:`\mathsf{ref{.}is\_null}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{ref{.}as\_non\_null}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~(\mathsf{ref}~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{ref{.}eq}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{ref{.}test}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}'}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The reference type :math:`{\mathit{rt}}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}'}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`(\mathsf{ref{.}cast}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}'}~\rightarrow~{\mathit{rt}}` if:


   * The reference type :math:`{\mathit{rt}}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}'}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`({\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{struct{.}new}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * Let :math:`{t^\ast}` be the value type sequence :math:`{{\mathrm{unpack}}({\mathit{zt}})^\ast}`.




The instruction :math:`(\mathsf{struct{.}new\_default}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * For all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`:

      * A :ref:`default value <aux-default>` for the value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~t` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

   * The length of :math:`{{\mathit{yt}}^\ast}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is of the form :math:`({\mathsf{mut}^?}~{\mathit{zt}})`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is of the form :math:`{\mathrm{unpack}}({\mathit{zt}})`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{struct{.}set}~x~i)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~t~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

   * The length of :math:`{{\mathit{yt}}^\ast}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is of the form :math:`(\mathsf{mut}~{\mathit{zt}})`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_default}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * A :ref:`default value <aux-default>` for the value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^{n}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_elem}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{rt}}))`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{array{.}new\_data}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{vectype}}`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is of the form :math:`{\mathrm{unpack}}({\mathit{zt}})`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`\mathsf{array{.}len}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{array{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x_1)~\mathsf{i{\scriptstyle 32}}~(\mathsf{ref}~\mathsf{null}~x_2)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x_1]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x_1]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}_1))`.

   * The type :math:`C{.}\mathsf{types}{}[x_2]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x_2]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}_2))`.

   * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The instruction :math:`(\mathsf{array{.}init\_elem}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}`.




The instruction :math:`(\mathsf{array{.}init\_data}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{vectype}}`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`\mathsf{extern{.}convert\_any}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{any})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{extern})` if:


   * :math:`{\mathsf{null}}{{{}_{1}^?}}` is of the form :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`\mathsf{any{.}convert\_extern}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{extern})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{any})` if:


   * :math:`{\mathsf{null}}{{{}_{1}^?}}` is of the form :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vternop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vswizzlop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is :ref:`valid <valid-val>` with the instruction type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`(\mathsf{set}~t)`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~{\rightarrow}_{x}\,\epsilon` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~{\rightarrow}_{x}\,t` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathsf{mut}^?}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{rt}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}}~{\mathit{at}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{at}}_1~{\mathit{lim}}_1~{\mathit{rt}}_1)`.

   * The table :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x_2]` is of the form :math:`({\mathit{at}}_2~{\mathit{lim}}_2~{\mathit{rt}}_2)`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{table{.}init}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}_1)`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` is of the form :math:`{\mathit{rt}}_2`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element segment :math:`C{.}\mathsf{elems}{}[x]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[x]` is of the form :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{memory{.}size}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}grow}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x_1]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x_1]` is of the form :math:`({\mathit{at}}_1~{\mathit{lim}}_1~\mathsf{page})`.

   * The memory :math:`C{.}\mathsf{mems}{}[x_2]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x_2]` is of the form :math:`({\mathit{at}}_2~{\mathit{lim}}_2~\mathsf{page})`.

   * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{memory{.}init}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data segment :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{valtype}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}'}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{valtype}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{storeop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}'}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{storeop}}^?}` is of the form :math:`M`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * :math:`{{\mathit{vloadop}}^?}` is absent.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.

   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.
   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({N}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.
   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({N}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{select}~t)` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{select})` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.

   * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

   * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{load}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{nt}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathsf{i}}{N}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{store}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{store}}{M}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathsf{i}}{N}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{splat}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{zero}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}''}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is empty.

      * The instruction type :math:`{\mathit{it}''}` is of the form :math:`\epsilon~\rightarrow~\epsilon`.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The instruction type :math:`{\mathit{it}''}` is of the form :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

      * The length of :math:`{{\mathit{init}}^\ast}` is equal to the length of :math:`{t^\ast}`.

      * The length of :math:`{{\mathit{init}}^\ast}` is equal to the length of :math:`{x_1^\ast}`.

      * For all :math:`x_1` in :math:`{x_1^\ast}`:

         * The local :math:`C{.}\mathsf{locals}{}[x_1]` exists.

      * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}`, and corresponding :math:`t` in :math:`{t^\ast}`, and corresponding :math:`x_1` in :math:`{x_1^\ast}`:

         * The local :math:`C{.}\mathsf{locals}{}[x_1]` is of the form :math:`({\mathit{init}}~t)`.

      * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}~t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{{\mathit{instr}}^\ast}`.

      * The instruction type :math:`{\mathit{it}''}` is of the form :math:`{\mathit{it}'}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}}`.

      * The instruction type :math:`{\mathit{it}}` :ref:`matches <match>` the instruction type :math:`{\mathit{it}'}`.

      * The instruction type :math:`{\mathit{it}'}` is :ref:`valid <valid-val>`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}'}^\ast}` is of the form :math:`{{\mathit{instr}}^\ast}`.

      * The instruction type :math:`{\mathit{it}''}` is of the form :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

      * The result type :math:`{t^\ast}` is :ref:`valid <valid-val>`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * The length of :math:`{{\mathit{init}}^\ast}` is equal to the length of :math:`{t^\ast}`.

   * The length of :math:`{{\mathit{init}}^\ast}` is equal to the length of :math:`{x_1^\ast}`.

   * For all :math:`x_1` in :math:`{x_1^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x_1]` exists.

   * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}`, and corresponding :math:`t` in :math:`{t^\ast}`, and corresponding :math:`x_1` in :math:`{x_1^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x_1]` is of the form :math:`({\mathit{init}}~t)`.

   * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}~t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}'}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}}`.

   * The instruction type :math:`{\mathit{it}}` :ref:`matches <match>` the instruction type :math:`{\mathit{it}'}`.

   * The instruction type :math:`{\mathit{it}'}` is :ref:`valid <valid-val>`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * The result type :math:`{t^\ast}` is :ref:`valid <valid-val>`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{t^\ast}`.




The value type :math:`t` is not defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is absent.




:math:`{\mathit{val}}` is constant if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{ref{.}i{\scriptstyle 31}}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{struct{.}new}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{struct{.}new\_default}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new\_default}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new\_fixed}~x~n)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{any{.}convert\_extern}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{extern{.}convert\_any}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathsf{i}}{N} {.} {\mathit{binop}})`.

      * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

      * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is constant.




:math:`\mathsf{ref{.}i{\scriptstyle 31}}` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{struct{.}new}~x)` is constant.




:math:`(\mathsf{struct{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new}~x)` is constant.




:math:`(\mathsf{array{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new\_fixed}~x~n)` is constant.




:math:`\mathsf{any{.}convert\_extern}` is constant.




:math:`\mathsf{extern{.}convert\_any}` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`({\mathsf{i}}{N} {.} {\mathit{binop}})` is constant if:


   * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

   * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type definition :math:`(\mathsf{type}~{\mathit{rectype}})` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}` if:


   * The length of :math:`C{.}\mathsf{types}` is equal to :math:`x`.

   * The defined type sequence :math:`{{\mathit{dt}}^\ast}` is of the form :math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the recursive type :math:`{\mathit{rectype}}` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x)})`.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`({\mathit{init}}~t)` if:


   * Either:

      * The initialization status :math:`{\mathit{init}}` is of the form :math:`\mathsf{set}`.

      * A :ref:`default value <aux-default>` for the value type :math:`t` is defined.

   * Or:

      * The initialization status :math:`{\mathit{init}}` is of the form :math:`\mathsf{unset}`.

      * A :ref:`default value <aux-default>` for the value type :math:`t` is not defined.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`(\mathsf{set}~t)` if:


   * A :ref:`default value <aux-default>` for the value type :math:`t` is defined.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`(\mathsf{unset}~t)` if:


   * A :ref:`default value <aux-default>` for the value type :math:`t` is not defined.




The function :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the type :math:`C{.}\mathsf{types}{}[x]` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The length of :math:`{{{\mathit{lt}}}^\ast}` is equal to the length of :math:`{{\mathit{local}}^\ast}`.

   * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}`, and corresponding :math:`{\mathit{local}}` in :math:`{{\mathit{local}}^\ast}`:

      * The local :math:`{\mathit{local}}` is :ref:`valid <valid-val>` with the local type :math:`{{\mathit{lt}}}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {(\mathsf{set}~t_1)^\ast}~{{{\mathit{lt}}}^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{globaltype}}` if:


   * The global type :math:`{\mathit{gt}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{globaltype}}` is of the form :math:`({\mathsf{mut}^?}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tabletype}}` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.

   * The table type :math:`{\mathit{tabletype}}` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}`.

   * :math:`{\mathit{expr}}` is constant.




The memory :math:`(\mathsf{memory}~{\mathit{memtype}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{memtype}}` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The tag :math:`(\mathsf{tag}~x)` is :ref:`valid <valid-val>` with the type :math:`C{.}\mathsf{types}{}[x]` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The element mode :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}` if:


   * Either:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

      * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{passive}`.
   * Or:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{declare}`.




The element mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

   * :math:`{\mathit{expr}}` is constant.




The element mode :math:`\mathsf{passive}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.




The element mode :math:`\mathsf{declare}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{elemtype}}` if:


   * The reference type :math:`{\mathit{elemtype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{elemtype}}`.

      * :math:`{\mathit{expr}}` is constant.

   * The element mode :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{elemtype}}`.




The data mode :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>` with the data type :math:`\mathsf{ok}` if:


   * Either:

      * The data mode :math:`{\mathit{datamode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * The data mode :math:`{\mathit{datamode}}` is of the form :math:`\mathsf{passive}`.




The data mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` with the data type :math:`\mathsf{ok}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

   * :math:`{\mathit{expr}}` is constant.




The data mode :math:`\mathsf{passive}` is :ref:`valid <valid-val>` with the data type :math:`\mathsf{ok}`.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is :ref:`valid <valid-val>` with the data type :math:`\mathsf{ok}` if:


   * The data mode :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>` with the data type :math:`\mathsf{ok}`.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the function :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~\epsilon~\rightarrow~\epsilon)`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{dt}})`.

      * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{tag}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{jt}})`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` is of the form :math:`{\mathit{jt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{dt}})` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{tag}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{tag}~{\mathit{jt}})` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The tag :math:`C{.}\mathsf{tags}{}[x]` is of the form :math:`{\mathit{jt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the name :math:`{\mathit{name}}` and the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The global sequence :math:`{{\mathit{global}'}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{globaltype}}^\ast}` if:


   * Either:

      * The global sequence :math:`{{\mathit{global}'}^\ast}` is empty.

      * The global type sequence :math:`{{\mathit{globaltype}}^\ast}` is empty.

   * Or:

      * The global sequence :math:`{{\mathit{global}'}^\ast}` is of the form :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}`.

      * The global type sequence :math:`{{\mathit{globaltype}}^\ast}` is of the form :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}`.

      * The global :math:`{\mathit{global}}_1` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}_1`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

      * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The global sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the global type sequence :math:`\epsilon`.




The global sequence :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}` if:


   * The global :math:`{\mathit{global}}_1` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}_1`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The type definition sequence :math:`{{\mathit{type}'}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{deftype}}^\ast}` if:


   * Either:

      * The type definition sequence :math:`{{\mathit{type}'}^\ast}` is empty.

      * The defined type sequence :math:`{{\mathit{deftype}}^\ast}` is empty.

   * Or:

      * The type definition sequence :math:`{{\mathit{type}'}^\ast}` is of the form :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}`.

      * The defined type sequence :math:`{{\mathit{deftype}}^\ast}` is of the form :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}`.

      * The type definition :math:`{\mathit{type}}_1` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

      * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The type definition sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the defined type sequence :math:`\epsilon`.




The type definition sequence :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}` if:


   * The type definition :math:`{\mathit{type}}_1` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` with the module type :math:`t` if:


   * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{return}~\epsilon \}\end{array}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}'}^\ast}`.

   * The length of :math:`{{\mathit{import}}^\ast}` is equal to the length of :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`, and corresponding :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}_{\mathsf{i}}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.

   * The length of :math:`{{\mathit{table}}^\ast}` is equal to the length of :math:`{{\mathit{tt}}^\ast}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, and corresponding :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * The length of :math:`{{\mathit{mem}}^\ast}` is equal to the length of :math:`{{\mathit{mt}}^\ast}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`, and corresponding :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * The length of :math:`{{\mathit{jt}}^\ast}` is equal to the length of :math:`{{\mathit{tag}}^\ast}`.

   * For all :math:`{\mathit{jt}}` in :math:`{{\mathit{jt}}^\ast}`, and corresponding :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`:

      * Under the context :math:`{C'}`, the tag :math:`{\mathit{tag}}` is :ref:`valid <valid-val>` with the tag type :math:`{\mathit{jt}}`.

   * The length of :math:`{{\mathit{dt}}^\ast}` is equal to the length of :math:`{{\mathit{func}}^\ast}`.

   * For all :math:`{\mathit{dt}}` in :math:`{{\mathit{dt}}^\ast}`, and corresponding :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the defined type :math:`{\mathit{dt}}`.

   * The length of :math:`{{\mathit{elem}}^\ast}` is equal to the length of :math:`{{\mathit{rt}}^\ast}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, and corresponding :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

      * The table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.

   * The length of :math:`{{\mathit{data}}^\ast}` is equal to the length of :math:`{{\mathit{ok}}^\ast}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, and corresponding :math:`{\mathit{ok}}` in :math:`{{\mathit{ok}}^\ast}`:

      * The memory segment :math:`{\mathit{data}}` is valid.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * The length of :math:`{{\mathit{export}}^\ast}` is equal to the length of :math:`{{\mathit{nm}}^\ast}`.

   * The length of :math:`{{\mathit{export}}^\ast}` is equal to the length of :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, and corresponding :math:`{\mathit{nm}}` in :math:`{{\mathit{nm}}^\ast}`, and corresponding :math:`{\mathit{xt}}_{\mathsf{e}}` in :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the name :math:`{\mathit{nm}}` and the external type :math:`{\mathit{xt}}_{\mathsf{e}}`.

   * :math:`{{\mathit{nm}}^\ast}~{\mathrm{disjoint}}` is of the form true.

   * The context :math:`C` is of the form :math:`{C'}{}[{.}\mathsf{globals} \mathrel{{=}{\oplus}} {{\mathit{gt}}^\ast}]{}[{.}\mathsf{tables} \mathrel{{=}{\oplus}} {{\mathit{tt}}_{\mathsf{i}}^\ast}~{{\mathit{tt}}^\ast}]{}[{.}\mathsf{mems} \mathrel{{=}{\oplus}} {{\mathit{mt}}_{\mathsf{i}}^\ast}~{{\mathit{mt}}^\ast}]{}[{.}\mathsf{tags} \mathrel{{=}{\oplus}} {{\mathit{jt}}_{\mathsf{i}}^\ast}~{{\mathit{jt}}^\ast}]{}[{.}\mathsf{elems} \mathrel{{=}{\oplus}} {{\mathit{rt}}^\ast}]{}[{.}\mathsf{datas} \mathrel{{=}{\oplus}} {{\mathit{ok}}^\ast}]`.

   * The context :math:`{C'}` is of the form :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\; \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast},\; \mathsf{return}~\epsilon,\; \mathsf{refs}~{x^\ast} \}\end{array}`.

   * The function index sequence :math:`{x^\ast}` is of the form :math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast})`.

   * The defined type sequence :math:`{{\mathit{dt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The global type sequence :math:`{{\mathit{gt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The table type sequence :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The tag type sequence :math:`{{\mathit{jt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * Let :math:`t` be the module type :math:`{{\mathrm{clos}}}_{C}({{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast})`.




The number value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.




The vector value :math:`({\mathit{vt}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.




The reference value :math:`{\mathit{ref}'}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}''}` if:


   * Either:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})`.

      * The heap type :math:`{\mathit{ht}'}` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}`.

   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}struct}~a)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}array}~a)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}func}~a)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}exn}~a)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~\mathsf{exn})`.

      * The exception instance :math:`s{.}\mathsf{exns}{}[a]` exists.

      * The exception instance :math:`s{.}\mathsf{exns}{}[a]` is of the form :math:`{\mathit{exn}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}host}~a)`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~\mathsf{any})`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`(\mathsf{ref}~\mathsf{extern})`.

      * Under the context :math:`s`, the reference value :math:`{\mathit{addrref}}` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.
   * Or:

      * The reference value :math:`{\mathit{ref}'}` is of the form :math:`{\mathit{ref}}`.

      * The reference type :math:`{\mathit{rt}''}` is of the form :math:`{\mathit{rt}}`.

      * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}'}`.

      * The reference type :math:`{\mathit{rt}'}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The reference value :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})` if:


   * The heap type :math:`{\mathit{ht}'}` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}`.




The reference value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.




The reference value :math:`(\mathsf{ref{.}struct}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}array}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}func}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}exn}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{exn})` if:


   * The exception instance :math:`s{.}\mathsf{exns}{}[a]` exists.

   * The exception instance :math:`s{.}\mathsf{exns}{}[a]` is of the form :math:`{\mathit{exn}}`.




The reference value :math:`(\mathsf{ref{.}host}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.




The reference value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{extern})` if:


   * Under the context :math:`s`, the reference value :math:`{\mathit{addrref}}` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.




The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}'}`.

   * The reference type :math:`{\mathit{rt}'}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The value :math:`{\mathit{val}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{valtype}}` if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{num}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * Under the context :math:`s`, the number value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{vec}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{vt}}`.

      * Under the context :math:`s`, the vector value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{ref}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{rt}}`.

      * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{nt}}` if:


   * Under the context :math:`s`, the number value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.




The value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{vt}}` if:


   * Under the context :math:`s`, the vector value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.




The value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}` if:


   * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The external address :math:`{\mathit{externaddr}'}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`(\mathsf{func}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is of the form :math:`{\mathit{funcinst}}`.

   * Or:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`(\mathsf{global}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})`.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` is of the form :math:`{\mathit{globalinst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`(\mathsf{table}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})`.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` is of the form :math:`{\mathit{tableinst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`(\mathsf{mem}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})`.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is of the form :math:`{\mathit{meminst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`(\mathsf{tag}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})`.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is of the form :math:`{\mathit{taginst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}'}` is of the form :math:`{\mathit{externaddr}}`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`{\mathit{xt}}`.

      * Under the context :math:`s`, the external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}'}`.

      * The external type :math:`{\mathit{xt}'}` :ref:`matches <match>` the external type :math:`{\mathit{xt}}`.




The external address :math:`(\mathsf{func}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is of the form :math:`{\mathit{funcinst}}`.




The external address :math:`(\mathsf{global}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})` if:


   * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

   * The global instance :math:`s{.}\mathsf{globals}{}[a]` is of the form :math:`{\mathit{globalinst}}`.




The external address :math:`(\mathsf{table}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})` if:


   * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

   * The table instance :math:`s{.}\mathsf{tables}{}[a]` is of the form :math:`{\mathit{tableinst}}`.




The external address :math:`(\mathsf{mem}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})` if:


   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is of the form :math:`{\mathit{meminst}}`.




The external address :math:`(\mathsf{tag}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})` if:


   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is of the form :math:`{\mathit{taginst}}`.




The external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * Under the context :math:`s`, the external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}'}`.

   * The external type :math:`{\mathit{xt}'}` :ref:`matches <match>` the external type :math:`{\mathit{xt}}`.




The instruction sequence :math:`{\mathit{instr}'}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction :math:`{\mathit{instr}'}` is of the form :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`\mathsf{i{\scriptstyle 32}}`.

   * Or:

      * The instruction :math:`{\mathit{instr}'}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`t`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathsf{mut}^?}~t)`.
   * Or:

      * The instruction :math:`{\mathit{instr}'}` is of the form :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t_2^\ast}`.

      * The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

      * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction sequence :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathsf{mut}^?}~t)`.




The instruction sequence :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` L from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~l`
.....................


1. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Let L be the topmost :math:`\mathsf{label}`.

   #. Let :math:`n` be the arity of L

   #. If :math:`l = 0`, then:

      1) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

      #) Pop the :math:`\mathsf{label}` L from the stack.

      #) Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

      #) Jump to the continuation of L.

   #. Else:

      1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) If :math:`l > 0`, then:

         a) Pop the :math:`\mathsf{label}` L from the stack.

         #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l - 1)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{handler}` H from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{br\_on\_null}~l`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{br\_on\_non\_null}~l`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{return\_call\_indirect}~x~y`
...........................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.


:math:`\mathsf{frame}`
......................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of f

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let f be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of f

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` F from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.

#. Else:

   a. If the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

      1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) Pop the :math:`\mathsf{handler}` H from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`\mathsf{return}`.


:math:`\mathsf{handler}`
........................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

#. Pop the :math:`\mathsf{handler}` H from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}i{\scriptstyle 31}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Push the value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~{{\mathrm{wrap}}}_{32, 31}(i))` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}as\_non\_null}`
....................................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{ref{.}eq}`
.........................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_2` from the stack.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_1` from the stack.

#. If :math:`{\mathit{ref}}_1` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. If :math:`{\mathit{ref}}_2` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

   #. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.

#. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`
.......................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}i{\scriptstyle 31}}` :math:`{\mathit{u{\kern-0.1em\scriptstyle 31}}}`, then:

   a. Let :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` be the destructuring of :math:`{\mathit{val}}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{31, 32}^{{\mathit{sx}}}}}{(i)})` to the stack.


:math:`\mathsf{array{.}new}~x`
..............................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{extern{.}convert\_any}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{extern})` to the stack.

#. If :math:`{\mathit{val}}` is address value, then:

   a. Push the value :math:`(\mathsf{ref{.}extern}~{\mathit{val}})` to the stack.


:math:`\mathsf{any{.}convert\_extern}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{any})` to the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}extern}` :math:`{\mathit{addrref}}`, then:

   a. Let :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` be the destructuring of :math:`{\mathit{val}}`.

   #. Push the value :math:`{\mathit{addrref}}` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vternop}}`
............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vtestop}}`
............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`i` be :math:`{{\mathit{vtestop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vshiftop}}`
.............................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vshiftop}}}{{}_{{\mathit{sh}}}}{(c_1, i)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{bitmask}`
........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vbitmask}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{swizzlop}}`
.............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{swizzlop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast}`
.................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vshuffle}}{{}_{{\mathit{sh}}}({i^\ast}, c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_1)^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}}{\mathsf{x}}{M}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}'}^?}}~i`
..........................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}'}^?}` is not defined and :math:`{\mathit{lanetype}}` is number type and :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1)|}`, then:

   a. Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1){}[i]`.

   #. Push the value :math:`({\mathit{lanetype}}{.}\mathsf{const}~c_2)` to the stack.

#. If :math:`{\mathit{lanetype}}` is packed type and :math:`{{\mathit{sx}'}^?}` is defined, then:

   a. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

   #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1)|}`, then:

      1) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_2)])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
...............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextunop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextbinop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextternop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{\mathit{sx}}}`
.....................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vnarrow}}{{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}^{{\mathit{sx}}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vcvtop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vcvtop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`m` and whose continuation is the start of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
...............................................................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
.....................................................................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Do nothing.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be the address :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{call\_ref}~y`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}func}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

      1) Let :math:`{\mathit{fi}}` be the function instance :math:`z{.}\mathsf{funcs}{}[a]`.

      #) Assert: Due to validation, :math:`{\mathit{fi}}{.}\mathsf{code}` is some :math:`\mathsf{func}` :math:`{\mathit{typeidx}}` :math:`{{\mathit{local}}^\ast}` :math:`{\mathit{expr}}`.

      #) Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{fi}}{.}\mathsf{code}`.

      #) Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

      #) Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{fi}}{.}\mathsf{type}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

      #) Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{fi}}{.}\mathsf{type}`.

      #) Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be the destructuring of :math:`{\mathit{functype}}_0`.

      #) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Let :math:`f` be the frame :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{n}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{fi}}{.}\mathsf{module} \}\end{array}`.

      #) Let f be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`m`.

      #) Push the :math:`\mathsf{frame}` F.

      #) Let L be the :math:`\mathsf{label}` whose arity is :math:`m` and whose continuation is the end of the block.

      #) Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{return\_call}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be the address :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` L from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{handler}` H from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else:

   a. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

      1) Assert: Due to validation, a value is on the top of the stack.

      #) Pop the value :math:`{\mathit{val}''}` from the stack.

      #) If :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

         a) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

         #) Pop the :math:`\mathsf{frame}` F from the stack.

         #) Trap.

      #) If :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}func}` :math:`{\mathit{funcaddr}}`, then:

         a) Let :math:`(\mathsf{ref{.}func}~a)` be the destructuring of :math:`{\mathit{val}''}`.

         #) If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

            1. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

            #. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`.

            #. Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be the destructuring of :math:`{\mathit{functype}}_0`.

            #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

            #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

            #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

            #. Pop the :math:`\mathsf{frame}` F from the stack.

            #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

            #. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}exn}` :math:`{\mathit{exnaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}exn}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`{{\mathit{val}}^\ast} \neq \epsilon`, then:

      1) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

      1) Pop the :math:`\mathsf{label}` L from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else:

      1) If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

         a) Pop the :math:`\mathsf{frame}` F from the stack.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else if not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

         a) Throw the exception :math:`{\mathit{val}'}` as a result.

      #) Else:

         a) Let H be the topmost :math:`\mathsf{handler}`.

         #) Let :math:`n` be the arity of H

         #) Let :math:`{{\mathit{catch}''}^\ast}` be the catch handler of H

         #) If :math:`{{\mathit{catch}''}^\ast} = \epsilon`, then:

            1. Pop the :math:`\mathsf{handler}` H from the stack.

            #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #. Execute the instruction :math:`\mathsf{throw\_ref}`.

         #) Else if :math:`a \geq {|z{.}\mathsf{exns}|}`, then:

            1. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}` :math:`{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. Pop the :math:`\mathsf{handler}` H from the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}` :math:`{\mathit{labelidx}}`, then:

               a. Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

               #. Pop the :math:`\mathsf{handler}` H from the stack.

               #. Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

               #. Push the :math:`\mathsf{handler}` H.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else:

               a. Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. Pop the :math:`\mathsf{handler}` H from the stack.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

         #) Else:

            1. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

            #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch}` :math:`{\mathit{tagidx}}` :math:`{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. If :math:`x < {|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} = z{.}\mathsf{tags}{}[x]`, then:

                  1) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` H.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else if :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_ref}` :math:`{\mathit{tagidx}}` :math:`{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch\_ref}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. If :math:`x \geq {|z{.}\mathsf{tags}|}`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` H.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else if :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} \neq z{.}\mathsf{tags}{}[x]`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` H.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else:

               a. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}` :math:`{\mathit{labelidx}}`, then:

                  1) Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}` :math:`{\mathit{labelidx}}`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` H.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

                  #) Pop the :math:`\mathsf{handler}` H from the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else if not the first non-value entry of the stack is a :math:`\mathsf{label}` and not the first non-value entry of the stack is a :math:`\mathsf{frame}` and not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Throw the exception :math:`{\mathit{val}'}` as a result.


:math:`\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let H be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}}^\ast}`.

#. Push the :math:`\mathsf{handler}` H.

#. Let L be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` L.


:math:`\mathsf{ref{.}null}~x`
.............................


1. Let :math:`z` be the current state.

#. Push the value :math:`(\mathsf{ref{.}null}~z{.}\mathsf{types}{}[x])` to the stack.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{ref{.}test}~{\mathit{rt}}`
.........................................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}cast}~{\mathit{rt}}`
.........................................


1. Let f be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{struct{.}new\_default}~x`
........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

#. Assert: Due to validation, for all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{val}}^\ast}|} = {|{{\mathit{zt}}^\ast}|}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Execute the instruction :math:`(\mathsf{struct{.}new}~x)`.


:math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}struct}` :math:`{\mathit{structaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}struct}~a)` be the destructuring of :math:`{\mathit{val}}`.

   #. If :math:`i < {|z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{structs}|}`, then:

      1) Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`.

      #) Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

      #) Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

      #) If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

         a) Push the value :math:`{{{{\mathrm{unpack}}}_{{{\mathit{zt}}^\ast}{}[i]}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}new\_default}~x`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_elem}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Let :math:`{{\mathit{ref}}^{n}}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]`.

#. Push the values :math:`{{\mathit{ref}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_data}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

#. If :math:`i + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{{{\mathit{byte}}^\ast}^\ast}` be the result for which each :math:`{{\mathit{byte}}^\ast}` has length :math:`{|{\mathit{zt}}|} / 8`, and the :ref:`concatenation <notation-concat>` of :math:`{{{\mathit{byte}}^\ast}^\ast}` is :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]`.

#. Let :math:`{c^{n}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathit{zt}}}({c^{n}}) = {{\mathit{byte}}^\ast})^\ast}`.

#. Push the values :math:`{{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`i < {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{arrays}|}`, then:

      1) Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

      #) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

      #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

      #) Push the value :math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}len}`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|})` to the stack.


:math:`\mathsf{array{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. If :math:`a \geq {|z{.}\mathsf{arrays}|}`, then:

      1) Do nothing.

   #. Else if :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`n = 0`, then:

      1) Do nothing.

   #. Else:

      1) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathit{val}}` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`{\mathit{val}}` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}fill}~x)`.


:math:`\mathsf{array{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}` and :math:`{\mathit{val}}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}` and :math:`{\mathit{val}'}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a_1)` be the destructuring of :math:`{\mathit{val}'}`.

   #. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

      1) If :math:`a_1 < {|z{.}\mathsf{arrays}|}` and :math:`i_1 + n > {|z{.}\mathsf{arrays}{}[a_1]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) Let :math:`(\mathsf{ref{.}array}~a_2)` be the destructuring of :math:`{\mathit{val}}`.

      #) If :math:`a_2 \geq {|z{.}\mathsf{arrays}|}`, then:

         a) Do nothing.

      #) Else if :math:`i_2 + n > {|z{.}\mathsf{arrays}{}[a_2]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) If :math:`n = 0`, then:

         a) Do nothing.

      #) Else:

         a) Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x_2]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

         #) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x_2]`.

         #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be the destructuring of :math:`{\mathit{arraytype}}_0`.

         #) Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

         #) If :math:`i_1 \leq i_2`, then:

            1. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

            #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

            #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

         #) Else:

            1. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

            #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

            #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.


:math:`\mathsf{array{.}init\_elem}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

      1) Trap.

   #. If :math:`n = 0`, then:

      1) Do nothing.

   #. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

      1) Let :math:`{\mathit{ref}}` be the reference value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathit{ref}}` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}init\_elem}~x~y)`.


:math:`\mathsf{array{.}init\_data}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`, then:

      1) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

      #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

      #) If :math:`j + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) If :math:`n = 0`, then:

         a) Do nothing.

      #) Else:

         a) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}(c)` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j : {|{\mathit{zt}}|} / 8]`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

         #) Push the value :math:`{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + {|{\mathit{zt}}|} / 8)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}init\_data}~x~y)`.

   #. Else if :math:`n = 0`, then:

      1) Do nothing.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{locals}{}[x]` is defined.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{locals}{}[x]`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`{\mathit{val}}` be the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})` be the destructuring of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{type}`.

#. Let :math:`n` be the length of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x_{1'}~x_{2'}`
...........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{tables}{}[x_{1'}]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{tables}{}[x_{2'}]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_{2'})`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_{1'})`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_{2'})`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_{1'})`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x_{1'}~x_{2'})`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}'}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~x~{\mathit{ao}}`
...............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}'}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}'}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}'}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}'}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathit{nt}'}` is :math:`{\mathsf{i}}{N}` and :math:`{{\mathit{loadop}}^?}` is defined, then:

   a. Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`({\mathit{nt}'}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathit{nt}'}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~x~{\mathit{ao}}`
..............................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{vloadop}}^?}`.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is some :math:`\mathsf{shape}` :math:`{\mathit{sz}}` :math:`\mathsf{x}` :math:`M` :math:`\mathsf{\_}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{K}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}}) = z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<K}}`.

      #) If :math:`N` for which :math:`N` :math:`=` :math:`M \cdot 2` is :math:`{\mathsf{i}}{N}`, then:

         a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

         #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is some :math:`\mathsf{splat}` :math:`{\mathit{sz}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be the destructuring of :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

         a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

         #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

         #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is some :math:`\mathsf{zero}` :math:`{\mathit{sz}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be the destructuring of :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`{|\mathsf{v{\scriptstyle 128}}|} / N`.

#. If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

   #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

   #. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])}`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}~x`
................................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})` be the destructuring of :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{type}`.

#. Let :math:`n \cdot 64 \, {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}fill}~x)`.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)`.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x~y)`.


:math:`\mathsf{throw}~x`
........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{tags}|}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{tags}{}[x]{.}\mathsf{type}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{tags}{}[x]{.}\mathsf{type}`.

#. Let :math:`{t^{n}}~\rightarrow~{\mathit{resulttype}}_1` be the destructuring of :math:`{\mathit{functype}}_0`.

#. Assert: Due to validation, :math:`{\mathit{resulttype}}_1 = \epsilon`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{exns}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{exn}}` be the exception instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tag}~z{.}\mathsf{tags}{}[x],\; \mathsf{fields}~{{\mathit{val}}^{n}} \}\end{array}`.

#. Perform :math:`z{}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {\mathit{exn}}]`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{struct{.}new}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^{n}}` be :math:`{\mathit{structtype}}_0`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{structs}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{si}}` be the structure instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}struct}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {\mathit{si}}]`.


:math:`\mathsf{struct{.}set}~x~i`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}struct}` :math:`{\mathit{structaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}struct}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`.

   #. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

   #. If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

      1) Perform :math:`z{}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{{\mathit{zt}}^\ast}{}[i]}({\mathit{val}})]`.


:math:`\mathsf{array{.}new\_fixed}~x~n`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{arrays}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{ai}}` be the array instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {\mathit{ai}}]`.


:math:`\mathsf{array{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}` :math:`{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`.

   #. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{arraytype}}_0`.

   #. Perform :math:`z{}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})]`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be the table instance :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}'}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~x~{\mathit{ao}}`
.................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}'''}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}'''}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}'} = {\mathit{nt}'''}` and :math:`{{\mathit{storeop}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{\mathit{nt}'} = {\mathit{nt}'''}` and :math:`{{\mathit{storeop}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}'''}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}'''}|} / 8] = {b^\ast}]`.

#. If :math:`{\mathit{nt}'''}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{nt}'} = {\mathit{nt}'''}` and :math:`{{\mathit{storeop}}^?}` is defined, then:

   a. Let :math:`n` be :math:`{{\mathit{storeop}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathit{nt}'''}|}, n}(c))`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{ao}}`
.....................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`({\mathit{lanetype}})` for which :math:`{|{\mathit{lanetype}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

   #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)|}`, then:

      1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c){}[j])`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmem}}(z{.}\mathsf{mems}{}[x], n)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\Sigma}\, {{n''}^\ast}`
...............................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\Sigma}\, {{n'}^\ast}`.


:math:`{\Pi}\, {{n''}^\ast}`
............................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`1`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n \cdot {\Pi}\, {{n'}^\ast}`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X^\ast}`.

#. Return :math:`w`.


:math:`{\bigoplus}\, {X^\ast}`
..............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\bigoplus}\, {{{w'}^\ast}^\ast}`.


:math:`{\bigoplus}\, {X^\ast}`
..............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^{n}}~{({{w'}^{n}})^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^{n}}~{\bigoplus}\, {({{w'}^{n}})^\ast}`.


:math:`{X^\ast}~{\mathrm{disjoint}}`
....................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return true.

#. Let :math:`w~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w` is not contained in :math:`{{w'}^\ast}` and :math:`{{w'}^\ast}~{\mathrm{disjoint}}`.


:math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {X^\ast})`
.........................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`w`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. If :math:`w = w_1`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {{w'}^\ast})`.


:math:`{X^\ast} \setminus {w^\ast}`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w_1, {w^\ast})~{{w'}^\ast} \setminus {w^\ast}`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X^\ast})`
.............................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X^\ast}, {{w^\ast}^\ast})`
.........................................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`{\Large\times}~{X^\ast}`
...............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, {\Large\times}~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+N}`
............


1. Return :math:`({+((1 + n \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{cont}}(b)`
..........................


1. Assert: Due to validation, :math:`128 < b`.

#. Assert: Due to validation, :math:`b < 192`.

#. Return :math:`b - 128`.


:math:`{\mathrm{funcs}}({{\mathit{externidx}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externidx}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{globals}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externidx}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tables}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externidx}'}^\ast})`
.....................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{mems}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externidx}'}^\ast})`
.....................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{tag}` :math:`{\mathit{tagidx}}`, then:

   a. Let :math:`(\mathsf{tag}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tags}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{opt}}({{\mathit{free}'}^?})`
............................................................


1. If :math:`{{\mathit{free}'}^?}` is not defined, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Let :math:`{\mathit{free}}` be :math:`{{\mathit{free}'}^?}`.

#. Return :math:`{\mathit{free}}`.


:math:`{\mathrm{free}}_{\mathit{list}}({{\mathit{free}''}^\ast})`
.................................................................


1. If :math:`{{\mathit{free}''}^\ast} = \epsilon`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Let :math:`{\mathit{free}}~{{\mathit{free}'}^\ast}` be :math:`{{\mathit{free}''}^\ast}`.

#. Return `free ++ $free_list(free'*{free' <- free'*})`.


:math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{\mathit{typeidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{funcs}~{\mathit{funcidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`
..................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{globals}~{\mathit{globalidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tables}~{\mathit{tableidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`
............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{mems}~{\mathit{memidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{elems}~{\mathit{elemidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{datas}~{\mathit{dataidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{\mathit{localidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{labels}~{\mathit{labelidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`
..................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.


:math:`\mathsf{anyref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{any})`.


:math:`\mathsf{eqref}`
......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})`.


:math:`\mathsf{i{\scriptstyle 31}ref}`
......................................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})`.


:math:`\mathsf{structref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{struct})`.


:math:`\mathsf{arrayref}`
.........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})`.


:math:`\mathsf{funcref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.


:math:`\mathsf{exnref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{exn})`.


:math:`\mathsf{externref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{extern})`.


:math:`\mathsf{nullref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{none})`.


:math:`\mathsf{nullfuncref}`
............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{nofunc})`.


:math:`\mathsf{nullexnref}`
...........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noexn})`.


:math:`\mathsf{nullexternref}`
..............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noextern})`.


:math:`{\mathsf{i}}{N}`
.......................


1. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathsf{f}}{N}`
.......................


1. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{f{\scriptstyle 64}}`.


:math:`{\mathsf{i}}{N}`
.......................


1. If :math:`N = 8`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`N = 16`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{|{\mathit{numtype}}|}`
..............................


1. If :math:`{\mathit{numtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{numtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{numtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{numtype}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{|\mathsf{v{\scriptstyle 128}}|}`
........................................


1. Return :math:`128`.


:math:`{|{\mathit{packtype}}|}`
...............................


1. If :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}|}`
...............................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{|{\mathit{lanetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{|{\mathit{lanetype}}|}`.


:math:`{|{\mathit{storagetype}}|}`
..................................


1. If :math:`{\mathit{storagetype}}` is number type, then:

   a. Return :math:`{|{\mathit{storagetype}}|}`.

#. If :math:`{\mathit{storagetype}}` is vector type, then:

   a. Return :math:`{|{\mathit{storagetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{|{\mathit{storagetype}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{vt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{pt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}})`
..............................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathit{lanetype}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is number type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. If :math:`{\mathit{storagetype}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Fail.


:math:`{\mathrm{unpack}}({\mathit{vectype}})`
.............................................


1. Return :math:`{\mathit{vectype}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is literal type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. If :math:`{\mathit{storagetype}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`{\mathit{storagetype}}` is lane type, then:

   a. Return :math:`{\mathrm{unpack}}({\mathit{storagetype}})`.

#. Fail.


:math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`
........................................................


1. If :math:`{|{\mathit{at}}_1|} \leq {|{\mathit{at}}_2|}`, then:

   a. Return :math:`{\mathit{at}}_1`.

#. Return :math:`{\mathit{at}}_2`.


:math:`\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1 \setminus \mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_2`
.........................................................................................................................


1. If :math:`{\mathsf{null}^?} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref}~{\mathit{ht}}_1)`.

#. Assert: Due to validation, :math:`{\mathsf{null}^?}` is not defined.

#. Return :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1)`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{dt}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{tag}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{jt}}~{\mathrm{tags}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xt}}^\ast})`.


:math:`{{\mathit{tv}}}{{}[ {{\mathit{typevar}}^\ast} := {{\mathit{typeuse}}^\ast} ]}`
.....................................................................................


1. If :math:`{{\mathit{typevar}}^\ast} = \epsilon` and :math:`{{\mathit{typeuse}}^\ast} = \epsilon`, then:

   a. Return :math:`{\mathit{tv}}`.

#. Assert: Due to validation, :math:`{|{{\mathit{typeuse}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}'}^\ast}` be :math:`{{\mathit{typeuse}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{typevar}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tv}}_1~{{\mathit{tv}'}^\ast}` be :math:`{{\mathit{typevar}}^\ast}`.

#. If :math:`{\mathit{tv}} = {\mathit{tv}}_1`, then:

   a. Return :math:`{\mathit{tu}}_1`.

#. Return :math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}`.


:math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{pt}}`.


:math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{nt}}`.


:math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{vt}}`.


:math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. If :math:`{\mathit{typeuse}}` is type variable, then:

   a. Return :math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is defined type.

#. Return :math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. If :math:`{\mathit{heaptype}}` is type variable, then:

   a. Return :math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{heaptype}}` is defined type, then:

   a. Return :math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Return :math:`{\mathit{heaptype}}`.


:math:`{\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..........................................................................................................


1. Return :math:`(\mathsf{ref}~{\mathsf{null}^?}~{{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. If :math:`{\mathit{valtype}}` is number type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{valtype}}` is vector type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{valtype}}` is reference type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{bot}`.

#. Return :math:`\mathsf{bot}`.


:math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
....................................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathsf{mut}^?}~{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................


1. Return :math:`({\mathsf{mut}^?}~{{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{comptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`, then:

   a. Let :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`(\mathsf{struct}~{{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.

#. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{yt}})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`(\mathsf{array}~{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

#. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{comptype}}`.

#. Return :math:`(\mathsf{func}~{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{tu}'}^\ast}~{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................................................................


1. Return :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~{{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{\mathsf{rec}~{{\mathit{st}}^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`(\mathsf{rec}~{{{\mathit{st}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.


:math:`{{\mathit{qt}} {.} i}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. Return :math:`({{\mathit{qt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]} {.} i)`.


:math:`{{t_1^\ast}~\rightarrow~{t_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`{{t_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{t_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{{\mathit{at}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{at}}`.


:math:`{{\mathsf{mut}^?}~t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. Return :math:`({\mathsf{mut}^?}~{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~\mathsf{page}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.


:math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{externtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................


1. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{func}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{func}~{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{global}` :math:`{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{global}~{{\mathit{gt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{table}` :math:`{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{table}~{{\mathit{tt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{mem}~{{\mathit{mt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}` is some :math:`\mathsf{tag}` :math:`{\mathit{typeuse}}`.

#. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be the destructuring of :math:`{\mathit{externtype}}`.

#. Return :math:`(\mathsf{tag}~{{\mathit{jt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{{\mathit{xt}}_1^\ast}~\rightarrow~{{\mathit{xt}}_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................................


1. Return :math:`{{{\mathit{xt}}_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{{\mathit{xt}}_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{t}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.............................................


1. Return :math:`{t}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{rt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{gt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{tt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{mt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
..........................................................


1. Return :math:`{{\mathit{mmt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{{\mathit{deftype}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`
......................................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{dt}}_1~{{\mathit{dt}}^\ast}` be :math:`{{\mathit{deftype}}^\ast}`.

#. Return :math:`{{\mathit{dt}}_1}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}~{{{\mathit{dt}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`
.................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {x + i^{i<n}} := {(\mathsf{rec}~i)^{i<n}} ]}^{n}})`.


:math:`{\mathrm{unroll}}({\mathit{rectype}})`
.............................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {(\mathsf{rec}~i)^{i<n}} := {({\mathit{rectype}} {.} i)^{i<n}} ]}^{n}})`.


:math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`
............................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`.

#. Return :math:`{((\mathsf{rec}~{{\mathit{subtype}}^{n}}) {.} i)^{i<n}}`.


:math:`{\mathrm{unroll}}({\mathit{rectype}} {.} i)`
...................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` be the destructuring of :math:`{\mathrm{unroll}}({\mathit{rectype}})`.

#. Return :math:`{{\mathit{subtype}}^\ast}{}[i]`.


:math:`{\mathrm{expand}}({\mathit{deftype}})`
.............................................


1. Let :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})` be the destructuring of :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. Return :math:`{\mathit{comptype}}`.


:math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`
................................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{lanetype}})`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{consttype}}({\mathit{consttype}})`
..................................................................


1. If :math:`{\mathit{consttype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{consttype}})`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}` is vector type.

#. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{consttype}})`.


:math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`
......................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typevar}})`
..............................................................


1. If :math:`{\mathit{typevar}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the type variable :math:`{\mathit{typevar}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. Assert: Due to validation, :math:`{\mathit{typevar}}` is some :math:`\mathsf{rec}` :math:`\mathbb{N}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`
................................................................


1. If :math:`{\mathit{heaptype}}` is abstract heap type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{heaptype}})`.

#. Assert: Due to validation, :math:`{\mathit{heaptype}}` is type use.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{reftype}}(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})`
..............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`
..............................................................


1. If :math:`{\mathit{typeuse}}` is type variable, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typeuse}})`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is defined type.

#. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`
..............................................................


1. If :math:`{\mathit{valtype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{valtype}})`.

#. If :math:`{\mathit{valtype}}` is vector type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{valtype}})`.

#. If :math:`{\mathit{valtype}}` is reference type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{valtype}})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{bot}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{resulttype}}({{\mathit{valtype}}^\ast})`
........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`
......................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{storagetype}})`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathsf{mut}^?}~{\mathit{storagetype}})`
.....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{structtype}}({{\mathit{fieldtype}}^\ast})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{fieldtype}})`
..................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})`.


:math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{resulttype}}_1~\rightarrow~{\mathit{resulttype}}_2)`
........................................................................................................


1. Return `$free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2)`.


:math:`{\mathrm{free}}_{\mathit{comptype}}({\mathit{comptype}})`
................................................................


1. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{struct}` :math:`{\mathit{structtype}}`, then:

   a. Let :math:`(\mathsf{struct}~{\mathit{structtype}})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{structtype}}({\mathit{structtype}})`.

#. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{array}` :math:`{\mathit{arraytype}}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{arraytype}})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{arraytype}})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}})` be the destructuring of :math:`{\mathit{comptype}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{functype}})`.


:math:`{\mathrm{free}}_{\mathit{subtype}}(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})`
.........................................................................................................................


1. Return `$free_list($free_typeuse(typeuse)*{typeuse <- typeuse*}) ++ $free_comptype(comptype)`.


:math:`{\mathrm{free}}_{\mathit{rectype}}(\mathsf{rec}~{{\mathit{subtype}}^\ast})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{subtype}}({\mathit{subtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{rectype}} {.} n)`
....................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathsf{mut}^?}~{\mathit{valtype}})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.


:math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})`
......................................................................................................


1. Return `$free_addrtype(addrtype) ++ $free_reftype(reftype)`.


:math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`.


:math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{deftype}})`
..............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{elemtype}}({\mathit{reftype}})`
...............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{datatype}}(\mathsf{ok})`
........................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`
....................................................................


1. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{func}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{global}` :math:`{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathit{globaltype}})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{table}` :math:`{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tabletype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{tabletype}})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memtype}}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memtype}})` be the destructuring of :math:`{\mathit{externtype}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{moduletype}}({{\mathit{externtype}}_1^\ast}~\rightarrow~{{\mathit{externtype}}_2^\ast})`
........................................................................................................................


1. Return `$free_list($free_externtype(externtype_1)*{externtype_1 <- externtype_1*}) ++ $free_list($free_externtype(externtype_2)*{externtype_2 <- externtype_2*})`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{N}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{\mathit{consttype}}{.}\mathsf{const}~c`
...............................................


1. If :math:`{\mathit{consttype}}` is number type, then:

   a. Return :math:`({\mathit{consttype}}{.}\mathsf{const}~c)`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}` is vector type.

#. Return :math:`({\mathit{consttype}}{.}\mathsf{const}~c)`.


:math:`{\mathrm{free}}_{\mathit{shape}}({{\mathit{lanetype}}}{\mathsf{x}}{{\mathit{dim}}})`
...........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{blocktype}}({\mathit{blocktype}})`
..................................................................


1. If :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`, then:

   a. Let :math:`{{\mathit{valtype}}^?}` be the block type :math:`{\mathit{blocktype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^?})`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`.

#. Let :math:`{\mathit{funcidx}}` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}''}^\ast})`
...........................................................................


1. If :math:`{{\mathit{labelidx}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{labelidx}}_0~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}''}^\ast}`.

#. If :math:`{\mathit{labelidx}}_0 = 0`, then:

   a. Return :math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.

#. Let :math:`{\mathit{labelidx}}~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}''}^\ast}`.

#. Return :math:`{\mathit{labelidx}} - 1~{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}'})`
...........................................................


1. If :math:`{\mathit{instr}'} = \mathsf{nop}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'} = \mathsf{unreachable}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'} = \mathsf{drop}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{select}` :math:`{({{\mathit{valtype}}^\ast})^?}`, then:

   a. Let :math:`(\mathsf{select}~{({{\mathit{valtype}}^\ast})^?})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})^?})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{block}` :math:`{\mathit{blocktype}}` :math:`{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{loop}` :math:`{\mathit{blocktype}}` :math:`{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{if}` :math:`{\mathit{blocktype}}` :math:`{{\mathit{instr}}^\ast}` :math:`\mathsf{else}` :math:`{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr_1*{instr_1 <- instr_1*}) ++ $free_block(instr_2*{instr_2 <- instr_2*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br}` :math:`{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_if}` :math:`{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_if}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_table}` :math:`{{\mathit{labelidx}}^\ast}` :math:`{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}'})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_list($free_labelidx(labelidx)*{}) ++ $free_labelidx(labelidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_null}` :math:`{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_on\_null}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_non\_null}` :math:`{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_on\_non\_null}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_cast}` :math:`{\mathit{labelidx}}` :math:`{\mathit{reftype}}` :math:`{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_cast\_fail}` :math:`{\mathit{labelidx}}` :math:`{\mathit{reftype}}` :math:`{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{call}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call\_ref}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{call\_ref}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call\_indirect}` :math:`{\mathit{tableidx}}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}'} = \mathsf{return}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{return\_call}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call\_ref}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{return\_call\_ref}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call\_indirect}` :math:`{\mathit{tableidx}}` :math:`{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{const}` :math:`{\mathit{numtype}}` :math:`{{\mathit{num}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}{.}\mathsf{const}~{\mathit{numlit}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{unop}` :math:`{\mathit{numtype}}` :math:`{{\mathit{unop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{unop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{binop}` :math:`{\mathit{numtype}}` :math:`{{\mathit{binop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{binop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{testop}` :math:`{\mathit{numtype}}` :math:`{{\mathit{testop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{testop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{relop}` :math:`{\mathit{numtype}}` :math:`{{\mathit{relop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{relop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{cvtop}` :math:`{\mathit{numtype}}_1` :math:`{\mathit{numtype}}_2` :math:`{{\mathit{cvtop}}}_{{\mathit{numtype}}_2, {\mathit{numtype}}_1}`, then:

   a. Let :math:`({\mathit{numtype}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{numtype}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype_1) ++ $free_numtype(numtype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vconst}` :math:`{\mathit{vectype}}` :math:`{{\mathit{vec}}}_{{\mathit{vectype}}}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{const}~{\mathit{veclit}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vvunop}` :math:`{\mathit{vectype}}` :math:`{\mathit{vvunop}}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvunop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vvbinop}` :math:`{\mathit{vectype}}` :math:`{\mathit{vvbinop}}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvbinop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vvternop}` :math:`{\mathit{vectype}}` :math:`{\mathit{vvternop}}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvternop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vvtestop}` :math:`{\mathit{vectype}}` :math:`{\mathit{vvtestop}}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvtestop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vunop}` :math:`{\mathit{shape}}` :math:`{{\mathit{vunop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vunop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vbinop}` :math:`{\mathit{shape}}` :math:`{{\mathit{vbinop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vbinop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vternop}` :math:`{\mathit{shape}}` :math:`{{\mathit{vternop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vternop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vtestop}` :math:`{\mathit{shape}}` :math:`{{\mathit{vtestop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vtestop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vrelop}` :math:`{\mathit{shape}}` :math:`{{\mathit{vrelop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vrelop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vshiftop}` :math:`{\mathit{ishape}}` :math:`{{\mathit{vshiftop}}}_{{\mathit{ishape}}}`, then:

   a. Let :math:`({\mathit{ishape}} {.} {\mathit{vshiftop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vbitmask}` :math:`{\mathit{ishape}}`, then:

   a. Let :math:`({\mathit{ishape}}{.}\mathsf{bitmask})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vswizzlop}` :math:`{\mathit{bshape}}` :math:`{{\mathit{vswizzlop}}}_{{\mathit{bshape}}}`, then:

   a. Let :math:`({\mathit{bshape}} {.} {\mathit{vswizzlop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vshuffle}` :math:`{\mathit{bshape}}` :math:`{{\mathit{laneidx}}^\ast}`, then:

   a. Let :math:`({\mathit{bshape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vextunop}` :math:`{\mathit{ishape}}_1` :math:`{\mathit{ishape}}_2` :math:`{{\mathit{vextunop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}`, then:

   a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vextbinop}` :math:`{\mathit{ishape}}_1` :math:`{\mathit{ishape}}_2` :math:`{{\mathit{vextbinop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}`, then:

   a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vextternop}` :math:`{\mathit{ishape}}_1` :math:`{\mathit{ishape}}_2` :math:`{{\mathit{vextternop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}`, then:

   a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vnarrow}` :math:`{\mathit{ishape}}_1` :math:`{\mathit{ishape}}_2` :math:`{\mathit{sx}}`, then:

   a. Let :math:`({{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vcvtop}` :math:`{\mathit{shape}}_1` :math:`{\mathit{shape}}_2` :math:`{{\mathit{vcvtop}}}_{{\mathit{shape}}_2, {\mathit{shape}}_1}`, then:

   a. Let :math:`({\mathit{shape}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{shape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(shape_1) ++ $free_shape(shape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vsplat}` :math:`{\mathit{shape}}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{splat})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vextract\_lane}` :math:`{\mathit{shape}}` :math:`{{\mathit{sx}}^?}` :math:`{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vreplace\_lane}` :math:`{\mathit{shape}}` :math:`{\mathit{laneidx}}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}null}` :math:`{\mathit{heaptype}}`, then:

   a. Let :math:`(\mathsf{ref{.}null}~{\mathit{heaptype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}is\_null}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}as\_non\_null}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}eq}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}test}` :math:`{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{ref{.}test}~{\mathit{reftype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}cast}` :math:`{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{ref{.}cast}~{\mathit{reftype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{ref{.}func}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}i{\scriptstyle 31}}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{i{\scriptstyle 31}{.}get}` :math:`{\mathit{sx}}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}new}` :math:`{\mathit{typeidx}}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}new\_default}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{struct{.}new\_default}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}get}` :math:`{{\mathit{sx}}^?}` :math:`{\mathit{typeidx}}` :math:`{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}set}` :math:`{\mathit{typeidx}}` :math:`{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`(\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_default}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_default}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_fixed}` :math:`{\mathit{typeidx}}` :math:`{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_data}` :math:`{\mathit{typeidx}}` :math:`{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_elem}` :math:`{\mathit{typeidx}}` :math:`{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}get}` :math:`{{\mathit{sx}}^?}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}set}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}set}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{array{.}len}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}fill}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}fill}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}copy}` :math:`{\mathit{typeidx}}` :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}copy}~{\mathit{typeidx}}_1~{\mathit{typeidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}init\_data}` :math:`{\mathit{typeidx}}` :math:`{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}init\_elem}` :math:`{\mathit{typeidx}}` :math:`{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'} = \mathsf{extern{.}convert\_any}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'} = \mathsf{any{.}convert\_extern}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}get}` :math:`{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}get}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}set}` :math:`{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}set}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}tee}` :math:`{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}tee}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{global{.}get}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global{.}get}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{global{.}set}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global{.}set}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}get}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}get}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}set}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}set}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}size}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}size}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}grow}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}grow}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}fill}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}fill}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}copy}` :math:`{\mathit{tableidx}}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}copy}~{\mathit{tableidx}}_1~{\mathit{tableidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}init}` :math:`{\mathit{tableidx}}` :math:`{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{elem{.}drop}` :math:`{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{elem{.}drop}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{load}` :math:`{\mathit{numtype}}` :math:`{{{\mathit{loadop}}}_{{\mathit{numtype}}}^?}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{store}` :math:`{\mathit{numtype}}` :math:`{{{\mathit{storeop}}}_{{\mathit{numtype}}}^?}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vload}` :math:`{\mathit{vectype}}` :math:`{{{\mathit{vloadop}}}_{{\mathit{vectype}}}^?}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vload\_lane}` :math:`{\mathit{vectype}}` :math:`{\mathit{sz}}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}` :math:`{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vstore}` :math:`{\mathit{vectype}}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{vstore\_lane}` :math:`{\mathit{vectype}}` :math:`{\mathit{sz}}` :math:`{\mathit{memidx}}` :math:`{\mathit{memarg}}` :math:`{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}size}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}size}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}grow}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}grow}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}fill}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}fill}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}copy}` :math:`{\mathit{memidx}}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}copy}~{\mathit{memidx}}_1~{\mathit{memidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_memidx(memidx_1) ++ $free_memidx(memidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}init}` :math:`{\mathit{memidx}}` :math:`{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_memidx(memidx) ++ $free_dataidx(dataidx)`.

#. Assert: Due to validation, :math:`{\mathit{instr}'}` is some :math:`\mathsf{data{.}drop}` :math:`{\mathit{dataidx}}`.

#. Let :math:`(\mathsf{data{.}drop}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

#. Return :math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`.


:math:`{\mathrm{free}}_{\mathit{block}}({{\mathit{instr}}^\ast})`
.................................................................


1. Let :math:`{\mathit{free}}` be :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.

#. Return :math:`{\mathit{free}}{}[{.}\mathsf{labels} = {\mathrm{shift}}_{\mathit{labelidxs}}({\mathit{free}}{.}\mathsf{labels})]`.


:math:`{\mathrm{free}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{type}}(\mathsf{type}~{\mathit{rectype}})`
.........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{local}}(\mathsf{local}~t)`
..........................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}(t)`.


:math:`{\mathrm{free}}_{\mathit{func}}(\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}})`
.................................................................................................................


1. Return `$free_typeidx(typeidx) ++ $free_list($free_local(local)*{local <- local*}) ++ update($free_block(expr).LOCALS, [])`.


:math:`{\mathrm{free}}_{\mathit{global}}(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})`
................................................................................................


1. Return `$free_globaltype(globaltype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{table}}(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})`
.............................................................................................


1. Return `$free_tabletype(tabletype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{mem}}(\mathsf{memory}~{\mathit{memtype}})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{tag}}(\mathsf{tag}~{\mathit{typeidx}})`
.......................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.


:math:`{\mathrm{free}}_{\mathit{elemmode}}({\mathit{elemmode}})`
................................................................


1. If :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}` :math:`{\mathit{tableidx}}` :math:`{\mathit{expr}}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{elemmode}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_expr(expr)`.

#. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}} = \mathsf{declare}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})`
....................................................................................................................


1. Return `$free_reftype(reftype) ++ $free_list($free_expr(expr)*{expr <- expr*}) ++ $free_elemmode(elemmode)`.


:math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`
................................................................


1. If :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}` :math:`{\mathit{memidx}}` :math:`{\mathit{expr}}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{datamode}}`.

   #. Return `$free_memidx(memidx) ++ $free_expr(expr)`.

#. Assert: Due to validation, :math:`{\mathit{datamode}} = \mathsf{passive}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{data}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`.


:math:`{\mathrm{free}}_{\mathit{start}}(\mathsf{start}~{\mathit{funcidx}})`
...........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{export}}(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`.


:math:`{\mathrm{free}}_{\mathit{import}}(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{externtype}})`
....................................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`.


:math:`{\mathrm{free}}_{\mathit{module}}(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})`
..........................................................................................................................................................................................................................................................................................................................


1. Return `$free_list($free_type(type)*{type <- type*}) ++ $free_list($free_import(import)*{import <- import*}) ++ $free_list($free_func(func)*{func <- func*}) ++ $free_list($free_global(global)*{global <- global*}) ++ $free_list($free_table(table)*{table <- table*}) ++ $free_list($free_mem(mem)*{mem <- mem*}) ++ $free_list($free_tag(tag)*{tag <- tag*}) ++ $free_list($free_elem(elem)*{elem <- elem*}) ++ $free_list($free_data(data)*{data <- data*}) ++ $free_opt($free_start(start)?{start <- start?}) ++ $free_list($free_export(export)*{export <- export*})`.


:math:`{\mathrm{funcidx}}({\mathit{module}})`
.............................................


1. Return :math:`{\mathrm{free}}_{\mathit{module}}({\mathit{module}}){.}\mathsf{funcs}`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}^\ast})`
..................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{func}}({\mathit{func}})^\ast}){.}\mathsf{datas}`.


:math:`C{}[{.}\mathsf{local}{}[{{\mathit{localidx}}^\ast}] = {{\mathit{localtype}}^\ast}]`
..........................................................................................


1. If :math:`{{\mathit{localidx}}^\ast} = \epsilon` and :math:`{{\mathit{localtype}}^\ast} = \epsilon`, then:

   a. Return :math:`C`.

#. Assert: Due to validation, :math:`{|{{\mathit{localtype}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{lt}}}_1~{{{\mathit{lt}}}^\ast}` be :math:`{{\mathit{localtype}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{localidx}}^\ast}|} \geq 1`.

#. Let :math:`x_1~{x^\ast}` be :math:`{{\mathit{localidx}}^\ast}`.

#. Return :math:`C{}[{.}\mathsf{locals}{}[x_1] = {{\mathit{lt}}}_1]{}[{.}\mathsf{local}{}[{x^\ast}] = {{{\mathit{lt}}}^\ast}]`.


:math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{deftype}}^\ast})}`
.............................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{dt}}^\ast}~{\mathit{dt}}_n` be :math:`{{\mathit{deftype}}^\ast}`.

#. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}^\ast})}`.

#. Return :math:`{{\mathit{dt}'}^\ast}~{{\mathit{dt}}_n}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}(t)`
................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{dt}})`
............................................


1. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{mmt}})`
.............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{\mathit{typeuse}} \prec x, i`
.....................................


1. If :math:`{\mathit{typeuse}}` is defined type, then:

   a. Return true.

#. If :math:`{\mathit{typeuse}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the type use :math:`{\mathit{typeuse}}`.

   #. Return :math:`{\mathit{typeidx}} < x`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is some :math:`\mathsf{rec}` :math:`\mathbb{N}`.

#. Let :math:`(\mathsf{rec}~j)` be the destructuring of :math:`{\mathit{typeuse}}`.

#. Return :math:`j < i`.


:math:`{{\mathrm{unroll}}}_{C}({\mathit{heaptype}})`
....................................................


1. If :math:`{\mathit{heaptype}}` is defined type, then:

   a. Return :math:`{\mathrm{unroll}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{heaptype}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the heap type :math:`{\mathit{heaptype}}`.

   #. Return :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[{\mathit{typeidx}}])`.

#. Assert: Due to validation, :math:`{\mathit{heaptype}}` is some :math:`\mathsf{rec}` :math:`\mathbb{N}`.

#. Let :math:`(\mathsf{rec}~i)` be the destructuring of :math:`{\mathit{heaptype}}`.

#. Return :math:`C{.}\mathsf{recs}{}[i]`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{v}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~0)`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is some :math:`\mathsf{ref}` :math:`{\mathsf{null}^?}` :math:`{\mathit{heaptype}}`.

#. Let :math:`(\mathsf{ref}~{\mathit{NULL}}_{{\mathit{opt}}_0}~{\mathit{ht}})` be the destructuring of :math:`{\mathit{valtype}}`.

#. If :math:`{\mathit{NULL}}_{{\mathit{opt}}_0} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

#. Assert: Due to validation, :math:`{\mathit{NULL}}_{{\mathit{opt}}_0}` is not defined.

#. Return :math:`\epsilon`.


:math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast})`
.........................................................................................................................


1. Return :math:`{\mathrm{funcidx}}(\mathsf{module}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast})`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2 ]}`
...............................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2{}[i]`.

#. Return :math:`X_1~X_2{}[0]`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2, X_3, X_4 ]}`
.........................................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2~X_3~X_4{}[i]`.

#. Return :math:`X_1~X_2~X_3~X_4{}[0]`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sx}}({\mathit{storagetype}})`
.............................................


1. If :math:`{\mathit{storagetype}}` is literal type, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`\mathsf{s}`.


:math:`0`
.........


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. Return :math:`{+0}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

   a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

   a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

   a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

   a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({-{{\mathrm{signed}}}_{N}(i_1)})}`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

   a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{{{\mathrm{iextend}}}_{N, M}^{{\mathit{sx}}}}}{(i)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`i \mathbin{\mathrm{mod}} ({2^{M}})`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{signed}}}_{M}(i \mathbin{\mathrm{mod}} ({2^{M}})))}`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}}(c)`
..................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{lanetype}})|}, {|{\mathit{lanetype}}|}}(c)`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}}(c)`
.....................................................


1. If :math:`{\mathit{storagetype}}` is literal type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{storagetype}})|}, {|{\mathit{storagetype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}}(c)`
....................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, {|{\mathrm{unpack}}({\mathit{lanetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{unpack}}}_{{\mathit{storagetype}}}(c)`
.......................................................


1. If :math:`{\mathit{storagetype}}` is literal type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{storagetype}}|}, {|{\mathrm{unpack}}({\mathit{storagetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{numtype}}}({i'})}`
........................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}({i'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}({i'})`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}({i'})`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{sz}}`.

   #. Let :math:`({\mathsf{extend}}{M}{\mathsf{\_}}{\mathsf{s}})` be the destructuring of :math:`{\mathit{unop}}`.

   #. Return :math:`{{{{\mathrm{iextend}}}_{N, M}^{\mathsf{s}}}}{({i'})}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}({i'})`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}({i'})`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}({i'})`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}({i'})`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}({i'})`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}({i'})`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({i'})`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{numtype}}}(i_{1'}, i_{2'})}`
...................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{div}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{rem}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}}` is some :math:`\mathsf{shr}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}(i_{1'}, i_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}(i_{1'}, i_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}(i_{1'}, i_{2'})`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{N}}(i)}`
...............................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}(i)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{numtype}}}(i_{1'}, i_{2'})}`
...................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}(i_{1'}, i_{2'})`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{lt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{gt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{le}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

   #. If :math:`{\mathit{relop}}` is some :math:`\mathsf{ge}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_{1'}, i_{2'})}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}(i_{1'}, i_{2'})`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}(i_{1'}, i_{2'})`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}(i_{1'}, i_{2'})`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{numtype}}, {\mathit{numtype}''}}(i_{1'})}`
.................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_{1'})}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

      1) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}(i_{1'})`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_{1'})}`.

   #. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_{1'})}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{cvtop}}` is some :math:`\mathsf{convert}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_{1'})}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{N}`, then:

   a. If :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

      1) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}(i_{1'})`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

      1) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}(i_{1'})`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}''}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}''}|}`, then:

   a. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}''}}(i_{1'})`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}''}` is :math:`{\mathsf{i}}{N}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}''}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}''}}(i_{1'})`.


:math:`{{{{\mathrm{lanes}}}_{{\mathit{sh}}}^{{-1}}}}{({c^\ast})}`
.................................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{zeroop}}({{\mathit{lanetype}''}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}, {\mathit{vcvtop}})`
..............................................................................................................................


1. If :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

      1) Return :math:`\epsilon`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

      1) Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{zero}}^?}`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{relaxed\_trunc}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{zero}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}` :math:`{\mathit{zero}}`, then:

   a. Let :math:`({\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~{\mathit{zero}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{zero}}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\epsilon`.


:math:`{\mathrm{halfop}}({{\mathit{lanetype}''}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}, {\mathit{vcvtop}})`
..............................................................................................................................


1. If :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{\mathit{half}}`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{half}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Return :math:`\epsilon`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{relaxed\_trunc}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}` :math:`{\mathit{zero}}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\mathsf{low}`.


:math:`{\mathrm{half}}({\mathit{half}}, i, j)`
..............................................


1. If :math:`{\mathit{half}} = \mathsf{low}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{half}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{{\mathrm{iswizzle}}_{{\mathit{lane}}}}_{N}({c^\ast}, i)`
................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. Return :math:`0`.


:math:`{{\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}}_{N}({c^\ast}, i)`
.....................................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. If :math:`{{\mathrm{signed}}}_{N}(i) < 0`, then:

   a. Return :math:`0`.

#. Return :math:`{{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{swizzle}})}{{}[ 0, {c^\ast}{}[i \mathbin{\mathrm{mod}} {|{c^\ast}|}] ]}`.


:math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
..........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
...............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{fvtestop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Assert: Due to validation, :math:`({\mathit{numtype}})` for which :math:`{|{\mathit{numtype}}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, i)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, i)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`
........................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}(c)` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{N}^{\mathsf{s}}}}{(c_1, 0)}^\ast}~{0^{32 - M}}`.

#. Return :math:`{{\mathrm{irev}}}_{32}(c)`.


:math:`{{\mathrm{ivswizzlop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
..........................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({c_1^\ast}, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshufflop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`
......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{c_1^\ast}~{c_2^\ast}{}[i]^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{\mathsf{not}}{{}_{{\mathsf{v}}{N}}(v)}`
...............................................


1. Return :math:`{{\mathrm{inot}}}_{N}(v)`.


:math:`{{\mathit{vvbinop}}}{{}_{{\mathsf{v}}{N}}(v_1, v_2)}`
............................................................


1. If :math:`{\mathit{vvbinop}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{N}(v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{N}(v_1, v_2)`.


:math:`{\mathsf{bitselect}}{{}_{{\mathsf{v}}{N}}(v_1, v_2, v_3)}`
.................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{N}(v_1, v_2, v_3)`.


:math:`{{\mathit{vunop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v)}`
........................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`, then:

   a. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fabs}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fneg}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{sqrt}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fsqrt}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{ceil}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fceil}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{floor}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ffloor}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{trunc}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ftrunc}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{nearest}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fnearest}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`.

#. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iabs}}, v)`.

#. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ineg}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{vunop}} = \mathsf{popcnt}`.

#. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ipopcnt}}, v)`.


:math:`{{\mathit{vbinop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2)}`
................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iadd}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{isub}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imul}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{add\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iadd}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{sub\_sat}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{isub}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{min}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imin}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`\mathsf{max}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imax}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iavgr}}, \mathsf{u}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}_{{\mathit{sat}}}, \mathsf{s}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{q{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}}, \mathsf{s}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fadd}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fsub}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmul}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fdiv}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmin}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fpmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmax}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fpmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{relaxed\_min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{min}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}} = \mathsf{relaxed\_max}`.

#. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{max}}}, v_1, v_2)`.


:math:`{{\mathit{vternop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2, v_3)}`
......................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vternop}} = \mathsf{relaxed\_laneselect}`, then:

   a. Return :math:`{{\mathrm{ivternopnd}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{laneselect}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vternop}} = \mathsf{relaxed\_madd}`, then:

   a. Return :math:`{{\mathrm{fvternop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{madd}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{vternop}} = \mathsf{relaxed\_nmadd}`.

#. Return :math:`{{\mathrm{fvternop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{nmadd}}}, v_1, v_2, v_3)`.


:math:`{\mathsf{all\_true}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
......................................................................


1. Return :math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{inez}}, v)`.


:math:`{{\mathit{vrelop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2)}`
................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ieq}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ine}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{lt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ilt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{gt}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{igt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{le}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ile}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{ge}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ige}}, {\mathit{sx}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{feq}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fne}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{flt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fgt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fle}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fge}}, v_1, v_2)`.


:math:`{{\mathrm{lcvtop}}}_{{{\mathit{lanetype}''}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)`
......................................................................................................................................


1. If :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}` :math:`{{\mathit{half}}^?}` :math:`{\mathit{sx}}`, then:

      1) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}''}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{relaxed\_trunc}` :math:`{\mathit{sx}}` :math:`{{\mathit{zero}}^?}`, then:

      1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{relaxed\_trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}} = ({\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~\mathsf{zero})`, then:

   a. Let :math:`{c^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}(c_1)`.

   #. Return :math:`{c^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}(c_1)`.

#. Return :math:`{c^\ast}`.


:math:`{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}({\mathit{vcvtop}}, v_1)`
.......................................................................................................................................


1. If :math:`{M'} = {M''}` and :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}, {\mathit{vcvtop}})` is not defined and :math:`{\mathrm{zeroop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}, {\mathit{vcvtop}})` is not defined, then:

   a. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M''}}}(v_1)`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M''}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. If :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}, {\mathit{vcvtop}})` is defined, then:

   a. Let :math:`{\mathit{half}}` be :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}, {\mathit{vcvtop}})`.

   #. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}}(v_1){}[{\mathrm{half}}({\mathit{half}}, 0, {M''}) : {M''}]`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. Assert: Due to validation, :math:`{\mathrm{zeroop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}, {\mathit{vcvtop}}) = \mathsf{zero}`.

#. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}({\mathit{vcvtop}}, c_1)^\ast}~{0^{{M'}}}`.

#. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M''}}}^{{-1}}}}{({c^\ast})}^\ast}`.

#. Return :math:`v`.


:math:`{{\mathit{vshiftop}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{(v, i)}`
............................................................................


1. If :math:`{\mathit{vshiftop}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishl}}, v, i)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}` is some :math:`\mathsf{shr}` :math:`{\mathit{sx}}`.

#. Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vshiftop}}`.

#. Return :math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishr}}, {\mathit{sx}}, v, i)`.


:math:`{\mathsf{vbitmask}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
.....................................................................


1. Return :math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)`.


:math:`{{\mathit{vswizzlop}}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................


1. If :math:`{\mathit{vswizzlop}} = \mathsf{swizzle}`, then:

   a. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{iswizzle}}_{{\mathit{lane}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vswizzlop}} = \mathsf{relaxed\_swizzle}`.

#. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}, v_1, v_2)`.


:math:`{\mathsf{vshuffle}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)}`
.................................................................................................


1. Return :math:`{{\mathrm{ivshufflop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`.


:math:`{\mathsf{vnarrow}}{{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{\mathit{sx}}}}}{(v_1, v_2)}`
.............................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_1}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_2}^\ast}`.

#. Let :math:`v` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{c'}_1^\ast}~{{c'}_2^\ast})}`.

#. Return :math:`v`.


:math:`{{\mathrm{ivadd\_pairwise}}}_{N}({i^\ast})`
..................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{i^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}, v_1)`
.................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{{\mathit{sx}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1)}`
...........................................................................................................................................................


1. Return :math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivadd}}_{{\mathit{pairwise}}}, {\mathit{sx}}, v_1)`.


:math:`{{\mathrm{ivdot}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivdot\_sat}}}_{N}({i_1^\ast}, {i_2^\ast})`
...........................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{iadd\_sat}}}_{N}^{\mathsf{s}}}}{(j_1, j_2)}^\ast}`.


:math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}_1, {\mathit{sx}}_2, i, k, v_1, v_2)`
................................................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[i : k]`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2){}[i : k]`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_1}}}{(c_1)}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_2}}}{(c_2)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast}, {{c'}_2^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivmul}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Return :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.


:math:`{{\mathit{vextbinop}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1, v_2)}`
.............................................................................................................................


1. If :math:`{\mathit{vextbinop}}` is some :math:`\mathsf{extmul}` :math:`{\mathit{half}}` :math:`{\mathit{sx}}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vextbinop}}`.

   #. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivmul}}, {\mathit{sx}}, {\mathit{sx}}, {\mathrm{half}}({\mathit{half}}, 0, M_2), M_2, v_1, v_2)`.

#. If :math:`{\mathit{vextbinop}} = `, then:

   a. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}, \mathsf{s}, \mathsf{s}, 0, M_1, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}} = `.

#. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}_{{\mathit{sat}}}, \mathsf{s}, {{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{idot}})}{{}[ \mathsf{s}, \mathsf{u} ]}, 0, M_1, v_1, v_2)`.


:math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1, c_2, c_3)}`
..............................................................................................................


1. Let :math:`M` be :math:`2 \, M_2`.

#. Assert: Due to validation, :math:`N` for which :math:`N` :math:`=` :math:`2 \cdot N_1` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`2 \cdot N_1`.

#. Let :math:`{c'}` be :math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1, c_2)}`.

#. Let :math:`{c''}` be :math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{\mathsf{s}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c'})}`.

#. Let :math:`c` be an element of :math:`{\mathsf{add}}{{}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c''}, c_3)}`.

#. Return :math:`c`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}}({\mathit{val}'})`
...................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathit{val}'}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Assert: Due to validation, :math:`{\mathit{val}'}` is some :math:`\mathsf{const}` :math:`{\mathit{numtype}}` :math:`{{\mathit{num}}}_{{\mathit{numtype}}}`.

#. Let :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` be the destructuring of :math:`{\mathit{val}'}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = \mathsf{i{\scriptstyle 32}}`.

#. Return :math:`({\mathit{storagetype}}{.}\mathsf{pack}~{{\mathrm{wrap}}}_{32, {|{\mathit{storagetype}}|}}(i))`.


:math:`{{{{\mathrm{unpack}}}_{{\mathit{storagetype}}}^{{{\mathit{sx}'}^?}}}}{({\mathit{fieldval}})}`
....................................................................................................


1. If :math:`{\mathit{storagetype}}` is value type and :math:`{\mathit{fieldval}}` is value and :math:`{{\mathit{sx}'}^?}` is not defined, then:

   a. Return :math:`{\mathit{fieldval}}`.

#. Assert: Due to validation, :math:`{\mathit{fieldval}}` is some :math:`\mathsf{pack}` :math:`{\mathit{packtype}}` :math:`{i}{N}`.

#. Let :math:`({\mathit{packtype}}{.}\mathsf{pack}~i)` be the destructuring of :math:`{\mathit{fieldval}}`.

#. Assert: Due to validation, :math:`{{\mathit{sx}'}^?}` is defined.

#. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}} = {\mathit{packtype}}`.

#. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, 32}^{{\mathit{sx}}}}}{(i)})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}` :math:`{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}` :math:`{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{globals}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}` :math:`{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tables}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}` :math:`{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{mems}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{tag}` :math:`{\mathit{tagaddr}}`, then:

   a. Let :math:`(\mathsf{tag}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tags}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xa}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`s{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{structs}`
.................................


1. Return :math:`s{.}\mathsf{structs}`.


:math:`(s, f){.}\mathsf{arrays}`
................................


1. Return :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){.}\mathsf{exns}`
..............................


1. Return :math:`s{.}\mathsf{exns}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{tags}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{tags}{}[f{.}\mathsf{module}{.}\mathsf{tags}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
.................................................................................


1. Replace :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
................................................................................


1. Replace :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {{\mathit{si}}^\ast}]`
................................................................................


1. Append :math:`{{\mathit{si}}^\ast}` to :math:`s{.}\mathsf{structs}`.


:math:`(s, f){}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {{\mathit{ai}}^\ast}]`
...............................................................................


1. Append :math:`{{\mathit{ai}}^\ast}` to :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {{\mathit{exn}}^\ast}]`
..............................................................................


1. Append :math:`{{\mathit{exn}}^\ast}` to :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{growtable}}({\mathit{tableinst}}, n, r)`
........................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ i .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{tableinst}}`.

#. If :math:`{|{{r'}^\ast}|} + n > j`, then:

   a. Fail.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. Let :math:`{\mathit{tableinst}'}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ {i'} .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

#. Return :math:`{\mathit{tableinst}'}`.


:math:`{\mathrm{growmem}}({\mathit{meminst}}, n)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ i .. j ]~\mathsf{page}),\; \mathsf{bytes}~{b^\ast} \}\end{array}` be the destructuring of :math:`{\mathit{meminst}}`.

#. If :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n > j`, then:

   a. Fail.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. Let :math:`{\mathit{meminst}'}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ {i'} .. j ]~\mathsf{page}),\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Return :math:`{\mathit{meminst}'}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}(t)`
....................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{rt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{gt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{tt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{mt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}})`
........................................................


1. If :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`x` be the block type :math:`{\mathit{blocktype}}`.

   #. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

   #. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Return :math:`{\mathit{ft}}`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`.

#. Let :math:`{t^?}` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`\epsilon~\rightarrow~{t^?}`.


:math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}''}^\ast})}`
.................................................................


1. If :math:`{{\mathit{type}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{type}'}^\ast}~{\mathit{type}}` be :math:`{{\mathit{type}''}^\ast}`.

#. Let :math:`(\mathsf{type}~{\mathit{rectype}})` be the destructuring of :math:`{\mathit{type}}`.

#. Let :math:`{{\mathit{deftype}'}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}'}^\ast})}`.

#. Let :math:`x` be the length of :math:`{{\mathit{deftype}'}^\ast}`.

#. Let :math:`{{\mathit{deftype}}^\ast}` be :math:`{{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}}{{}[ {:=}\, {{\mathit{deftype}'}^\ast} ]}`.

#. Return :math:`{{\mathit{deftype}'}^\ast}~{{\mathit{deftype}}^\ast}`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{deftype}}, {\mathit{code}}, {\mathit{moduleinst}})`
...........................................................................................


1. Let :math:`{\mathit{funcinst}}` be the function instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{deftype}},\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{code}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{funcinst}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{deftype}}^\ast}, {{{\mathit{code}}''}^\ast}, {{\mathit{moduleinst}''}^\ast})}`
.................................................................................................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{{\mathit{code}}''}^\ast} = \epsilon`.

   #. Assert: Due to validation, :math:`{{\mathit{moduleinst}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{dt}}~{{\mathit{dt}'}^\ast}` be :math:`{{\mathit{deftype}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{{\mathit{code}}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{code}}~{{{\mathit{code}}'}^\ast}` be :math:`{{{\mathit{code}}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{moduleinst}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{moduleinst}}~{{\mathit{moduleinst}'}^\ast}` be :math:`{{\mathit{moduleinst}''}^\ast}`.

   #. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{dt}}, {\mathit{code}}, {\mathit{moduleinst}})`.

   #. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}'}^\ast}, {{{\mathit{code}}'}^\ast}, {{\mathit{moduleinst}'}^\ast})}`.

   #. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{globalinst}}` be the global instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{globalinst}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})}`
.....................................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})}`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {\mathit{at}}~{}[ i .. j ]~{\mathit{rt}}, {\mathit{ref}})`
..........................................................................................


1. Let :math:`{\mathit{tableinst}}` be the table instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ i .. j ]~{\mathit{rt}}),\; \mathsf{refs}~{{\mathit{ref}}^{i}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{tableinst}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}''}^\ast}, {{\mathit{ref}''}^\ast})}`
...................................................................................................


1. If :math:`{{\mathit{tabletype}''}^\ast} = \epsilon` and :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{ref}''}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ref}}~{{\mathit{ref}'}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tabletype}''}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}}, {\mathit{ref}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}'}^\ast}, {{\mathit{ref}'}^\ast})}`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {\mathit{at}}~{}[ i .. j ]~\mathsf{page})`
........................................................................


1. Let :math:`{\mathit{meminst}}` be the memory instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[ i .. j ]~\mathsf{page}),\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{meminst}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}''}^\ast})}`
......................................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}'}^\ast})}`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`
..................................................


1. Let :math:`{\mathit{taginst}}` be the tag instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{tagtype}} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tags}`.

#. Append :math:`{\mathit{taginst}}` to :math:`s{.}\mathsf{tags}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{tagtype}''}^\ast})}`
......................................................................


1. If :math:`{{\mathit{tagtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tagtype}}~{{\mathit{tagtype}'}^\ast}` be :math:`{{\mathit{tagtype}''}^\ast}`.

#. Let :math:`{\mathit{ja}}` be :math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`.

#. Let :math:`{{\mathit{ja}'}^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{tagtype}'}^\ast})}`.

#. Return :math:`{\mathit{ja}}~{{\mathit{ja}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{elemtype}}, {{\mathit{ref}}^\ast})`
...........................................................................


1. Let :math:`{\mathit{eleminst}}` be the element instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{elemtype}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{elems}`.

#. Append :math:`{\mathit{eleminst}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{elemtype}}^\ast}, {{\mathit{ref}''}^\ast})}`
...............................................................................................


1. If :math:`{{\mathit{elemtype}}^\ast} = \epsilon` and :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{ref}''}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{elemtype}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{elemtype}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, \mathsf{ok}, {{\mathit{byte}}^\ast})`
....................................................................


1. Let :math:`{\mathit{datainst}}` be the data instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{datas}`.

#. Append :math:`{\mathit{datainst}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{datatype}}^\ast}, {{\mathit{byte}}^\ast})}`
..............................................................................................


1. If :math:`{{\mathit{datatype}}^\ast} = \epsilon` and :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{byte}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{datatype}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ok}}~{{\mathit{ok}'}^\ast}` be :math:`{{\mathit{datatype}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {\mathit{ok}}, {b^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}'}^\ast}, {{{b'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}` :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}` :math:`{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{\mathit{moduleinst}}{.}\mathsf{globals}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}` :math:`{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{\mathit{moduleinst}}{.}\mathsf{tables}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}` :math:`{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{\mathit{moduleinst}}{.}\mathsf{mems}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}` is some :math:`\mathsf{tag}` :math:`{\mathit{tagidx}}`.

#. Let :math:`(\mathsf{tag}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{tag}~{\mathit{moduleinst}}{.}\mathsf{tags}{}[x]) \}\end{array}`.


:math:`{{{\mathrm{allocexport}}^\ast}}{({\mathit{moduleinst}}, {{\mathit{export}}^\ast})}`
..........................................................................................


1. Return :math:`{{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})^\ast}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`
.....................................................................................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{fa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{aa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tags}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}` for all :math:`i_{\mathsf{f}}` from :math:`0` to :math:`{|{{\mathit{func}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{|s{.}\mathsf{globals}|} + i_{\mathsf{g}}` for all :math:`i_{\mathsf{g}}` from :math:`0` to :math:`{|{{\mathit{global}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{|s{.}\mathsf{tables}|} + i_{\mathsf{t}}` for all :math:`i_{\mathsf{t}}` from :math:`0` to :math:`{|{{\mathit{table}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{aa}}^\ast}` be :math:`{|s{.}\mathsf{tags}|} + i_{\mathsf{a}}` for all :math:`i_{\mathsf{a}}` from :math:`0` to :math:`{|{{\mathit{tag}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{|s{.}\mathsf{mems}|} + i_{\mathsf{m}}` for all :math:`i_{\mathsf{m}}` from :math:`0` to :math:`{|{{\mathit{mem}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{|s{.}\mathsf{elems}|} + i_{\mathsf{e}}` for all :math:`i_{\mathsf{e}}` from :math:`0` to :math:`{|{{\mathit{elem}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{|s{.}\mathsf{datas}|} + i_{\mathsf{d}}` for all :math:`i_{\mathsf{d}}` from :math:`0` to :math:`{|{{\mathit{data}}^\ast}|} - 1`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^\ast}` be :math:`{{\mathit{mem}}^\ast}`.

#. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})}`.

#. Let :math:`{(\mathsf{tag}~y)^\ast}` be :math:`{{\mathit{tag}}^\ast}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}` be :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{{\mathrm{allocexport}}^\ast}}{(\{ \begin{array}[t]{@{}l@{}}\mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast} \}\end{array}, {{\mathit{export}}^\ast})}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[x]^\ast}, {(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}, {{\mathit{moduleinst}}^{{|{{\mathit{func}}^\ast}|}}})}`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{{\mathit{globaltype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{{\mathit{tabletype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{{\mathit{memtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{tagaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[y]^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tagaddr}}_0^\ast} = {{\mathit{aa}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{{\mathit{elemtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {\mathsf{ok}^{{|{{\mathit{data}}^\ast}|}}}, {{{\mathit{byte}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{{\mathrm{runelem}}}_{x}(\mathsf{elem}~{\mathit{rt}}~{e^{n}}~{\mathit{elemmode}})`
.........................................................................................


1. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~x)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}` :math:`{\mathit{tableidx}}` :math:`{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{elemmode}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~y~x)~(\mathsf{elem{.}drop}~x)`.


:math:`{{\mathrm{rundata}}}_{x}(\mathsf{data}~{b^{n}}~{\mathit{datamode}})`
...........................................................................


1. If :math:`{\mathit{datamode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}` :math:`{\mathit{memidx}}` :math:`{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{datamode}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~y~x)~(\mathsf{data{.}drop}~x)`.


:math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}''}^\ast})}`
...................................................................................................


1. If :math:`{{\mathit{globaltype}}^\ast} = \epsilon` and :math:`{{\mathit{expr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{expr}''}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{expr}}~{{\mathit{expr}'}^\ast}` be :math:`{{\mathit{expr}''}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{globaltype}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{gt}}~{{\mathit{gt}'}^\ast}` be :math:`{{\mathit{globaltype}}^\ast}`.

#. Let :math:`(s, f)` be the destructuring of :math:`z`.

#. Let :math:`{\mathit{val}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}` with state :math:`z`.

#. Let :math:`a` be :math:`{\mathrm{allocglobal}}(s, {\mathit{gt}}, {\mathit{val}})`.

#. Append :math:`a` to :math:`f{.}\mathsf{module}{.}\mathsf{globals}`.

#. Let :math:`{{\mathit{val}'}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{((s, f), {{\mathit{gt}'}^\ast}, {{\mathit{expr}'}^\ast})}`.

#. Return :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. If :math:`{\mathit{module}}` is not :ref:`valid <valid-val>`, then:

   a. Fail.

#. Let :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast}` be the destructuring of the type of :math:`{\mathit{module}}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. If :math:`{|{{\mathit{externaddr}}^\ast}|} \neq {|{{\mathit{xt}}_{\mathsf{i}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`{\mathit{externaddr}}` in :math:`{{\mathit{externaddr}}^\ast}`, and corresponding :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`:

   a. If :math:`{\mathit{externaddr}}` is not :ref:`valid <valid-val>` with type :math:`{\mathit{xt}}_{\mathsf{i}}`, then:

      1) Fail.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{{\mathrm{rundata}}}_{i_{\mathsf{d}}}({{\mathit{data}}^\ast}{}[i_{\mathsf{d}}])^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{{\mathrm{runelem}}}_{i_{\mathsf{e}}}({{\mathit{elem}}^\ast}{}[i_{\mathsf{e}}])^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{\mathit{moduleinst}}_0` be the module instance :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` be :math:`{(\mathsf{call}~x)^?}`.

#. Let :math:`z` be the state :math:`(s, \{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_0 \}\end{array})`.

#. Let F be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}}_{\mathsf{g}}^\ast})}`.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Let f be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{t}}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Let f be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` F.

#. Let :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` with state :math:`z`.

#. Pop the :math:`\mathsf{frame}` f from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Let F be the :math:`\mathsf{frame}` :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the :math:`\mathsf{frame}` F.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` is defined, then:

   a. Let :math:`{\mathit{instr}}_0` be :math:`{{\mathit{instr}}_{\mathsf{s}}^?}`.

   #. Execute the instruction :math:`{\mathit{instr}}_0`.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{funcaddr}}, {{\mathit{val}}^\ast})`
........................................................................


1. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type}` is some :math:`\mathsf{func}` :math:`{\mathit{functype}}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type}`.

#. Let :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` be the destructuring of :math:`{\mathit{functype}}_0`.

#. If :math:`{|{t_1^\ast}|} \neq {|{{\mathit{val}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`{\mathit{val}}` in :math:`{{\mathit{val}}^\ast}`:

   a. If :math:`{\mathit{val}}` is not :ref:`valid <valid-val>` with type :math:`t_1`, then:

      1) Fail.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let F be the :math:`\mathsf{frame}` :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` F.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~{\mathit{funcaddr}})` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` F from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`{{{\mathrm{allocX}}^\ast}}{(s, {{X''}^\ast}, {{Y''}^\ast})}`
...................................................................


1. If :math:`{{X''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{Y''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`X~{{X'}^\ast}` be :math:`{{X''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{Y''}^\ast}|} \geq 1`.

   #. Let :math:`Y~{{Y'}^\ast}` be :math:`{{Y''}^\ast}`.

   #. Let :math:`a` be :math:`{\mathrm{allocX}}(X, Y, s, X, Y)`.

   #. Let :math:`{{a'}^\ast}` be :math:`{{{\mathrm{allocX}}^\ast}}{(s, {{X'}^\ast}, {{Y'}^\ast})}`.

   #. Return :math:`a~{{a'}^\ast}`.


:math:`X`
.........


1. Return :math:`0`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Expand_use: `%~~_%%`(typeuse, context, comptype)
Numtype_ok
- the number type numtype is always valid.

Vectype_ok
- the vector type vectype is always valid.

Packtype_ok
- the packed type packtype is always valid.

Packtype_sub
- packtype matches only itself.

Numtype_sub
- numtype matches only itself.

Vectype_sub
- vectype matches only itself.

Heaptype_ok
- the heap type heaptype is valid if:
  - Either:
    - heaptype is absheaptype.
  - Or:
    - heaptype is typeuse.
    - the type use typeuse is valid.

Heaptype_ok/abs
- the heap type absheaptype is always valid.

Heaptype_ok/typeuse
- the heap type typeuse is valid if:
  - typeuse is valid.

Reftype_ok
- the reference type (REF NULL? heaptype) is valid if:
  - the heap type heaptype is valid.

Valtype_ok
- the value type valtype is valid if:
  - Either:
    - valtype is numtype.
    - the number type numtype is valid.
  - Or:
    - valtype is vectype.
    - the vector type vectype is valid.
  - Or:
    - valtype is reftype.
    - the reference type reftype is valid.
  - Or:
    - valtype is BOT.

Valtype_ok/num
- the value type numtype is valid if:
  - numtype is valid.

Valtype_ok/vec
- the value type vectype is valid if:
  - vectype is valid.

Valtype_ok/ref
- the value type reftype is valid if:
  - reftype is valid.

Valtype_ok/bot
- the value type BOT is always valid.

Typeuse_ok
- the type use typeuse is valid if:
  - Either:
    - typeuse is (_IDX typeidx).
    - the type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is dt.
  - Or:
    - typeuse is deftype.
    - the defined type deftype is valid.
  - Or:
    - typeuse is (REC i).
    - the recursive type C.RECS[i] exists.
    - C.RECS[i] is st.

Typeuse_ok/typeidx
- the type use (_IDX typeidx) is valid if:
  - the type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is dt.

Typeuse_ok/deftype
- the type use deftype is valid if:
  - deftype is valid.

Typeuse_ok/rec
- the type use (REC i) is valid if:
  - the recursive type C.RECS[i] exists.
  - C.RECS[i] is st.

Resulttype_ok
- the result type t* is valid if:
  - For all t in t*:
    - the value type t is valid.

Fieldtype_ok
- the field type (MUT? storagetype) is valid if:
  - the storage type storagetype is valid.

Storagetype_ok
- the storage type storagetype is valid if:
  - Either:
    - storagetype is valtype.
    - the value type valtype is valid.
  - Or:
    - storagetype is packtype.
    - the packed type packtype is valid.

Storagetype_ok/val
- the storage type valtype is valid if:
  - valtype is valid.

Storagetype_ok/pack
- the storage type packtype is valid if:
  - packtype is valid.

Comptype_ok
- the composite type comptype is valid if:
  - Either:
    - comptype is (STRUCT fieldtype*).
    - For all fieldtype in fieldtype*:
      - the field type fieldtype is valid.
  - Or:
    - comptype is (ARRAY fieldtype).
    - fieldtype is valid.
  - Or:
    - comptype is (FUNC functype).
    - the function type functype is valid.

Comptype_ok/struct
- the composite type (STRUCT fieldtype*) is valid if:
  - For all fieldtype in fieldtype*:
    - the field type fieldtype is valid.

Comptype_ok/array
- the composite type (ARRAY fieldtype) is valid if:
  - the field type fieldtype is valid.

Comptype_ok/func
- the composite type (FUNC functype) is valid if:
  - the function type functype is valid.

Functype_ok
- the function type t_1* -> t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.

Subtype_ok
- the sub type (SUB FINAL? (_IDX x)* comptype) is valid for (OK x_0) if:
  - |x*| is less than or equal to 1.
  - For all x in x*:
    - the index x is less than x_0.
  - |comptype'*| is |x*|.
  - |comptype'*| is |x'**|.
  - For all x in x*:
    - the type C.TYPES[x] exists.
  - For all comptype' in comptype'*, and corresponding x in x*, and corresponding x'* in x'**:
    - the sub type $unrolldt(C.TYPES[x]) is (SUB ?() (_IDX x')* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok
- the recursive type (REC subtype'*) is valid for (OK x) if:
  - Either:
    - the sub type sequence subtype'* is [].
  - Or:
    - subtype'* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid for (OK x).
    - the recursive type (REC subtype*) is valid for (OK (x + 1)).

Rectype_ok/empty
- the recursive type (REC []) is valid for (OK x).

Rectype_ok/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid for (OK x) if:
  - the sub type subtype_1 is valid for (OK x).
  - the recursive type (REC subtype*) is valid for (OK (x + 1)).

Subtype_ok2
- the sub type (SUB FINAL? typeuse* compttype) is valid for (OK x i) if:
  - |typeuse*| is less than or equal to 1.
  - For all typeuse in typeuse*:
    - $before(typeuse, x, i) is true.
  - |comptype'*| is |typeuse*|.
  - |comptype'*| is |typeuse'**|.
  - For all comptype' in comptype'*, and corresponding typeuse in typeuse*, and corresponding typeuse'* in typeuse'**:
    - the sub type $unrollht(C, typeuse) is (SUB ?() typeuse'* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok2
- the recursive type (REC subtype'*) is valid for (OK x i) if:
  - Either:
    - the sub type sequence subtype'* is [].
  - Or:
    - subtype'* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid for (OK x i).
    - the recursive type (REC subtype*) is valid for (OK (x + 1) (i + 1)).

Rectype_ok2/empty
- the recursive type (REC []) is valid for (OK x i).

Rectype_ok2/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid for (OK x i) if:
  - the sub type subtype_1 is valid for (OK x i).
  - the recursive type (REC subtype*) is valid for (OK (x + 1) (i + 1)).

Deftype_ok
- the defined type (DEF rectype i) is valid if:
  - the recursive type rectype is valid for (OK x).
  - rectype is (REC subtype^n).
  - i is less than n.

Comptype_sub
- the composite type comptype matches the composite type comptype' if:
  - Either:
    - comptype is (STRUCT yt_1* :: yt'_1*).
    - comptype' is (STRUCT yt_2*).
    - |yt_1*| is |yt_2*|.
    - For all yt_1 in yt_1*, and corresponding yt_2 in yt_2*:
      - the field type yt_1 matches the field type yt_2.
  - Or:
    - comptype is (ARRAY yt_1).
    - comptype' is (ARRAY yt_2).
    - yt_1 matches yt_2.
  - Or:
    - comptype is (FUNC ft_1).
    - comptype' is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.

Comptype_sub/struct
- the composite type (STRUCT yt_1* :: yt'_1*) matches the composite type (STRUCT yt_2*) if:
  - |yt_1*| is |yt_2*|.
  - For all yt_1 in yt_1*, and corresponding yt_2 in yt_2*:
    - the field type yt_1 matches the field type yt_2.

Comptype_sub/array
- the composite type (ARRAY yt_1) matches the composite type (ARRAY yt_2) if:
  - the field type yt_1 matches the field type yt_2.

Comptype_sub/func
- the composite type (FUNC ft_1) matches the composite type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Deftype_sub
- the defined type deftype_1 matches the defined type deftype_2 if:
  - Either:
    - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).
  - Or:
    - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
    - |typeuse*| is greater than i.
    - the type use typeuse*[i] matches deftype_2.

Deftype_sub/refl
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).

Deftype_sub/super
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
  - |typeuse*| is greater than i.
  - the type use typeuse*[i] matches deftype_2.

Heaptype_sub
- the heap type heaptype'' matches the heap type heaptype''' if:
  - Either:
    - heaptype'' is heaptype.
    - heaptype''' is heaptype.
  - Or:
    - heaptype'' is heaptype_1.
    - heaptype''' is heaptype_2.
    - the heap type heaptype' is valid.
    - the heap type heaptype_1 matches heaptype'.
    - heaptype' matches the heap type heaptype_2.
  - Or:
    - heaptype'' is EQ.
    - heaptype''' is ANY.
  - Or:
    - heaptype'' is I31.
    - heaptype''' is EQ.
  - Or:
    - heaptype'' is STRUCT.
    - heaptype''' is EQ.
  - Or:
    - heaptype'' is ARRAY.
    - heaptype''' is EQ.
  - Or:
    - heaptype'' is deftype.
    - heaptype''' is STRUCT.
    - The :ref:`expansion <aux-expand-deftype>` of the defined type deftype is the composite type (STRUCT fieldtype*).
  - Or:
    - heaptype'' is deftype.
    - heaptype''' is ARRAY.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).
  - Or:
    - heaptype'' is deftype.
    - heaptype''' is FUNC.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).
  - Or:
    - heaptype'' is deftype_1.
    - heaptype''' is deftype_2.
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - heaptype'' is (_IDX typeidx).
    - heaptype''' is heaptype.
    - the type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] matches the heap type heaptype.
  - Or:
    - heaptype'' is heaptype.
    - heaptype''' is (_IDX typeidx).
    - C.TYPES[typeidx] exists.
    - heaptype matches C.TYPES[typeidx].
  - Or:
    - heaptype'' is (REC i).
    - heaptype''' is typeuse*[j].
    - |typeuse*| is greater than j.
    - the recursive type C.RECS[i] exists.
    - C.RECS[i] is (SUB fin typeuse* ct).
  - Or:
    - heaptype'' is NONE.
    - heaptype''' is heaptype.
    - heaptype matches the heap type ANY.
  - Or:
    - heaptype'' is NOFUNC.
    - heaptype''' is heaptype.
    - heaptype matches the heap type FUNC.
  - Or:
    - heaptype'' is NOEXN.
    - heaptype''' is heaptype.
    - heaptype matches the heap type EXN.
  - Or:
    - heaptype'' is NOEXTERN.
    - heaptype''' is heaptype.
    - heaptype matches the heap type EXTERN.
  - Or:
    - heaptype'' is BOT.
    - heaptype''' is heaptype.

Heaptype_sub/refl
- heaptype matches only itself.

Heaptype_sub/trans
- the heap type heaptype_1 matches the heap type heaptype_2 if:
  - the heap type heaptype' is valid.
  - heaptype_1 matches heaptype'.
  - heaptype' matches heaptype_2.

Heaptype_sub/eq
- the heap type EQ matches the heap type ANY.

Heaptype_sub/i31
- the heap type I31 matches EQ.

Heaptype_sub/struct
- the heap type STRUCT matches EQ.

Heaptype_sub/array
- the heap type ARRAY matches EQ.

Heaptype_sub/struct
- the heap type deftype matches the heap type STRUCT if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (STRUCT fieldtype*).

Heaptype_sub/array
- the heap type deftype matches the heap type ARRAY if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).

Heaptype_sub/func
- the heap type deftype matches the heap type FUNC if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Heaptype_sub/def
- the heap type deftype_1 matches the heap type deftype_2 if:
  - deftype_1 matches deftype_2.

Heaptype_sub/typeidx
- the heap type (_IDX typeidx) matches the heap type heaptype if:
  - the type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] matches heaptype.

Heaptype_sub/typeidx
- the heap type heaptype matches the heap type (_IDX typeidx) if:
  - the type C.TYPES[typeidx] exists.
  - heaptype matches C.TYPES[typeidx].

Heaptype_sub/rec
- the heap type (REC i) matches the type use typeuse*[j] if:
  - |typeuse*| is greater than j.
  - the recursive type C.RECS[i] exists.
  - C.RECS[i] is (SUB fin typeuse* ct).

Heaptype_sub/none
- the heap type NONE matches the heap type heaptype if:
  - heaptype matches the heap type ANY.

Heaptype_sub/nofunc
- the heap type NOFUNC matches the heap type heaptype if:
  - heaptype matches the heap type FUNC.

Heaptype_sub/noexn
- the heap type NOEXN matches the heap type heaptype if:
  - heaptype matches the heap type EXN.

Heaptype_sub/noextern
- the heap type NOEXTERN matches the heap type heaptype if:
  - heaptype matches the heap type EXTERN.

Heaptype_sub/bot
- the heap type BOT matches heaptype.

Reftype_sub
- the reference type (REF nul ht_1) matches the reference type (REF nul' ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.
  - Either:
    - nul is ?().
    - nul' is ?().
  - Or:
    - nul is NULL?.
    - nul' is ?(NULL).

Reftype_sub/nonnull
- the reference type (REF ?() ht_1) matches the reference type (REF ?() ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Reftype_sub/null
- the reference type (REF NULL? ht_1) matches the reference type (REF ?(NULL) ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Valtype_sub
- the value type valtype' matches the value type valtype'' if:
  - Either:
    - valtype' is numtype_1.
    - valtype'' is numtype_2.
    - the number type numtype_1 matches the number type numtype_2.
  - Or:
    - valtype' is vectype_1.
    - valtype'' is vectype_2.
    - the vector type vectype_1 matches the vector type vectype_2.
  - Or:
    - valtype' is reftype_1.
    - valtype'' is reftype_2.
    - the reference type reftype_1 matches the reference type reftype_2.
  - Or:
    - valtype' is BOT.
    - valtype'' is valtype.

Valtype_sub/num
- the value type numtype_1 matches the value type numtype_2 if:
  - numtype_1 matches numtype_2.

Valtype_sub/vec
- the value type vectype_1 matches the value type vectype_2 if:
  - vectype_1 matches vectype_2.

Valtype_sub/ref
- the value type reftype_1 matches the value type reftype_2 if:
  - reftype_1 matches reftype_2.

Valtype_sub/bot
- the value type BOT matches the value type valtype.

Resulttype_sub
- the result type t_1* matches the result type t_2* if:
  - |t_1*| is |t_2*|.
  - For all t_1 in t_1*, and corresponding t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Storagetype_sub
- the storage type storagetype matches the storage type storagetype' if:
  - Either:
    - storagetype is valtype_1.
    - storagetype' is valtype_2.
    - the value type valtype_1 matches the value type valtype_2.
  - Or:
    - storagetype is packtype_1.
    - storagetype' is packtype_2.
    - the packed type packtype_1 matches the packed type packtype_2.

Storagetype_sub/val
- the storage type valtype_1 matches the storage type valtype_2 if:
  - valtype_1 matches valtype_2.

Storagetype_sub/pack
- the storage type packtype_1 matches the storage type packtype_2 if:
  - packtype_1 matches packtype_2.

Fieldtype_sub
- the field type (mut zt_1) matches the field type (mut' zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - Either:
    - mut is ?().
    - mut' is ?().
  - Or:
    - mut is ?(MUT).
    - mut' is ?(MUT).
    - zt_2 matches zt_1.

Fieldtype_sub/const
- the field type (?() zt_1) matches the field type (?() zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.

Fieldtype_sub/var
- the field type (?(MUT) zt_1) matches the field type (?(MUT) zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - zt_2 matches zt_1.

Functype_sub
- the function type t_11* -> t_12* matches the function type t_21* -> t_22* if:
  - the result type t_21* matches the result type t_11*.
  - the result type t_12* matches the result type t_22*.

Instrtype_ok
- the instruction type t_1* ->_ x* t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.
  - |lct*| is |x*|.
  - For all x in x*:
    - the local C.LOCALS[x] exists.
  - For all lct in lct*, and corresponding x in x*:
    - C.LOCALS[x] is lct.

Limits_ok
- the limits range ([ n .. m ]) is valid within k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Globaltype_ok
- the global type (MUT? t) is valid if:
  - the value type t is valid.

Tabletype_ok
- the table type (addrtype limits reftype) is valid if:
  - the limits range limits is valid within ((2 ^ 32) - 1).
  - the reference type reftype is valid.

Memtype_ok
- the memory type addrtype limits PAGE is valid if:
  - the limits range limits is valid within (2 ^ 16).

Tagtype_ok
- the tag type deftype is valid if:
  - deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (FUNC typeuse).
    - the type use typeuse is valid.
    - The :ref:`expansion <aux-expand-typeuse>` of the context C is the composite type (FUNC functype).
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.
  - Or:
    - externtype is (TAG typeuse).
    - typeuse is valid.
    - The :ref:`expansion <aux-expand-typeuse>` of C is (FUNC functype).

Externtype_ok/func
- the external type (FUNC typeuse) is valid if:
  - the type use typeuse is valid.
  - The :ref:`expansion <aux-expand-typeuse>` of the context C is the composite type (FUNC functype).

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Externtype_ok/tag
- the external type (TAG typeuse) is valid if:
  - the type use typeuse is valid.
  - The :ref:`expansion <aux-expand-typeuse>` of the context C is the composite type (FUNC functype).

Instrtype_sub
- the instruction type t_11* ->_ x_1* t_12* matches the instruction type t_21* ->_ x_2* t_22* if:
  - the result type t_21* matches the result type t_11*.
  - the result type t_12* matches the result type t_22*.
  - the local index sequence x* is $setminus_(`localidx, x_2*, x_1*).
  - |t*| is |x*|.
  - For all x in x*:
    - the local C.LOCALS[x] exists.
  - For all t in t*, and corresponding x in x*:
    - C.LOCALS[x] is (SET t).

Limits_sub
- the limits range ([ n_1 .. m_1 ]) matches the limits range ([ n_2 .. m_2 ]) if:
  - n_1 is greater than or equal to n_2.
  - m_1 is less than or equal to m_2.

Globaltype_sub
- the global type (mut valtype_1) matches the global type (mut' valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - Either:
    - mut is ?().
    - mut' is ?().
  - Or:
    - mut is ?(MUT).
    - mut' is ?(MUT).
    - valtype_2 matches valtype_1.

Globaltype_sub/const
- the global type (?() valtype_1) matches the global type (?() valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.

Globaltype_sub/var
- the global type (?(MUT) valtype_1) matches the global type (?(MUT) valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - valtype_2 matches valtype_1.

Tabletype_sub
- the table type (addrtype limits_1 reftype_1) matches the table type (addrtype limits_2 reftype_2) if:
  - the limits range limits_1 matches the limits range limits_2.
  - the reference type reftype_1 matches the reference type reftype_2.
  - reftype_2 matches reftype_1.

Memtype_sub
- the memory type addrtype limits_1 PAGE matches the memory type addrtype limits_2 PAGE if:
  - the limits range limits_1 matches the limits range limits_2.

Tagtype_sub
- the tag type deftype_1 matches the tag type deftype_2 if:
  - deftype_1 matches deftype_2.
  - deftype_2 matches deftype_1.

Externtype_sub
- the external type externtype matches the external type externtype' if:
  - Either:
    - externtype is (FUNC deftype_1).
    - externtype' is (FUNC deftype_2).
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - externtype is (GLOBAL globaltype_1).
    - externtype' is (GLOBAL globaltype_2).
    - the global type globaltype_1 matches the global type globaltype_2.
  - Or:
    - externtype is (TABLE tabletype_1).
    - externtype' is (TABLE tabletype_2).
    - the table type tabletype_1 matches the table type tabletype_2.
  - Or:
    - externtype is (MEM memtype_1).
    - externtype' is (MEM memtype_2).
    - the memory type memtype_1 matches the memory type memtype_2.
  - Or:
    - externtype is (TAG tagtype_1).
    - externtype' is (TAG tagtype_2).
    - the tag type tagtype_1 matches the tag type tagtype_2.

Externtype_sub/func
- the external type (FUNC deftype_1) matches the external type (FUNC deftype_2) if:
  - the defined type deftype_1 matches the defined type deftype_2.

Externtype_sub/global
- the external type (GLOBAL globaltype_1) matches the external type (GLOBAL globaltype_2) if:
  - the global type globaltype_1 matches the global type globaltype_2.

Externtype_sub/table
- the external type (TABLE tabletype_1) matches the external type (TABLE tabletype_2) if:
  - the table type tabletype_1 matches the table type tabletype_2.

Externtype_sub/mem
- the external type (MEM memtype_1) matches the external type (MEM memtype_2) if:
  - the memory type memtype_1 matches the memory type memtype_2.

Externtype_sub/tag
- the external type (TAG tagtype_1) matches the external type (TAG tagtype_2) if:
  - the tag type tagtype_1 matches the tag type tagtype_2.

Blocktype_ok
- the block type blocktype is valid as the instruction type valtype'* -> valtype''* if:
  - Either:
    - blocktype is (_RESULT valtype?).
    - the value type sequence valtype'* is [].
    - the value type sequence valtype''* is valtype?.
    - If valtype is defined, then:
      - the value type valtype is valid.
  - Or:
    - blocktype is (_IDX typeidx).
    - valtype'* is t_1*.
    - valtype''* is t_2*.
    - the type C.TYPES[typeidx] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid as the instruction type [] -> valtype? if:
  - If valtype is defined, then:
    - the value type valtype is valid.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid as the instruction type t_1* -> t_2* if:
  - the type C.TYPES[typeidx] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Catch_ok
- the catch clause catch is valid if:
  - the label C.LABELS[l] exists.
  - Either:
    - catch is (CATCH x l).
    - the tag C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
    - the result type t* matches C.LABELS[l].
  - Or:
    - catch is (CATCH_REF x l).
    - C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> []).
    - the result type t* :: [(REF ?() EXN)] matches C.LABELS[l].
  - Or:
    - catch is (CATCH_ALL l).
    - the result type [] matches C.LABELS[l].
  - Or:
    - catch is (CATCH_ALL_REF l).
    - the result type [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch
- the catch clause (CATCH x l) is valid if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the label C.LABELS[l] exists.
  - the result type t* matches C.LABELS[l].

Catch_ok/catch_ref
- the catch clause (CATCH_REF x l) is valid if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the label C.LABELS[l] exists.
  - the result type t* :: [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch_all
- the catch clause (CATCH_ALL l) is valid if:
  - the label C.LABELS[l] exists.
  - the result type [] matches C.LABELS[l].

Catch_ok/catch_all_ref
- the catch clause (CATCH_ALL_REF l) is valid if:
  - the label C.LABELS[l] exists.
  - the result type [(REF ?() EXN)] matches C.LABELS[l].

Defaultable
- the value type t is defaultable if:
  - the value $default_(t) is not ?().

Instr_ok/nop
- the instruction NOP is valid with the instruction type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the instruction type t_1* -> t_2* if:
  - t_1* -> t_2* is valid.

Instr_ok/drop
- the instruction DROP is valid with the instruction type [t] -> [] if:
  - the value type t is valid.

Instr_ok/select
- the instruction (SELECT valtype?) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - Either:
    - the value type sequence valtype? is ?([t]).
  - Or:
    - valtype? is ?().
    - t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid as the instruction type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with the instruction type t_1* ->_ x_1* t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with the instruction type t_1* ->_ x_2* t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the instruction type t* :: [I32] -> t* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the instruction type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the label C.LABELS[l] exists.
  - For all l in l*:
    - the result type t* matches C.LABELS[l].
  - the label C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].
  - t_1* :: t* :: [I32] -> t_2* is valid.

Instr_ok/br_on_null
- the instruction (BR_ON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* :: [(REF ?() ht)] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the heap type ht is valid.

Instr_ok/br_on_non_null
- the instruction (BR_ON_NON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [(REF ?() ht)].

Instr_ok/br_on_cast
- the instruction (BR_ON_CAST l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [t'] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - rt_2 matches the reference type rt.
  - Let t' be the reference type $diffrt(rt_1, rt_2).

Instr_ok/br_on_cast_fail
- the instruction (BR_ON_CAST_FAIL l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [rt_2] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - the reference type $diffrt(rt_1, rt_2) matches the reference type rt.

Instr_ok/call
- the instruction (CALL x) is valid with the instruction type t_1* -> t_2* if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_ref
- the instruction (CALL_REF (_IDX x)) is valid with the instruction type t_1* :: [(REF ?(NULL) (_IDX x))] -> t_2* if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_1* :: [at] -> t_2* if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/return
- the instruction RETURN is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/return_call
- the instruction (RETURN_CALL x) is valid with the instruction type t_3* :: t_1* -> t_4* if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_ref
- the instruction (RETURN_CALL_REF (_IDX x)) is valid with the instruction type t_3* :: t_1* :: [(REF ?(NULL) (_IDX x))] -> t_4* if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_indirect
- the instruction (RETURN_CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_3* :: t_1* :: [at] -> t_4* if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/throw
- the instruction (THROW x) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/throw_ref
- the instruction THROW_REF is valid with the instruction type t_1* :: [(REF ?(NULL) EXN)] -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/try_table
- the instruction (TRY_TABLE bt catch* instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - For all catch in catch*:
    - the catch clause catch is valid.

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the instruction type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the instruction type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the instruction type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the instruction type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the instruction type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the instruction type [nt_2] -> [nt_1].

Instr_ok/ref.null
- the instruction (REF.NULL ht) is valid with the instruction type [] -> [(REF ?(NULL) ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the instruction type [] -> [(REF ?() dt)] if:
  - the function C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.
  - x is contained in C.REFS.

Instr_ok/ref.i31
- the instruction REF.I31 is valid with the instruction type [I32] -> [(REF ?() I31)].

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [I32] if:
  - the heap type ht is valid.

Instr_ok/ref.as_non_null
- the instruction REF.AS_NON_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [(REF ?() ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.eq
- the instruction REF.EQ is valid with the instruction type [(REF ?(NULL) EQ), (REF ?(NULL) EQ)] -> [I32].

Instr_ok/ref.test
- the instruction (REF.TEST rt) is valid with the instruction type [rt'] -> [I32] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/ref.cast
- the instruction (REF.CAST rt) is valid with the instruction type [rt'] -> [rt] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/i31.get
- the instruction (I31.GET sx) is valid with the instruction type [(REF ?(NULL) I31)] -> [I32].

Instr_ok/struct.new
- the instruction (STRUCT.NEW x) is valid with the instruction type t* -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut zt)*).
  - Let t* be the value type sequence $unpack(zt)*.

Instr_ok/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is valid with the instruction type [] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut zt)*).
  - For all zt in zt*:
    - A :ref:`default value <aux-default>` for the value type $unpack(zt) is defined.

Instr_ok/struct.get
- the instruction (STRUCT.GET sx? x i) is valid with the instruction type [(REF ?(NULL) (_IDX x))] -> [t] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (mut zt).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/struct.set
- the instruction (STRUCT.SET x i) is valid with the instruction type [(REF ?(NULL) (_IDX x)), t] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (?(MUT) zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new
- the instruction (ARRAY.NEW x) is valid with the instruction type [t, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is valid with the instruction type [I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - A :ref:`default value <aux-default>` for the value type $unpack(zt) is defined.

Instr_ok/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is valid with the instruction type t^n -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_elem
- the instruction (ARRAY.NEW_ELEM x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut rt)).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] matches the reference type rt.

Instr_ok/array.new_data
- the instruction (ARRAY.NEW_DATA x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/array.get
- the instruction (ARRAY.GET sx? x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32] -> [t] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.set
- the instruction (ARRAY.SET x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.len
- the instruction ARRAY.LEN is valid with the instruction type [(REF ?(NULL) ARRAY)] -> [I32].

Instr_ok/array.fill
- the instruction (ARRAY.FILL x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.copy
- the instruction (ARRAY.COPY x_1 x_2) is valid with the instruction type [(REF ?(NULL) (_IDX x_1)), I32, (REF ?(NULL) (_IDX x_2)), I32, I32] -> [] if:
  - the type C.TYPES[x_1] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_1] is the composite type (ARRAY (?(MUT) zt_1)).
  - the type C.TYPES[x_2] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_2] is the composite type (ARRAY (mut zt_2)).
  - the storage type zt_2 matches the storage type zt_1.

Instr_ok/array.init_elem
- the instruction (ARRAY.INIT_ELEM x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] matches the storage type zt.

Instr_ok/array.init_data
- the instruction (ARRAY.INIT_DATA x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is valid with the instruction type [(REF nul1 ANY)] -> [(REF nul2 EXTERN)] if:
  - nul1 is nul2.

Instr_ok/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is valid with the instruction type [(REF nul1 EXTERN)] -> [(REF nul2 ANY)] if:
  - nul1 is nul2.

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the instruction type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop) is valid with [V128, V128] -> [V128].

Instr_ok/vternop
- the instruction (VTERNOP sh vternop) is valid with [V128, V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop) is valid with the instruction type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzlop
- the instruction (VSWIZZLOP sh vswizzlop) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the instruction type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the instruction type [t] -> [V128] if:
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the instruction type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the instruction type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vextternop
- the instruction (VEXTTERNOP sh_1 sh_2 vextternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the instruction type [] -> [t] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (SET t).

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the instruction type [t] ->_ [x] [] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the instruction type [t] ->_ [x] [t] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the instruction type [] -> [t] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the instruction type [t] -> [] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the instruction type [at] -> [rt] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the instruction type [at, rt] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the instruction type [] -> [at] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the instruction type [rt, at] -> [I32] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the instruction type [at, rt, at] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the table C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (at_1 lim_1 rt_1).
  - the table C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (at_2 lim_2 rt_2).
  - the reference type rt_2 matches the reference type rt_1.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/table.init
- the instruction (TABLE.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt_1).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] is rt_2.
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the instruction type [] -> [] if:
  - the element segment C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction (MEMORY.SIZE x) is valid with the instruction type [] -> [at] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.grow
- the instruction (MEMORY.GROW x) is valid with the instruction type [at] -> [at] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.fill
- the instruction (MEMORY.FILL x) is valid with the instruction type [at, I32, at] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.copy
- the instruction (MEMORY.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the memory C.MEMS[x_1] exists.
  - C.MEMS[x_1] is at_1 lim_1 PAGE.
  - the memory C.MEMS[x_2] exists.
  - C.MEMS[x_2] is at_2 lim_2 PAGE.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/memory.init
- the instruction (MEMORY.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the instruction type [] -> [] if:
  - the data segment C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt' loadop_? x memarg) is valid with the instruction type [at] -> [valtype] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt' is nt.
    - loadop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt' is Inn.
    - loadop_? is ?(M _ sx).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt' storeop_? x memarg) is valid with the instruction type [at, valtype] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt' is nt.
    - storeop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt' is Inn.
    - storeop_? is ?(M).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 vloadop_? x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - vloadop_? is ?().
    - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).
  - Or:
    - vloadop_? is ?((SHAPE M X N _ sx)).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_? is ?((SPLAT N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - Or:
    - vloadop_? is ?((ZERO N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/vstore
- the instruction (VSTORE V128 x memarg) is valid with the instruction type [at, V128] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/load-val
- the instruction (LOAD nt ?() x memarg) is valid with the instruction type [at] -> [nt] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) x memarg) is valid with the instruction type [at] -> [Inn] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() x memarg) is valid with the instruction type [at, nt] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) x memarg) is valid with the instruction type [at, Inn] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload-val
- the instruction (VLOAD V128 ?() x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vload-pack
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instrs_ok
- the instruction sequence instr'* is valid with the instruction type it'' if:
  - Either:
    - instr'* is [].
    - it'' is [] -> [].
  - Or:
    - instr'* is [instr_1] :: instr_2*.
    - it'' is t_1* ->_ x_1* :: x_2* t_3*.
    - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
    - |init*| is |t*|.
    - |init*| is |x_1*|.
    - For all x_1 in x_1*:
      - the local C.LOCALS[x_1] exists.
    - For all init in init*, and corresponding t in t*, and corresponding x_1 in x_1*:
      - C.LOCALS[x_1] is (init t).
    - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.
  - Or:
    - instr'* is instr*.
    - it'' is it'.
    - the instruction sequence instr* is valid with the instruction type it.
    - it matches the instruction type it'.
    - it' is valid.
  - Or:
    - instr'* is instr*.
    - it'' is t* :: t_1* ->_ x* t* :: t_2*.
    - instr* is valid with the instruction type t_1* ->_ x* t_2*.
    - the result type t* is valid.

Instrs_ok/empty
- the instruction sequence [] is valid with the instruction type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the instruction type t_1* ->_ x_1* :: x_2* t_3* if:
  - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
  - |init*| is |t*|.
  - |init*| is |x_1*|.
  - For all x_1 in x_1*:
    - the local C.LOCALS[x_1] exists.
  - For all init in init*, and corresponding t in t*, and corresponding x_1 in x_1*:
    - C.LOCALS[x_1] is (init t).
  - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the instruction type it' if:
  - instr* is valid with the instruction type it.
  - it matches it'.
  - it' is valid.

Instrs_ok/frame
- the instruction sequence instr* is valid with the instruction type t* :: t_1* ->_ x* t* :: t_2* if:
  - instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - the result type t* is valid.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the instruction type [] -> t*.

Nondefaultable
- the value type t is not defaultable if:
  - the value $default_(t) is ?().

Instr_const
- the value val is constant if:
  - Either:
    - val is (nt.CONST c_nt).
  - Or:
    - val is (vt.CONST c_vt).
  - Or:
    - val is (REF.NULL ht).
  - Or:
    - val is REF.I31.
  - Or:
    - val is (REF.FUNC x).
  - Or:
    - val is (STRUCT.NEW x).
  - Or:
    - val is (STRUCT.NEW_DEFAULT x).
  - Or:
    - val is (ARRAY.NEW x).
  - Or:
    - val is (ARRAY.NEW_DEFAULT x).
  - Or:
    - val is (ARRAY.NEW_FIXED x n).
  - Or:
    - val is ANY.CONVERT_EXTERN.
  - Or:
    - val is EXTERN.CONVERT_ANY.
  - Or:
    - val is (GLOBAL.GET x).
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).
  - Or:
    - val is (BINOP Inn binop).
    - Inn is contained in [I32, I64].
    - binop is contained in [ADD, SUB, MUL].

Instr_const/const
- the instruction (nt.CONST c_nt) is constant.

Instr_const/vconst
- the instruction (vt.CONST c_vt) is constant.

Instr_const/ref.null
- the instruction (REF.NULL ht) is constant.

Instr_const/ref.i31
- the instruction REF.I31 is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/struct.new
- the instruction (STRUCT.NEW x) is constant.

Instr_const/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is constant.

Instr_const/array.new
- the instruction (ARRAY.NEW x) is constant.

Instr_const/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is constant.

Instr_const/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is constant.

Instr_const/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is constant.

Instr_const/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Instr_const/binop
- the instruction (BINOP Inn binop) is constant if:
  - Inn is contained in [I32, I64].
  - binop is contained in [ADD, SUB, MUL].

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type definition (TYPE rectype) is valid with the defined type sequence dt* if:
  - |C.TYPES| is x.
  - dt* is $rolldt(x, rectype).
  - the context C' is the context C with .TYPES appended by dt*.
  - Under the context C', the recursive type rectype is valid for (OK x).

Local_ok
- the local (LOCAL t) is valid with the local type (init t) if:
  - Either:
    - the initialization status init is SET.
    - A :ref:`default value <aux-default>` for the value type t is defined.
  - Or:
    - init is UNSET.
    - A :ref:`default value <aux-default>` for t is not defined.

Local_ok/set
- the local (LOCAL t) is valid with the local type (SET t) if:
  - A :ref:`default value <aux-default>` for the value type t is defined.

Local_ok/unset
- the local (LOCAL t) is valid with the local type (UNSET t) if:
  - A :ref:`default value <aux-default>` for the value type t is not defined.

Func_ok
- the function (FUNC x local* expr) is valid with the type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - |lct*| is |local*|.
  - For all lct in lct*, and corresponding local in local*:
    - the local local is valid with the local type lct.
  - Under the context C with .LOCALS appended by (SET t_1)* :: lct* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL globaltype expr) is valid with the global type globaltype if:
  - the global type gt is valid.
  - globaltype is (mut t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tabletype expr) is valid with the table type tabletype if:
  - tabletype is valid.
  - tabletype is (at lim rt).
  - the expression expr is valid with the value type rt.
  - expr is constant.

Mem_ok
- the memory (MEMORY memtype) is valid with the memory type memtype if:
  - memtype is valid.

Tag_ok
- the tag (TAG x) is valid with the type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC functype).

Elemmode_ok
- the element mode elemmode is valid with the element type rt if:
  - Either:
    - elemmode is (ACTIVE x expr).
    - the table C.TABLES[x] exists.
    - C.TABLES[x] is (at lim rt').
    - rt matches the reference type rt'.
    - the expression expr is valid with the value type at.
    - expr is constant.
  - Or:
    - elemmode is PASSIVE.
  - Or:
    - elemmode is DECLARE.

Elemmode_ok/active
- the element mode (ACTIVE x expr) is valid with the element type rt if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt').
  - rt matches the reference type rt'.
  - the expression expr is valid with the value type at.
  - expr is constant.

Elemmode_ok/passive
- the element mode PASSIVE is valid with rt.

Elemmode_ok/declare
- the element mode DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM elemtype expr* elemmode) is valid with the element type elemtype if:
  - elemtype is valid.
  - For all expr in expr*:
    - the expression expr is valid with elemtype.
    - expr is constant.
  - the element mode elemmode is valid with elemtype.

Datamode_ok
- the data mode datamode is valid with the data type OK if:
  - Either:
    - datamode is (ACTIVE x expr).
    - the memory C.MEMS[x] exists.
    - C.MEMS[x] is at lim PAGE.
    - the expression expr is valid with the value type at.
    - expr is constant.
  - Or:
    - datamode is PASSIVE.

Datamode_ok/active
- the data mode (ACTIVE x expr) is valid with the data type OK if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the expression expr is valid with the value type at.
  - expr is constant.

Datamode_ok/passive
- the data mode PASSIVE is valid with OK.

Data_ok
- the memory segment (DATA b* datamode) is valid with the data type OK if:
  - the data mode datamode is valid with OK.

Start_ok
- the start function (START x) is valid if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC [] -> []).

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (FUNC x).
    - externtype is (FUNC dt).
    - the function C.FUNCS[x] exists.
    - C.FUNCS[x] is dt.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory C.MEMS[x] exists.
    - C.MEMS[x] is mt.
  - Or:
    - externidx is (TAG x).
    - externtype is (TAG jt).
    - the tag C.TAGS[x] exists.
    - C.TAGS[x] is jt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC dt) if:
  - the function C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Externidx_ok/tag
- the external index (TAG x) is valid with the external type (TAG jt) if:
  - the tag C.TAGS[x] exists.
  - C.TAGS[x] is jt.

Export_ok
- the export (EXPORT name externidx) is valid with the name name and the external type xt if:
  - the external index externidx is valid with xt.

Globals_ok
- the global sequence global'* is valid with the global type sequence globaltype* if:
  - Either:
    - global'* is [].
    - globaltype* is [].
  - Or:
    - global'* is [global_1] :: global*.
    - globaltype* is [gt_1] :: gt*.
    - the global global_1 is valid with the global type gt_1.
    - the context C' is the context C with .GLOBALS appended by [gt_1].
    - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Globals_ok/empty
- [] is valid with the global type sequence [].

Globals_ok/cons
- the global sequence [global_1] :: global* is valid with the global type sequence [gt_1] :: gt* if:
  - the global global_1 is valid with the global type gt_1.
  - the context C' is the context C with .GLOBALS appended by [gt_1].
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Types_ok
- the type definition sequence type'* is valid with the defined type sequence deftype* if:
  - Either:
    - type'* is [].
    - deftype* is [].
  - Or:
    - type'* is [type_1] :: type*.
    - deftype* is dt_1* :: dt*.
    - the type definition type_1 is valid with the defined type sequence dt_1*.
    - the context C' is the context C with .TYPES appended by dt_1*.
    - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Types_ok/empty
- [] is valid with the defined type sequence [].

Types_ok/cons
- the type definition sequence [type_1] :: type* is valid with the defined type sequence dt_1* :: dt* if:
  - the type definition type_1 is valid with the defined type sequence dt_1*.
  - the context C' is the context C with .TYPES appended by dt_1*.
  - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Module_ok
- the module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) is valid with the module type t if:
  - Under the context { RETURN: ?() }, the type definition sequence type* is valid with the defined type sequence dt'*.
  - |import*| is |xt_I*|.
  - For all import in import*, and corresponding xt_I in xt_I*:
    - Under the context { TYPES: dt'*; RETURN: ?() }, the import import is valid with the external type xt_I.
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.
  - |table*| is |tt*|.
  - For all table in table*, and corresponding tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem*, and corresponding mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |jt*| is |tag*|.
  - For all jt in jt*, and corresponding tag in tag*:
    - Under the context C', the tag tag is valid with the tag type jt.
  - |dt*| is |func*|.
  - For all dt in dt*, and corresponding func in func*:
    - the function func is valid with the defined type dt.
  - |elem*| is |rt*|.
  - For all elem in elem*, and corresponding rt in rt*:
    - the table segment elem is valid with the element type rt.
  - |data*| is |ok*|.
  - For all data in data*, and corresponding ok in ok*:
    - the memory segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |nm*|.
  - |export*| is |xt_E*|.
  - For all export in export*, and corresponding nm in nm*, and corresponding xt_E in xt_E*:
    - the export export is valid with the name nm and the external type xt_E.
  - $disjoint_(`name, nm*) is true.
  - C is C' with .GLOBALS appended by gt* with .TABLES appended by tt_I* :: tt* with .MEMS appended by mt_I* :: mt* with .TAGS appended by jt_I* :: jt* with .ELEMS appended by rt* with .DATAS appended by ok*.
  - the context C' is { TYPES: dt'*; FUNCS: dt_I* :: dt*; GLOBALS: gt_I*; RETURN: ?(); REFS: x* }.
  - the function index sequence x* is $funcidx_nonfuncs((global* table* mem* elem*)).
  - the defined type sequence dt_I* is $funcsxt(xt_I*).
  - the global type sequence gt_I* is $globalsxt(xt_I*).
  - the table type sequence tt_I* is $tablesxt(xt_I*).
  - the memory type sequence mt_I* is $memsxt(xt_I*).
  - the tag type sequence jt_I* is $tagsxt(xt_I*).
  - Let t be the module type $clos_moduletype(C, xt_I* -> xt_E*).

Num_ok
- the number value (nt.CONST c) is valid with the number type nt.

Vec_ok
- the vector value (vt.CONST c) is valid with the vector type vt.

Ref_ok
- the reference value ref' is valid with the reference type rt'' if:
  - Either:
    - ref' is (REF.NULL ht).
    - rt'' is (REF ?(NULL) ht').
    - the heap type ht' matches the heap type ht.
  - Or:
    - ref' is (REF.I31_NUM i).
    - rt'' is (REF ?() I31).
  - Or:
    - ref' is (REF.STRUCT_ADDR a).
    - rt'' is (REF ?() dt).
    - the structure instance s.STRUCTS[a] exists.
    - the defined type s.STRUCTS[a].TYPE is dt.
  - Or:
    - ref' is (REF.ARRAY_ADDR a).
    - rt'' is (REF ?() dt).
    - the array instance s.ARRAYS[a] exists.
    - the defined type s.ARRAYS[a].TYPE is dt.
  - Or:
    - ref' is (REF.FUNC_ADDR a).
    - rt'' is (REF ?() dt).
    - the function instance s.FUNCS[a] exists.
    - the defined type s.FUNCS[a].TYPE is dt.
  - Or:
    - ref' is (REF.EXN_ADDR a).
    - rt'' is (REF ?() EXN).
    - the exception instance s.EXNS[a] exists.
    - s.EXNS[a] is exn.
  - Or:
    - ref' is (REF.HOST_ADDR a).
    - rt'' is (REF ?() ANY).
  - Or:
    - ref' is (REF.EXTERN addrref).
    - rt'' is (REF ?() EXTERN).
    - Under the context s, the reference value addrref is valid with the reference type (REF ?() ANY).
  - Or:
    - ref' is ref.
    - rt'' is rt.
    - Under the context s, the reference value ref is valid with the reference type rt'.
    - rt' matches the reference type rt.

Ref_ok/null
- the reference value (REF.NULL ht) is valid with the reference type (REF ?(NULL) ht') if:
  - the heap type ht' matches the heap type ht.

Ref_ok/i31
- the reference value (REF.I31_NUM i) is valid with the reference type (REF ?() I31).

Ref_ok/struct
- the reference value (REF.STRUCT_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the structure instance s.STRUCTS[a] exists.
  - the defined type s.STRUCTS[a].TYPE is dt.

Ref_ok/array
- the reference value (REF.ARRAY_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the array instance s.ARRAYS[a] exists.
  - the defined type s.ARRAYS[a].TYPE is dt.

Ref_ok/func
- the reference value (REF.FUNC_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the function instance s.FUNCS[a] exists.
  - the defined type s.FUNCS[a].TYPE is dt.

Ref_ok/exn
- the reference value (REF.EXN_ADDR a) is valid with the reference type (REF ?() EXN) if:
  - the exception instance s.EXNS[a] exists.
  - s.EXNS[a] is exn.

Ref_ok/host
- the reference value (REF.HOST_ADDR a) is valid with the reference type (REF ?() ANY).

Ref_ok/extern
- the reference value (REF.EXTERN addrref) is valid with the reference type (REF ?() EXTERN) if:
  - Under the context s, the reference value addrref is valid with the reference type (REF ?() ANY).

Ref_ok/sub
- the reference value ref is valid with the reference type rt if:
  - Under the context s, ref is valid with the reference type rt'.
  - rt' matches rt.

Val_ok
- the value val is valid with the value type valtype if:
  - Either:
    - val is num.
    - valtype is nt.
    - Under the context s, the number value num is valid with the number type nt.
  - Or:
    - val is vec.
    - valtype is vt.
    - Under the context s, the vector value vec is valid with the vector type vt.
  - Or:
    - val is ref.
    - valtype is rt.
    - Under the context s, the reference value ref is valid with the reference type rt.

Val_ok/num
- the value num is valid with the value type nt if:
  - Under the context s, num is valid with nt.

Val_ok/vec
- the value vec is valid with the value type vt if:
  - Under the context s, vec is valid with vt.

Val_ok/ref
- the value ref is valid with the value type rt if:
  - Under the context s, ref is valid with rt.

Externaddr_ok
- the external address externaddr' is valid with the external type externtype if:
  - Either:
    - externaddr' is (FUNC a).
    - externtype is (FUNC funcinst.TYPE).
    - the function instance s.FUNCS[a] exists.
    - s.FUNCS[a] is funcinst.
  - Or:
    - externaddr' is (GLOBAL a).
    - externtype is (GLOBAL globalinst.TYPE).
    - the global instance s.GLOBALS[a] exists.
    - s.GLOBALS[a] is globalinst.
  - Or:
    - externaddr' is (TABLE a).
    - externtype is (TABLE tableinst.TYPE).
    - the table instance s.TABLES[a] exists.
    - s.TABLES[a] is tableinst.
  - Or:
    - externaddr' is (MEM a).
    - externtype is (MEM meminst.TYPE).
    - the memory instance s.MEMS[a] exists.
    - s.MEMS[a] is meminst.
  - Or:
    - externaddr' is (TAG a).
    - externtype is (TAG taginst.TYPE).
    - the tag instance s.TAGS[a] exists.
    - s.TAGS[a] is taginst.
  - Or:
    - externaddr' is externaddr.
    - externtype is xt.
    - Under the context s, the external address externaddr is valid with the external type xt'.
    - xt' matches the external type xt.

Externaddr_ok/func
- the external address (FUNC a) is valid with the external type (FUNC funcinst.TYPE) if:
  - the function instance s.FUNCS[a] exists.
  - s.FUNCS[a] is funcinst.

Externaddr_ok/global
- the external address (GLOBAL a) is valid with the external type (GLOBAL globalinst.TYPE) if:
  - the global instance s.GLOBALS[a] exists.
  - s.GLOBALS[a] is globalinst.

Externaddr_ok/table
- the external address (TABLE a) is valid with the external type (TABLE tableinst.TYPE) if:
  - the table instance s.TABLES[a] exists.
  - s.TABLES[a] is tableinst.

Externaddr_ok/mem
- the external address (MEM a) is valid with the external type (MEM meminst.TYPE) if:
  - the memory instance s.MEMS[a] exists.
  - s.MEMS[a] is meminst.

Externaddr_ok/tag
- the external address (TAG a) is valid with the external type (TAG taginst.TYPE) if:
  - the tag instance s.TAGS[a] exists.
  - s.TAGS[a] is taginst.

Externaddr_ok/sub
- the external address externaddr is valid with the external type xt if:
  - Under the context s, externaddr is valid with the external type xt'.
  - xt' matches xt.

NotationTypingInstrScheme
- the instruction sequence [instr'] is valid with the function type valtype* -> valtype'* if:
  - Either:
    - the instruction instr' is (BINOP I32 ADD).
    - the value type sequence valtype* is [I32, I32].
    - the value type sequence valtype'* is [I32].
  - Or:
    - instr' is (GLOBAL.GET x).
    - valtype* is [].
    - valtype'* is [t].
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (mut t).
  - Or:
    - instr' is (BLOCK blocktype instr*).
    - valtype* is t_1*.
    - valtype'* is t_2*.
    - the block type blocktype is valid as the instruction type t_1* -> t_2*.
    - the context C' is the context C with .LABELS prepended by [t_2*].
    - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

NotationTypingInstrScheme/i32.add
- the instruction sequence [(BINOP I32 ADD)] is valid with the function type [I32, I32] -> [I32].

NotationTypingInstrScheme/global.get
- the instruction sequence [(GLOBAL.GET x)] is valid with the function type [] -> [t] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

NotationTypingInstrScheme/block
- the instruction sequence [(BLOCK blocktype instr*)] is valid with the function type t_1* -> t_2* if:
  - the block type blocktype is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br l
1. If the first non-value entry of the stack is a LABEL_, then:
  a. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
  b. If (l = 0), then:
    1) Assert: Due to validation, there are at least n values on the top of the stack.
    2) Pop the values val^n from the stack.
    3) Pop all values val'* from the top of the stack.
    4) Pop the label (LABEL_ _ { _ }) from the stack.
    5) Push the values val^n to the stack.
    6) Execute the sequence instr'*.
  c. Else:
    1) Pop all values val* from the top of the stack.
    2) If (l > 0), then:
      a) Pop the label (LABEL_ _ { _ }) from the stack.
      b) Push the values val* to the stack.
      c) Execute the instruction (BR (l - 1)).
2. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the handler (HANDLER_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/br_on_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Execute the instruction (BR l).
4. Else:
  a. Push the value val to the stack.

Step_pure/br_on_non_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Do nothing.
4. Else:
  a. Push the value val to the stack.
  b. Execute the instruction (BR l).

Step_pure/call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (CALL_REF yy).

Step_pure/return_call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (RETURN_CALL_REF yy).

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the handler (HANDLER_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/handler
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
3. Pop the handler (HANDLER_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.i31
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Push the value (REF.I31_NUM $wrap__(32, 31, i)) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/ref.as_non_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Trap.
4. Push the value ref to the stack.

Step_pure/ref.eq
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref_2 from the stack.
3. Assert: Due to validation, a value of value type ref is on the top of the stack.
4. Pop the value ref_1 from the stack.
5. If ref_1 is some REF.NULL, then:
  a. If ref_2 is some REF.NULL, then:
    1) Push the value (I32.CONST 1) to the stack.
  b. Else if (ref_1 = ref_2), then:
    1) Push the value (I32.CONST 1) to the stack.
  c. Else:
    1) Push the value (I32.CONST 0) to the stack.
6. Else if (ref_1 = ref_2), then:
  a. Push the value (I32.CONST 1) to the stack.
7. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/i31.get sx
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Trap.
4. If val is some REF.I31_NUM, then:
  a. Let (REF.I31_NUM i) be val.
  b. Push the value (I32.CONST $extend__(31, 32, sx, i)) to the stack.

Step_pure/array.new x
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the values val^n to the stack.
6. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_pure/extern.convert_any
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Push the value (REF.NULL EXTERN) to the stack.
4. If val is addrref, then:
  a. Push the value (REF.EXTERN val) to the stack.

Step_pure/any.convert_extern
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Push the value (REF.NULL ANY) to the stack.
4. If val is some REF.EXTERN, then:
  a. Let (REF.EXTERN addrref) be val.
  b. Push the value addrref to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Assert: Due to validation, (|$vvunop_(V128, vvunop, c_1)| > 0).
4. Let c be an element of $vvunop_(V128, vvunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (|$vvbinop_(V128, vvbinop, c_1, c_2)| > 0).
6. Let c be an element of $vvbinop_(V128, vvbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Assert: Due to validation, (|$vvternop_(V128, vvternop, c_1, c_2, c_3)| > 0).
8. Let c be an element of $vvternop_(V128, vvternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($vsize(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vternop sh vternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. If (|$vternop_(sh, vternop, c_1, c_2, c_3)| <= 0), then:
  a. Trap.
8. Let c be an element of $vternop_(sh, vternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop sh vtestop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let i be $vtestop_(sh, vtestop, c_1).
4. Push the value (I32.CONST i) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop sh vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshiftop_(sh, vshiftop, c_1, i).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask sh
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vbitmaskop_(sh, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vswizzlop sh swizzlop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vswizzlop_(sh, swizzlop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle sh i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshufflop_(sh, i*, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X M
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Let c be $invlanes_(Lnn X M, $lpacknum_(Lnn, c_1)^M).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype X M sx'? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx'? is not defined /\ (lanetype is numtype /\ (i < |$lanes_(lanetype X M, c_1)|))), then:
  a. Let c_2 be $lanes_(lanetype X M, c_1)[i].
  b. Push the value (lanetype.CONST c_2) to the stack.
4. If (lanetype is packtype /\ sx'? is defined), then:
  a. Let ?(sx) be sx'?.
  b. If (i < |$lanes_(lanetype X M, c_1)|), then:
    1) Let c_2 be $extend__($psize(lanetype), 32, sx, $lanes_(lanetype X M, c_1)[i]).
    2) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X M i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X M, $lanes_(Lnn X M, c_1) with [i] replaced by $lpacknum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_2 sh_1 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_2 sh_1 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vextternop sh_2 sh_1 vextternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vextternop__(sh_1, sh_2, vextternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow sh_2 sh_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vnarrowop__(sh_1, sh_2, sx, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop sh_2 sh_1 vcvtop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vcvtop__(sh_1, sh_2, vcvtop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ m { [(LOOP bt instr*)] }).

Step_read/br_on_cast l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_ok(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Execute the instruction (BR l).
7. Else:
  a. Do nothing.

Step_read/br_on_cast_fail l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_ok(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (CALL_REF $funcinst(z)[a].TYPE).

Step_read/call_ref yy
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val' from the stack.
4. If val' is some REF.NULL, then:
  a. Trap.
5. If val' is some REF.FUNC_ADDR, then:
  a. Let (REF.FUNC_ADDR a) be val'.
  b. If (a < |$funcinst(z)|), then:
    1) Let fi be $funcinst(z)[a].
    2) Assert: Due to validation, fi.CODE is some FUNC.
    3) Let (FUNC x local_0* instr*) be fi.CODE.
    4) Let (LOCAL t)* be local_0*.
    5) Assert: Due to validation, $Expand(fi.TYPE) is some FUNC.
    6) Let (FUNC functype_0) be $Expand(fi.TYPE).
    7) Let t_1^n -> t_2^m be functype_0.
    8) Assert: Due to validation, there are at least n values on the top of the stack.
    9) Pop the values val^n from the stack.
    10) Let f be { LOCALS: ?(val)^n :: $default_(t)*; MODULE: fi.MODULE }.
    11) Push the frame (FRAME_ m { f }) to the stack.
    12) Enter instr* with label (LABEL_ m { [] }).

Step_read/return_call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (RETURN_CALL_REF $funcinst(z)[a].TYPE).

Step_read/return_call_ref yy
1. Let z be the current state.
2. If the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the handler (HANDLER_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
4. Else if the first non-value entry of the stack is a FRAME_, then:
  a. Assert: Due to validation, a value is on the top of the stack.
  b. Pop the value val'' from the stack.
  c. If val'' is some REF.NULL, then:
    1) Pop all values val* from the top of the stack.
    2) Pop the frame (FRAME_ _ { _ }) from the stack.
    3) Trap.
  d. If val'' is some REF.FUNC_ADDR, then:
    1) Let (REF.FUNC_ADDR a) be val''.
    2) If (a < |$funcinst(z)|), then:
      a) Assert: Due to validation, $Expand($funcinst(z)[a].TYPE) is some FUNC.
      b) Let (FUNC functype_0) be $Expand($funcinst(z)[a].TYPE).
      c) Let t_1^n -> t_2^m be functype_0.
      d) Assert: Due to validation, there are at least n values on the top of the stack.
      e) Pop the values val^n from the stack.
      f) Pop all values val'* from the top of the stack.
      g) Pop the frame (FRAME_ _ { _ }) from the stack.
      h) Push the values val^n to the stack.
      i) Push the value (REF.FUNC_ADDR a) to the stack.
      j) Execute the instruction (CALL_REF yy).

Step_read/throw_ref
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val' from the stack.
4. If val' is some REF.NULL, then:
  a. Trap.
5. If val' is some REF.EXN_ADDR, then:
  a. Let (REF.EXN_ADDR a) be val'.
  b. Pop all values val* from the top of the stack.
  c. If (val* =/= []), then:
    1) Push the value (REF.EXN_ADDR a) to the stack.
    2) Execute the instruction THROW_REF.
  d. Else if the first non-value entry of the stack is a LABEL_, then:
    1) Pop the label (LABEL_ _ { _ }) from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  e. Else if the first non-value entry of the stack is a FRAME_, then:
    1) Pop the frame (FRAME_ _ { _ }) from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  f. Else if not the first non-value entry of the stack is a HANDLER_, then:
    1) Throw the exception val' as a result.
  g. Else:
    1) Let (HANDLER_ n { catch''* }) be the topmost HANDLER_.
    2) If (catch''* = []), then:
      a) Pop the handler (HANDLER_ _ { _ }) from the stack.
      b) Push the value (REF.EXN_ADDR a) to the stack.
      c) Execute the instruction THROW_REF.
    3) Else if (a >= |$exninst(z)|), then:
      a) Let [catch_0] :: catch'* be catch''*.
      b) If catch_0 is some CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Execute the instruction (BR l).
      c) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch''*.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the handler (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      d) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
    4) Else:
      a) Let val* be $exninst(z)[a].FIELDS.
      b) Let [catch_0] :: catch'* be catch''*.
      c) If catch_0 is some CATCH, then:
        1. Let (CATCH x l) be catch_0.
        2. If ((x < |$tagaddr(z)|) /\ ($exninst(z)[a].TAG = $tagaddr(z)[x])), then:
          a. Pop the handler (HANDLER_ _ { _ }) from the stack.
          b. Push the values val* to the stack.
          c. Execute the instruction (BR l).
        3. Else:
          a. Let [catch] :: catch'* be catch''*.
          b. Pop the handler (HANDLER_ _ { _ }) from the stack.
          c. Push the handler (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
      d) Else if catch_0 is some CATCH_REF, then:
        1. Let (CATCH_REF x l) be catch_0.
        2. If (x >= |$tagaddr(z)|), then:
          a. Let [catch] :: catch'* be catch''*.
          b. Pop the handler (HANDLER_ _ { _ }) from the stack.
          c. Push the handler (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        3. Else if ($exninst(z)[a].TAG =/= $tagaddr(z)[x]), then:
          a. Let [catch] :: catch'* be catch''*.
          b. Pop the handler (HANDLER_ _ { _ }) from the stack.
          c. Push the handler (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        4. Else:
          a. Pop the handler (HANDLER_ _ { _ }) from the stack.
          b. Push the values val* to the stack.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
      e) Else if catch_0 is some CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Execute the instruction (BR l).
      f) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch''*.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the handler (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      g) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
6. Else if (not the first non-value entry of the stack is a LABEL_ /\ (not the first non-value entry of the stack is a FRAME_ /\ not the first non-value entry of the stack is a HANDLER_)), then:
  a. Throw the exception val' as a result.

Step_read/try_table bt catch* instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Push the handler (HANDLER_ n { catch* }) to the stack.
6. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/ref.null (_IDX x)
1. Let z be the current state.
2. Push the value (REF.NULL $type(z, x)) to the stack.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Push the value (REF.FUNC_ADDR $moduleinst(z).FUNCS[x]) to the stack.

Step_read/ref.test rt
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_ok(ref).
5. If rt' matches $inst_reftype(f.MODULE, rt), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_read/ref.cast rt
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_ok(ref).
5. If rt' does not match $inst_reftype(f.MODULE, rt), then:
  a. Trap.
6. Push the value ref to the stack.

Step_read/struct.new_default x
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
3. Let (STRUCT structtype_0) be $Expand($type(z, x)).
4. Let (mut zt)* be structtype_0.
5. Assert: Due to validation, $default_($unpack(zt)) is defined*.
6. Let ?(val)* be $default_($unpack(zt))*.
7. Assert: Due to validation, (|val*| = |zt*|).
8. Push the values val* to the stack.
9. Execute the instruction (STRUCT.NEW x).

Step_read/struct.get sx? x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. If val is some REF.NULL, then:
  a. Trap.
5. If val is some REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be val.
  b. If ((i < |$structinst(z)[a].FIELDS|) /\ (a < |$structinst(z)|)), then:
    1) Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
    2) Let (STRUCT structtype_0) be $Expand($type(z, x)).
    3) Let (mut zt)* be structtype_0.
    4) If (i < |zt*|), then:
      a) Push the value $unpackfield_(zt*[i], sx?, $structinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.new_default x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
5. Let (ARRAY arraytype_0) be $Expand($type(z, x)).
6. Let (mut zt) be arraytype_0.
7. Assert: Due to validation, $default_($unpack(zt)) is defined.
8. Let ?(val) be $default_($unpack(zt)).
9. Push the values val^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
7. Let ref^n be $elem(z, y).REFS[i : n].
8. Push the values ref^n to the stack.
9. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
7. Let (ARRAY arraytype_0) be $Expand($type(z, x)).
8. Let (mut zt) be arraytype_0.
9. If ((i + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
  a. Trap.
10. Let byte** be $concatn__1^-1(`byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)]).
11. Let c^n be $zbytes__1^-1(zt, byte*)*.
12. Push the values $const($cunpack(zt), $cunpacknum_(zt, c))^n to the stack.
13. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.get sx? x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. If val is some REF.NULL, then:
  a. Trap.
7. If val is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((i < |$arrayinst(z)[a].FIELDS|) /\ (a < |$arrayinst(z)|)), then:
    1) Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
    2) Let (ARRAY arraytype_0) be $Expand($type(z, x)).
    3) Let (mut zt) be arraytype_0.
    4) Push the value $unpackfield_(zt, sx?, $arrayinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.len
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. If val is some REF.NULL, then:
  a. Trap.
5. If val is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val.
  b. If (a < |$arrayinst(z)|), then:
    1) Push the value (I32.CONST |$arrayinst(z)[a].FIELDS|) to the stack.

Step_read/array.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val' from the stack.
10. If val' is some REF.NULL, then:
  a. Trap.
11. If val' is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val'.
  b. If (a >= |$arrayinst(z)|), then:
    1) Do nothing.
  c. Else if ((i + n) > |$arrayinst(z)[a].FIELDS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else:
    1) Push the value (REF.ARRAY_ADDR a) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Push the value val to the stack.
    4) Execute the instruction (ARRAY.SET x).
    5) Push the value (REF.ARRAY_ADDR a) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
    7) Push the value val to the stack.
    8) Push the value (I32.CONST (n - 1)) to the stack.
    9) Execute the instruction (ARRAY.FILL x).

Step_read/array.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value val from the stack.
8. Assert: Due to validation, a value of value type I32 is on the top of the stack.
9. Pop the value (I32.CONST i_1) from the stack.
10. Assert: Due to validation, a value is on the top of the stack.
11. Pop the value val' from the stack.
12. If (val' is some REF.NULL /\ val is ref), then:
  a. Trap.
13. If (val is some REF.NULL /\ val' is ref), then:
  a. Trap.
14. If val' is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a_1) be val'.
  b. If val is some REF.ARRAY_ADDR, then:
    1) If ((a_1 < |$arrayinst(z)|) /\ ((i_1 + n) > |$arrayinst(z)[a_1].FIELDS|)), then:
      a) Trap.
    2) Let (REF.ARRAY_ADDR a_2) be val.
    3) If (a_2 >= |$arrayinst(z)|), then:
      a) Do nothing.
    4) Else if ((i_2 + n) > |$arrayinst(z)[a_2].FIELDS|), then:
      a) Trap.
    5) If (n = 0), then:
      a) Do nothing.
    6) Else:
      a) Assert: Due to validation, $Expand($type(z, x_2)) is some ARRAY.
      b) Let (ARRAY arraytype_0) be $Expand($type(z, x_2)).
      c) Let (mut zt_2) be arraytype_0.
      d) Let sx? be $sx(zt_2).
      e) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      f) If (i_1 <= i_2), then:
        1. Push the value (I32.CONST i_1) to the stack.
        2. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        3. Push the value (I32.CONST i_2) to the stack.
        4. Execute the instruction (ARRAY.GET sx? x_2).
        5. Execute the instruction (ARRAY.SET x_1).
        6. Push the value (REF.ARRAY_ADDR a_1) to the stack.
        7. Push the value (I32.CONST (i_1 + 1)) to the stack.
        8. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        9. Push the value (I32.CONST (i_2 + 1)) to the stack.
      g) Else:
        1. Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
        2. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        3. Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
        4. Execute the instruction (ARRAY.GET sx? x_2).
        5. Execute the instruction (ARRAY.SET x_1).
        6. Push the value (REF.ARRAY_ADDR a_1) to the stack.
        7. Push the value (I32.CONST i_1) to the stack.
        8. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        9. Push the value (I32.CONST i_2) to the stack.
      h) Push the value (I32.CONST (n - 1)) to the stack.
      i) Execute the instruction (ARRAY.COPY x_1 x_2).

Step_read/array.init_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val from the stack.
10. If val is some REF.NULL, then:
  a. Trap.
11. If val is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((j + n) > |$elem(z, y).REFS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else if (j < |$elem(z, y).REFS|), then:
    1) Let ref be $elem(z, y).REFS[j].
    2) Push the value (REF.ARRAY_ADDR a) to the stack.
    3) Push the value (I32.CONST i) to the stack.
    4) Push the value ref to the stack.
    5) Execute the instruction (ARRAY.SET x).
    6) Push the value (REF.ARRAY_ADDR a) to the stack.
    7) Push the value (I32.CONST (i + 1)) to the stack.
    8) Push the value (I32.CONST (j + 1)) to the stack.
    9) Push the value (I32.CONST (n - 1)) to the stack.
    10) Execute the instruction (ARRAY.INIT_ELEM x y).

Step_read/array.init_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val from the stack.
10. If val is some REF.NULL, then:
  a. Trap.
11. If val is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If $Expand($type(z, x)) is some ARRAY, then:
    1) Let (ARRAY arraytype_0) be $Expand($type(z, x)).
    2) Let (mut zt) be arraytype_0.
    3) If ((j + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
      a) Trap.
    4) If (n = 0), then:
      a) Do nothing.
    5) Else:
      a) Let c be $zbytes__1^-1(zt, $data(z, y).BYTES[j : ($zsize(zt) / 8)]).
      b) Push the value (REF.ARRAY_ADDR a) to the stack.
      c) Push the value (I32.CONST i) to the stack.
      d) Push the value $const($cunpack(zt), $cunpacknum_(zt, c)) to the stack.
      e) Execute the instruction (ARRAY.SET x).
      f) Push the value (REF.ARRAY_ADDR a) to the stack.
      g) Push the value (I32.CONST (i + 1)) to the stack.
      h) Push the value (I32.CONST (j + ($zsize(zt) / 8))) to the stack.
      i) Push the value (I32.CONST (n - 1)) to the stack.
      j) Execute the instruction (ARRAY.INIT_DATA x y).
  d. Else if (n = 0), then:
    1) Do nothing.

Step_read/local.get x
1. Let z be the current state.
2. Assert: Due to validation, $local(z, x) is defined.
3. Let ?(val) be $local(z, x).
4. Push the value val to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Let val be $global(z, x).VALUE.
3. Push the value val to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let (at lim rt) be $table(z, x).TYPE.
3. Let n be |$table(z, x).REFS|.
4. Push the value (at.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x_1' x_2'
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$table(z, x_1').REFS|), then:
  a. Trap.
9. If ((i_2 + n) > |$table(z, x_2').REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (TABLE.GET x_2').
    4) Execute the instruction (TABLE.SET x_1').
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET x_2').
    4) Execute the instruction (TABLE.SET x_1').
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x_1' x_2').

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$elem(z, y).REFS|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value $elem(z, y).REFS[j] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt' loadop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt') / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  b. Let c be $nbytes__1^-1(nt', $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt') / 8)]).
  c. Push the value (nt'.CONST c) to the stack.
5. If (nt' is Inn /\ loadop_? is defined), then:
  a. Let ?(loadop__0) be loadop_?.
  b. Let n _ sx be loadop__0.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  d. Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
  e. Push the value (nt'.CONST $extend__(n, $size(nt'), sx, c)) to the stack.

Step_read/vload V128 vloadop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|) /\ vloadop_? is not defined), then:
  a. Trap.
5. If vloadop_? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, x).BYTES[(i + ao.OFFSET) : ($vsize(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop__0) be vloadop_?.
  b. If vloadop__0 is some SHAPE, then:
    1) Let (SHAPE M X K _ sx) be vloadop__0.
    2) If (((i + ao.OFFSET) + ((M * K) / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<K).
    4) If $lsizenn^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsizenn^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X K, $extend__(M, $lsizenn(Jnn), sx, j)^K).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop__0 is some SPLAT, then:
    1) Let (SPLAT N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop__0 is some ZERO, then:
    1) Let (ZERO N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be ($vsize(V128) / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size x
1. Let z be the current state.
2. Let at lim PAGE be $mem(z, x).TYPE.
3. Let (n * (64 * $Ki())) be |$mem(z, x).BYTES|.
4. Push the value (at.CONST n) to the stack.

Step_read/memory.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.FILL x).

Step_read/memory.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (MEMORY.COPY x_1 x_2).

Step_read/memory.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$data(z, y).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$data(z, y).BYTES|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value (I32.CONST $data(z, y).BYTES[j]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x y).

Step/throw x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$tagaddr(z)|).
3. Assert: Due to validation, $Expand($tag(z, x).TYPE) is some FUNC.
4. Let (FUNC functype_0) be $Expand($tag(z, x).TYPE).
5. Let t^n -> resulttype_1 be functype_0.
6. Assert: Due to validation, (resulttype_1 = []).
7. Let a be |$exninst(z)|.
8. Assert: Due to validation, there are at least n values on the top of the stack.
9. Pop the values val^n from the stack.
10. Let exn be { TAG: $tagaddr(z)[x]; FIELDS: val^n }.
11. Perform $add_exninst(z, [exn]).
12. Push the value (REF.EXN_ADDR a) to the stack.
13. Execute the instruction THROW_REF.

Step/struct.new x
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
3. Let (STRUCT structtype_0) be $Expand($type(z, x)).
4. Let (mut zt)^n be structtype_0.
5. Let a be |$structinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let si be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.STRUCT_ADDR a) to the stack.
10. Perform $add_structinst(z, [si]).

Step/struct.set x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val' from the stack.
6. If val' is some REF.NULL, then:
  a. Trap.
7. If val' is some REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be val'.
  b. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
  c. Let (STRUCT structtype_0) be $Expand($type(z, x)).
  d. Let (mut zt)* be structtype_0.
  e. If (i < |zt*|), then:
    1) Perform $with_struct(z, a, i, $packfield_(zt*[i], val)).

Step/array.new_fixed x n
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
3. Let (ARRAY arraytype_0) be $Expand($type(z, x)).
4. Let (mut zt) be arraytype_0.
5. Let a be |$arrayinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let ai be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.ARRAY_ADDR a) to the stack.
10. Perform $add_arrayinst(z, [ai]).

Step/array.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value val' from the stack.
8. If val' is some REF.NULL, then:
  a. Trap.
9. If val' is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be val'.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
  d. Let (ARRAY arraytype_0) be $Expand($type(z, x)).
  e. Let (mut zt) be arraytype_0.
  f. Perform $with_array(z, a, i, $packfield_(zt, val)).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (at.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt' storeop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (nt'''.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If ((((i + ao.OFFSET) + ($size(nt''') / 8)) > |$mem(z, x).BYTES|) /\ ((nt' = nt''') /\ storeop_? is not defined)), then:
  a. Trap.
7. If ((nt' = nt''') /\ storeop_? is not defined), then:
  a. Let b* be $nbytes_(nt''', c).
  b. Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt''') / 8), b*).
8. If (nt''' is Inn /\ ((nt' = nt''') /\ storeop_? is defined)), then:
  a. Let ?(n) be storeop_?.
  b. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  c. Let b* be $ibytes_(n, $wrap__($size(nt'''), n, c)).
  d. Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($vsize(V128) / 8), b*).

Step/vstore_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, x, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Either:
  a. Let mi be $growmem($mem(z, x), n).
  b. Push the value (at.CONST (|$mem(z, x).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, x, mi).
5. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

prod n''*
1. If (n''* = []), then:
  a. Return 1.
2. Let [n] :: n'* be n''*.
3. Return (n * $prod(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X*| = 1).
3. Let [w] be X*.
4. Return ?(w).

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

concatn_ `X X* n
1. If (X* = []), then:
  a. Return [].
2. Let [w^n] :: w'^n* be X*.
3. Return w^n :: $concatn_(`X, w'^n*, n).

disjoint_ `X X*
1. If (X* = []), then:
  a. Return true.
2. Let [w] :: w'* be X*.
3. Return (w is not contained in w'* /\ $disjoint_(`X, w'*)).

setminus1_ `X w X*
1. If (X* = []), then:
  a. Return [w].
2. Let [w_1] :: w'* be X*.
3. If (w = w_1), then:
  a. Return [].
4. Return $setminus1_(`X, w, w'*).

setminus_ `X X* w*
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setminus1_(`X, w_1, w*) :: $setminus_(`X, w'*, w*).

setproduct2_ `X w_1 X*
1. If (X* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X*.
3. Return [[w_1] :: w'*] :: $setproduct2_(`X, w_1, w**).

setproduct1_ `X X* w**
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setproduct2_(`X, w_1, w**) :: $setproduct1_(`X, w'*, w**).

setproduct_ `X X*
1. If (X* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X*.
3. Return $setproduct1_(`X, w_1*, $setproduct_(`X, w**)).

signif N
1. If (N = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N = 64).
3. Return 52.

expon N
1. If (N = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fnat N n
1. Return (POS (NORM n 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

cont b
1. Assert: Due to validation, (128 < b).
2. Assert: Due to validation, (b < 192).
3. Return (b - 128).

funcsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some FUNC, then:
  a. Let (FUNC x) be externidx_0.
  b. Return [x] :: $funcsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $funcsxx(xx*).

globalsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx_0.
  b. Return [x] :: $globalsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $globalsxx(xx*).

tablesxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some TABLE, then:
  a. Let (TABLE x) be externidx_0.
  b. Return [x] :: $tablesxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $tablesxx(xx*).

memsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some MEM, then:
  a. Let (MEM x) be externidx_0.
  b. Return [x] :: $memsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $memsxx(xx*).

tagsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some TAG, then:
  a. Let (TAG x) be externidx_0.
  b. Return [x] :: $tagsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $tagsxx(xx*).

free_opt free'?
1. If free'? is not defined, then:
  a. Return {}.
2. Let ?(free) be free'?.
3. Return free.

free_list free''*
1. If (free''* = []), then:
  a. Return {}.
2. Let [free] :: free'* be free''*.
3. Return free ++ $free_list(free'*).

free_typeidx typeidx
1. Return { TYPES: [typeidx] }.

free_funcidx funcidx
1. Return { FUNCS: [funcidx] }.

free_globalidx globalidx
1. Return { GLOBALS: [globalidx] }.

free_tableidx tableidx
1. Return { TABLES: [tableidx] }.

free_memidx memidx
1. Return { MEMS: [memidx] }.

free_elemidx elemidx
1. Return { ELEMS: [elemidx] }.

free_dataidx dataidx
1. Return { DATAS: [dataidx] }.

free_localidx localidx
1. Return { LOCALS: [localidx] }.

free_labelidx labelidx
1. Return { LABELS: [labelidx] }.

free_externidx externidx
1. If externidx is some FUNC, then:
  a. Let (FUNC funcidx) be externidx.
  b. Return $free_funcidx(funcidx).
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL globalidx) be externidx.
  b. Return $free_globalidx(globalidx).
3. If externidx is some TABLE, then:
  a. Let (TABLE tableidx) be externidx.
  b. Return $free_tableidx(tableidx).
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM memidx) be externidx.
6. Return $free_memidx(memidx).

ANYREF
1. Return (REF ?(NULL) ANY).

EQREF
1. Return (REF ?(NULL) EQ).

I31REF
1. Return (REF ?(NULL) I31).

STRUCTREF
1. Return (REF ?(NULL) STRUCT).

ARRAYREF
1. Return (REF ?(NULL) ARRAY).

FUNCREF
1. Return (REF ?(NULL) FUNC).

EXNREF
1. Return (REF ?(NULL) EXN).

EXTERNREF
1. Return (REF ?(NULL) EXTERN).

NULLREF
1. Return (REF ?(NULL) NONE).

NULLFUNCREF
1. Return (REF ?(NULL) NOFUNC).

NULLEXNREF
1. Return (REF ?(NULL) NOEXN).

NULLEXTERNREF
1. Return (REF ?(NULL) NOEXTERN).

IN N
1. If (N = 32), then:
  a. Return I32.
2. Assert: Due to validation, (N = 64).
3. Return I64.

FN N
1. If (N = 32), then:
  a. Return F32.
2. Assert: Due to validation, (N = 64).
3. Return F64.

JN N
1. If (N = 8), then:
  a. Return I8.
2. If (N = 16), then:
  a. Return I16.
3. If (N = 32), then:
  a. Return I32.
4. Assert: Due to validation, (N = 64).
5. Return I64.

size numtype
1. If (numtype = I32), then:
  a. Return 32.
2. If (numtype = I64), then:
  a. Return 64.
3. If (numtype = F32), then:
  a. Return 32.
4. Assert: Due to validation, (numtype = F64).
5. Return 64.

vsize V128
1. Return 128.

psize packtype
1. If (packtype = I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype = I16).
3. Return 16.

lsize lanetype
1. If lanetype is numtype, then:
  a. Return $size(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $psize(lanetype).

zsize storagetype
1. If storagetype is numtype, then:
  a. Return $size(storagetype).
2. If storagetype is vectype, then:
  a. Return $vsize(storagetype).
3. Assert: Due to validation, storagetype is packtype.
4. Return $psize(storagetype).

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

vsizenn vt
1. Return $vsize(vt).

psizenn pt
1. Return $psize(pt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

lunpack lanetype
1. If lanetype is numtype, then:
  a. Return lanetype.
2. Assert: Due to validation, lanetype is packtype.
3. Return I32.

unpack storagetype
1. If storagetype is valtype, then:
  a. Return storagetype.
2. Assert: Due to validation, storagetype is packtype.
3. Return I32.

nunpack storagetype
1. If storagetype is numtype, then:
  a. Return storagetype.
2. If storagetype is packtype, then:
  a. Return I32.
3. Fail.

vunpack vectype
1. Return vectype.

cunpack storagetype
1. If storagetype is consttype, then:
  a. Return storagetype.
2. If storagetype is packtype, then:
  a. Return I32.
3. If storagetype is lanetype, then:
  a. Return $lunpack(storagetype).
4. Fail.

minat at_1 at_2
1. If ($size(at_1) <= $size(at_2)), then:
  a. Return at_1.
2. Return at_2.

diffrt (REF nul1 ht_1) (REF nul ht_2)
1. If (nul = ?(NULL)), then:
  a. Return (REF ?() ht_1).
2. Assert: Due to validation, nul is not defined.
3. Return (REF nul1 ht_1).

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC dt) be externtype_0.
  b. Return [dt] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

tagsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TAG, then:
  a. Let (TAG jt) be externtype_0.
  b. Return [jt] :: $tagsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tagsxt(xt*).

subst_typevar tv typevar* typeuse*
1. If ((typevar* = []) /\ (typeuse* = [])), then:
  a. Return tv.
2. Assert: Due to validation, (|typeuse*| >= 1).
3. Let [tu_1] :: tu'* be typeuse*.
4. Assert: Due to validation, (|typevar*| >= 1).
5. Let [tv_1] :: tv'* be typevar*.
6. If (tv = tv_1), then:
  a. Return tu_1.
7. Return $subst_typevar(tv, tv'*, tu'*).

subst_packtype pt tv* tu*
1. Return pt.

subst_numtype nt tv* tu*
1. Return nt.

subst_vectype vt tv* tu*
1. Return vt.

subst_typeuse typeuse tv* tu*
1. If typeuse is typevar, then:
  a. Return $subst_typevar(typeuse, tv*, tu*).
2. Assert: Due to validation, typeuse is deftype.
3. Return $subst_deftype(typeuse, tv*, tu*).

subst_heaptype heaptype tv* tu*
1. If heaptype is typevar, then:
  a. Return $subst_typevar(heaptype, tv*, tu*).
2. If heaptype is deftype, then:
  a. Return $subst_deftype(heaptype, tv*, tu*).
3. Return heaptype.

subst_reftype (REF nul ht) tv* tu*
1. Return (REF nul $subst_heaptype(ht, tv*, tu*)).

subst_valtype valtype tv* tu*
1. If valtype is numtype, then:
  a. Return $subst_numtype(valtype, tv*, tu*).
2. If valtype is vectype, then:
  a. Return $subst_vectype(valtype, tv*, tu*).
3. If valtype is reftype, then:
  a. Return $subst_reftype(valtype, tv*, tu*).
4. Assert: Due to validation, (valtype = BOT).
5. Return BOT.

subst_storagetype storagetype tv* tu*
1. If storagetype is valtype, then:
  a. Return $subst_valtype(storagetype, tv*, tu*).
2. Assert: Due to validation, storagetype is packtype.
3. Return $subst_packtype(storagetype, tv*, tu*).

subst_fieldtype (mut zt) tv* tu*
1. Return (mut $subst_storagetype(zt, tv*, tu*)).

subst_comptype comptype tv* tu*
1. If comptype is some STRUCT, then:
  a. Let (STRUCT yt*) be comptype.
  b. Return (STRUCT $subst_fieldtype(yt, tv*, tu*)*).
2. If comptype is some ARRAY, then:
  a. Let (ARRAY yt) be comptype.
  b. Return (ARRAY $subst_fieldtype(yt, tv*, tu*)).
3. Assert: Due to validation, comptype is some FUNC.
4. Let (FUNC ft) be comptype.
5. Return (FUNC $subst_functype(ft, tv*, tu*)).

subst_subtype (SUB fin tu'* ct) tv* tu*
1. Return (SUB fin $subst_typeuse(tu', tv*, tu*)* $subst_comptype(ct, tv*, tu*)).

subst_rectype (REC st*) tv* tu*
1. Return (REC $subst_subtype(st, tv*, tu*)*).

subst_deftype (DEF qt i) tv* tu*
1. Return (DEF $subst_rectype(qt, tv*, tu*) i).

subst_functype t_1* -> t_2* tv* tu*
1. Return $subst_valtype(t_1, tv*, tu*)* -> $subst_valtype(t_2, tv*, tu*)*.

subst_addrtype at tv* tu*
1. Return at.

subst_globaltype (mut t) tv* tu*
1. Return (mut $subst_valtype(t, tv*, tu*)).

subst_tabletype (at lim rt) tv* tu*
1. Return (at lim $subst_reftype(rt, tv*, tu*)).

subst_memtype at lim PAGE tv* tu*
1. Return at lim PAGE.

subst_tagtype dt tv* tu*
1. Return $subst_deftype(dt, tv*, tu*).

subst_externtype externtype tv* tu*
1. If externtype is some FUNC, then:
  a. Let (FUNC dt) be externtype.
  b. Return (FUNC $subst_deftype(dt, tv*, tu*)).
2. If externtype is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype.
  b. Return (GLOBAL $subst_globaltype(gt, tv*, tu*)).
3. If externtype is some TABLE, then:
  a. Let (TABLE tt) be externtype.
  b. Return (TABLE $subst_tabletype(tt, tv*, tu*)).
4. If externtype is some MEM, then:
  a. Let (MEM mt) be externtype.
  b. Return (MEM $subst_memtype(mt, tv*, tu*)).
5. Assert: Due to validation, externtype is some TAG.
6. Let (TAG jt) be externtype.
7. Return (TAG $subst_tagtype(jt, tv*, tu*)).

subst_moduletype xt_1* -> xt_2* tv* tu*
1. Return $subst_externtype(xt_1, tv*, tu*)* -> $subst_externtype(xt_2, tv*, tu*)*.

subst_all_valtype t tu^n
1. Return $subst_valtype(t, (_IDX i)^(i<n), tu^n).

subst_all_reftype rt tu^n
1. Return $subst_reftype(rt, (_IDX i)^(i<n), tu^n).

subst_all_deftype dt tu^n
1. Return $subst_deftype(dt, (_IDX i)^(i<n), tu^n).

subst_all_globaltype gt tu^n
1. Return $subst_globaltype(gt, (_IDX i)^(i<n), tu^n).

subst_all_tabletype tt tu^n
1. Return $subst_tabletype(tt, (_IDX i)^(i<n), tu^n).

subst_all_memtype mt tu^n
1. Return $subst_memtype(mt, (_IDX i)^(i<n), tu^n).

subst_all_moduletype mmt tu^n
1. Return $subst_moduletype(mmt, (_IDX i)^(i<n), tu^n).

subst_all_deftypes deftype* tu*
1. If (deftype* = []), then:
  a. Return [].
2. Let [dt_1] :: dt* be deftype*.
3. Return [$subst_all_deftype(dt_1, tu*)] :: $subst_all_deftypes(dt*, tu*).

rollrt x rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (_IDX (x + i))^(i<n), (REC i)^(i<n))^n).

unrollrt rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (REC i)^(i<n), (DEF rectype i)^(i<n))^n).

rolldt x rectype
1. Let (REC subtype^n) be $rollrt(x, rectype).
2. Return (DEF (REC subtype^n) i)^(i<n).

unrolldt (DEF rectype i)
1. Let (REC subtype*) be $unrollrt(rectype).
2. Return subtype*[i].

expanddt deftype
1. Let (SUB fin typeuse* comptype) be $unrolldt(deftype).
2. Return comptype.

free_addrtype addrtype
1. Return {}.

free_numtype numtype
1. Return {}.

free_packtype packtype
1. Return {}.

free_lanetype lanetype
1. If lanetype is numtype, then:
  a. Return $free_numtype(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $free_packtype(lanetype).

free_vectype vectype
1. Return {}.

free_consttype consttype
1. If consttype is numtype, then:
  a. Return $free_numtype(consttype).
2. Assert: Due to validation, consttype is vectype.
3. Return $free_vectype(consttype).

free_absheaptype absheaptype
1. Return {}.

free_typevar typevar
1. If typevar is some _IDX, then:
  a. Let (_IDX typeidx) be typevar.
  b. Return $free_typeidx(typeidx).
2. Assert: Due to validation, typevar is some REC.
3. Return {}.

free_heaptype heaptype
1. If heaptype is absheaptype, then:
  a. Return $free_absheaptype(heaptype).
2. Assert: Due to validation, heaptype is typeuse.
3. Return $free_typeuse(heaptype).

free_reftype (REF nul heaptype)
1. Return $free_heaptype(heaptype).

free_typeuse typeuse
1. If typeuse is typevar, then:
  a. Return $free_typevar(typeuse).
2. Assert: Due to validation, typeuse is deftype.
3. Return $free_deftype(typeuse).

free_valtype valtype
1. If valtype is numtype, then:
  a. Return $free_numtype(valtype).
2. If valtype is vectype, then:
  a. Return $free_vectype(valtype).
3. If valtype is reftype, then:
  a. Return $free_reftype(valtype).
4. Assert: Due to validation, (valtype = BOT).
5. Return {}.

free_resulttype valtype*
1. Return $free_list($free_valtype(valtype)*).

free_storagetype storagetype
1. If storagetype is valtype, then:
  a. Return $free_valtype(storagetype).
2. Assert: Due to validation, storagetype is packtype.
3. Return $free_packtype(storagetype).

free_fieldtype (mut storagetype)
1. Return $free_storagetype(storagetype).

free_structtype fieldtype*
1. Return $free_list($free_fieldtype(fieldtype)*).

free_arraytype fieldtype
1. Return $free_fieldtype(fieldtype).

free_functype resulttype_1 -> resulttype_2
1. Return $free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2).

free_comptype comptype
1. If comptype is some STRUCT, then:
  a. Let (STRUCT structtype) be comptype.
  b. Return $free_structtype(structtype).
2. If comptype is some ARRAY, then:
  a. Let (ARRAY arraytype) be comptype.
  b. Return $free_arraytype(arraytype).
3. Assert: Due to validation, comptype is some FUNC.
4. Let (FUNC functype) be comptype.
5. Return $free_functype(functype).

free_subtype (SUB fin typeuse* comptype)
1. Return $free_list($free_typeuse(typeuse)*) ++ $free_comptype(comptype).

free_rectype (REC subtype*)
1. Return $free_list($free_subtype(subtype)*).

free_deftype (DEF rectype n)
1. Return $free_rectype(rectype).

free_globaltype (mut valtype)
1. Return $free_valtype(valtype).

free_tabletype (addrtype limits reftype)
1. Return $free_addrtype(addrtype) ++ $free_reftype(reftype).

free_memtype addrtype limits PAGE
1. Return $free_addrtype(addrtype).

free_tagtype deftype
1. Return $free_deftype(deftype).

free_elemtype reftype
1. Return $free_reftype(reftype).

free_datatype OK
1. Return {}.

free_externtype externtype
1. If externtype is some FUNC, then:
  a. Let (FUNC typeuse) be externtype.
  b. Return $free_typeuse(typeuse).
2. If externtype is some GLOBAL, then:
  a. Let (GLOBAL globaltype) be externtype.
  b. Return $free_globaltype(globaltype).
3. If externtype is some TABLE, then:
  a. Let (TABLE tabletype) be externtype.
  b. Return $free_tabletype(tabletype).
4. Assert: Due to validation, externtype is some MEM.
5. Let (MEM memtype) be externtype.
6. Return $free_memtype(memtype).

free_moduletype externtype_1* -> externtype_2*
1. Return $free_list($free_externtype(externtype_1)*) ++ $free_list($free_externtype(externtype_2)*).

dim Lnn X N
1. Return N.

lanetype Lnn X N
1. Return Lnn.

unpackshape Lnn X N
1. Return $lunpack(Lnn).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

const consttype c
1. If consttype is numtype, then:
  a. Return (consttype.CONST c).
2. Assert: Due to validation, consttype is vectype.
3. Return (consttype.CONST c).

free_shape lanetype X dim
1. Return $free_lanetype(lanetype).

free_blocktype blocktype
1. If blocktype is some _RESULT, then:
  a. Let (_RESULT valtype?) be blocktype.
  b. Return $free_opt($free_valtype(valtype)?).
2. Assert: Due to validation, blocktype is some _IDX.
3. Let (_IDX funcidx) be blocktype.
4. Return $free_funcidx(funcidx).

shift_labelidxs labelidx''*
1. If (labelidx''* = []), then:
  a. Return [].
2. Let [labelidx_0] :: labelidx'* be labelidx''*.
3. If (labelidx_0 = 0), then:
  a. Return $shift_labelidxs(labelidx'*).
4. Let [labelidx] :: labelidx'* be labelidx''*.
5. Return [(labelidx - 1)] :: $shift_labelidxs(labelidx'*).

free_instr instr'
1. If (instr' = NOP), then:
  a. Return {}.
2. If (instr' = UNREACHABLE), then:
  a. Return {}.
3. If (instr' = DROP), then:
  a. Return {}.
4. If instr' is some SELECT, then:
  a. Let (SELECT valtype*?) be instr'.
  b. Return $free_opt($free_list($free_valtype(valtype)*)?).
5. If instr' is some BLOCK, then:
  a. Let (BLOCK blocktype instr*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
6. If instr' is some LOOP, then:
  a. Let (LOOP blocktype instr*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
7. If instr' is some IF, then:
  a. Let (IF blocktype instr_1* ELSE instr_2*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr_1*) ++ $free_block(instr_2*).
8. If instr' is some BR, then:
  a. Let (BR labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
9. If instr' is some BR_IF, then:
  a. Let (BR_IF labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
10. If instr' is some BR_TABLE, then:
  a. Let (BR_TABLE labelidx* labelidx') be instr'.
  b. Return $free_list($free_labelidx(labelidx)*) ++ $free_labelidx(labelidx).
11. If instr' is some BR_ON_NULL, then:
  a. Let (BR_ON_NULL labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
12. If instr' is some BR_ON_NON_NULL, then:
  a. Let (BR_ON_NON_NULL labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
13. If instr' is some BR_ON_CAST, then:
  a. Let (BR_ON_CAST labelidx reftype_1 reftype_2) be instr'.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
14. If instr' is some BR_ON_CAST_FAIL, then:
  a. Let (BR_ON_CAST_FAIL labelidx reftype_1 reftype_2) be instr'.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
15. If instr' is some CALL, then:
  a. Let (CALL funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
16. If instr' is some CALL_REF, then:
  a. Let (CALL_REF typeuse) be instr'.
  b. Return $free_typeuse(typeuse).
17. If instr' is some CALL_INDIRECT, then:
  a. Let (CALL_INDIRECT tableidx typeuse) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
18. If (instr' = RETURN), then:
  a. Return {}.
19. If instr' is some RETURN_CALL, then:
  a. Let (RETURN_CALL funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
20. If instr' is some RETURN_CALL_REF, then:
  a. Let (RETURN_CALL_REF typeuse) be instr'.
  b. Return $free_typeuse(typeuse).
21. If instr' is some RETURN_CALL_INDIRECT, then:
  a. Let (RETURN_CALL_INDIRECT tableidx typeuse) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
22. If instr' is some CONST, then:
  a. Let (numtype.CONST numlit) be instr'.
  b. Return $free_numtype(numtype).
23. If instr' is some UNOP, then:
  a. Let (UNOP numtype unop) be instr'.
  b. Return $free_numtype(numtype).
24. If instr' is some BINOP, then:
  a. Let (BINOP numtype binop) be instr'.
  b. Return $free_numtype(numtype).
25. If instr' is some TESTOP, then:
  a. Let (TESTOP numtype testop) be instr'.
  b. Return $free_numtype(numtype).
26. If instr' is some RELOP, then:
  a. Let (RELOP numtype relop) be instr'.
  b. Return $free_numtype(numtype).
27. If instr' is some CVTOP, then:
  a. Let (CVTOP numtype_1 numtype_2 cvtop) be instr'.
  b. Return $free_numtype(numtype_1) ++ $free_numtype(numtype_2).
28. If instr' is some VCONST, then:
  a. Let (vectype.CONST veclit) be instr'.
  b. Return $free_vectype(vectype).
29. If instr' is some VVUNOP, then:
  a. Let (VVUNOP vectype vvunop) be instr'.
  b. Return $free_vectype(vectype).
30. If instr' is some VVBINOP, then:
  a. Let (VVBINOP vectype vvbinop) be instr'.
  b. Return $free_vectype(vectype).
31. If instr' is some VVTERNOP, then:
  a. Let (VVTERNOP vectype vvternop) be instr'.
  b. Return $free_vectype(vectype).
32. If instr' is some VVTESTOP, then:
  a. Let (VVTESTOP vectype vvtestop) be instr'.
  b. Return $free_vectype(vectype).
33. If instr' is some VUNOP, then:
  a. Let (VUNOP shape vunop) be instr'.
  b. Return $free_shape(shape).
34. If instr' is some VBINOP, then:
  a. Let (VBINOP shape vbinop) be instr'.
  b. Return $free_shape(shape).
35. If instr' is some VTERNOP, then:
  a. Let (VTERNOP shape vternop) be instr'.
  b. Return $free_shape(shape).
36. If instr' is some VTESTOP, then:
  a. Let (VTESTOP shape vtestop) be instr'.
  b. Return $free_shape(shape).
37. If instr' is some VRELOP, then:
  a. Let (VRELOP shape vrelop) be instr'.
  b. Return $free_shape(shape).
38. If instr' is some VSHIFTOP, then:
  a. Let (VSHIFTOP ishape vshiftop) be instr'.
  b. Return $free_shape(ishape).
39. If instr' is some VBITMASK, then:
  a. Let (VBITMASK ishape) be instr'.
  b. Return $free_shape(ishape).
40. If instr' is some VSWIZZLOP, then:
  a. Let (VSWIZZLOP bshape vswizzlop) be instr'.
  b. Return $free_shape(bshape).
41. If instr' is some VSHUFFLE, then:
  a. Let (VSHUFFLE bshape laneidx*) be instr'.
  b. Return $free_shape(bshape).
42. If instr' is some VEXTUNOP, then:
  a. Let (VEXTUNOP ishape_1 ishape_2 vextunop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
43. If instr' is some VEXTBINOP, then:
  a. Let (VEXTBINOP ishape_1 ishape_2 vextbinop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
44. If instr' is some VEXTTERNOP, then:
  a. Let (VEXTTERNOP ishape_1 ishape_2 vextternop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
45. If instr' is some VNARROW, then:
  a. Let (VNARROW ishape_1 ishape_2 sx) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
46. If instr' is some VCVTOP, then:
  a. Let (VCVTOP shape_1 shape_2 vcvtop) be instr'.
  b. Return $free_shape(shape_1) ++ $free_shape(shape_2).
47. If instr' is some VSPLAT, then:
  a. Let (VSPLAT shape) be instr'.
  b. Return $free_shape(shape).
48. If instr' is some VEXTRACT_LANE, then:
  a. Let (VEXTRACT_LANE shape sx? laneidx) be instr'.
  b. Return $free_shape(shape).
49. If instr' is some VREPLACE_LANE, then:
  a. Let (VREPLACE_LANE shape laneidx) be instr'.
  b. Return $free_shape(shape).
50. If instr' is some REF.NULL, then:
  a. Let (REF.NULL heaptype) be instr'.
  b. Return $free_heaptype(heaptype).
51. If (instr' = REF.IS_NULL), then:
  a. Return {}.
52. If (instr' = REF.AS_NON_NULL), then:
  a. Return {}.
53. If (instr' = REF.EQ), then:
  a. Return {}.
54. If instr' is some REF.TEST, then:
  a. Let (REF.TEST reftype) be instr'.
  b. Return $free_reftype(reftype).
55. If instr' is some REF.CAST, then:
  a. Let (REF.CAST reftype) be instr'.
  b. Return $free_reftype(reftype).
56. If instr' is some REF.FUNC, then:
  a. Let (REF.FUNC funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
57. If (instr' = REF.I31), then:
  a. Return {}.
58. If instr' is some I31.GET, then:
  a. Return {}.
59. If instr' is some STRUCT.NEW, then:
  a. Return {}.
60. If instr' is some STRUCT.NEW_DEFAULT, then:
  a. Let (STRUCT.NEW_DEFAULT typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
61. If instr' is some STRUCT.GET, then:
  a. Let (STRUCT.GET sx? typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
62. If instr' is some STRUCT.SET, then:
  a. Let (STRUCT.SET typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
63. If instr' is some ARRAY.NEW, then:
  a. Let (ARRAY.NEW typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
64. If instr' is some ARRAY.NEW_DEFAULT, then:
  a. Let (ARRAY.NEW_DEFAULT typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
65. If instr' is some ARRAY.NEW_FIXED, then:
  a. Let (ARRAY.NEW_FIXED typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
66. If instr' is some ARRAY.NEW_DATA, then:
  a. Let (ARRAY.NEW_DATA typeidx dataidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
67. If instr' is some ARRAY.NEW_ELEM, then:
  a. Let (ARRAY.NEW_ELEM typeidx elemidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
68. If instr' is some ARRAY.GET, then:
  a. Let (ARRAY.GET sx? typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
69. If instr' is some ARRAY.SET, then:
  a. Let (ARRAY.SET typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
70. If (instr' = ARRAY.LEN), then:
  a. Return {}.
71. If instr' is some ARRAY.FILL, then:
  a. Let (ARRAY.FILL typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
72. If instr' is some ARRAY.COPY, then:
  a. Let (ARRAY.COPY typeidx_1 typeidx_2) be instr'.
  b. Return $free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2).
73. If instr' is some ARRAY.INIT_DATA, then:
  a. Let (ARRAY.INIT_DATA typeidx dataidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
74. If instr' is some ARRAY.INIT_ELEM, then:
  a. Let (ARRAY.INIT_ELEM typeidx elemidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
75. If (instr' = EXTERN.CONVERT_ANY), then:
  a. Return {}.
76. If (instr' = ANY.CONVERT_EXTERN), then:
  a. Return {}.
77. If instr' is some LOCAL.GET, then:
  a. Let (LOCAL.GET localidx) be instr'.
  b. Return $free_localidx(localidx).
78. If instr' is some LOCAL.SET, then:
  a. Let (LOCAL.SET localidx) be instr'.
  b. Return $free_localidx(localidx).
79. If instr' is some LOCAL.TEE, then:
  a. Let (LOCAL.TEE localidx) be instr'.
  b. Return $free_localidx(localidx).
80. If instr' is some GLOBAL.GET, then:
  a. Let (GLOBAL.GET globalidx) be instr'.
  b. Return $free_globalidx(globalidx).
81. If instr' is some GLOBAL.SET, then:
  a. Let (GLOBAL.SET globalidx) be instr'.
  b. Return $free_globalidx(globalidx).
82. If instr' is some TABLE.GET, then:
  a. Let (TABLE.GET tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
83. If instr' is some TABLE.SET, then:
  a. Let (TABLE.SET tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
84. If instr' is some TABLE.SIZE, then:
  a. Let (TABLE.SIZE tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
85. If instr' is some TABLE.GROW, then:
  a. Let (TABLE.GROW tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
86. If instr' is some TABLE.FILL, then:
  a. Let (TABLE.FILL tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
87. If instr' is some TABLE.COPY, then:
  a. Let (TABLE.COPY tableidx_1 tableidx_2) be instr'.
  b. Return $free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2).
88. If instr' is some TABLE.INIT, then:
  a. Let (TABLE.INIT tableidx elemidx) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_elemidx(elemidx).
89. If instr' is some ELEM.DROP, then:
  a. Let (ELEM.DROP elemidx) be instr'.
  b. Return $free_elemidx(elemidx).
90. If instr' is some LOAD, then:
  a. Let (LOAD numtype loadop? memidx memarg) be instr'.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
91. If instr' is some STORE, then:
  a. Let (STORE numtype storeop? memidx memarg) be instr'.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
92. If instr' is some VLOAD, then:
  a. Let (VLOAD vectype vloadop? memidx memarg) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
93. If instr' is some VLOAD_LANE, then:
  a. Let (VLOAD_LANE vectype sz memidx memarg laneidx) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
94. If instr' is some VSTORE, then:
  a. Let (VSTORE vectype memidx memarg) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
95. If instr' is some VSTORE_LANE, then:
  a. Let (VSTORE_LANE vectype sz memidx memarg laneidx) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
96. If instr' is some MEMORY.SIZE, then:
  a. Let (MEMORY.SIZE memidx) be instr'.
  b. Return $free_memidx(memidx).
97. If instr' is some MEMORY.GROW, then:
  a. Let (MEMORY.GROW memidx) be instr'.
  b. Return $free_memidx(memidx).
98. If instr' is some MEMORY.FILL, then:
  a. Let (MEMORY.FILL memidx) be instr'.
  b. Return $free_memidx(memidx).
99. If instr' is some MEMORY.COPY, then:
  a. Let (MEMORY.COPY memidx_1 memidx_2) be instr'.
  b. Return $free_memidx(memidx_1) ++ $free_memidx(memidx_2).
100. If instr' is some MEMORY.INIT, then:
  a. Let (MEMORY.INIT memidx dataidx) be instr'.
  b. Return $free_memidx(memidx) ++ $free_dataidx(dataidx).
101. Assert: Due to validation, instr' is some DATA.DROP.
102. Let (DATA.DROP dataidx) be instr'.
103. Return $free_dataidx(dataidx).

free_block instr*
1. Let free be $free_list($free_instr(instr)*).
2. Return free with .LABELS replaced by $shift_labelidxs(free.LABELS).

free_expr instr*
1. Return $free_list($free_instr(instr)*).

free_type (TYPE rectype)
1. Return $free_rectype(rectype).

free_local (LOCAL t)
1. Return $free_valtype(t).

free_func (FUNC typeidx local* expr)
1. Return $free_typeidx(typeidx) ++ $free_list($free_local(local)*) ++ $free_block(expr) with .LOCALS replaced by [].

free_global (GLOBAL globaltype expr)
1. Return $free_globaltype(globaltype) ++ $free_expr(expr).

free_table (TABLE tabletype expr)
1. Return $free_tabletype(tabletype) ++ $free_expr(expr).

free_mem (MEMORY memtype)
1. Return $free_memtype(memtype).

free_tag (TAG typeidx)
1. Return $free_typeidx(typeidx).

free_elemmode elemmode
1. If elemmode is some ACTIVE, then:
  a. Let (ACTIVE tableidx expr) be elemmode.
  b. Return $free_tableidx(tableidx) ++ $free_expr(expr).
2. If (elemmode = PASSIVE), then:
  a. Return {}.
3. Assert: Due to validation, (elemmode = DECLARE).
4. Return {}.

free_elem (ELEM reftype expr* elemmode)
1. Return $free_reftype(reftype) ++ $free_list($free_expr(expr)*) ++ $free_elemmode(elemmode).

free_datamode datamode
1. If datamode is some ACTIVE, then:
  a. Let (ACTIVE memidx expr) be datamode.
  b. Return $free_memidx(memidx) ++ $free_expr(expr).
2. Assert: Due to validation, (datamode = PASSIVE).
3. Return {}.

free_data (DATA byte* datamode)
1. Return $free_datamode(datamode).

free_start (START funcidx)
1. Return $free_funcidx(funcidx).

free_export (EXPORT name externidx)
1. Return $free_externidx(externidx).

free_import (IMPORT name_1 name_2 externtype)
1. Return $free_externtype(externtype).

free_module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*)
1. Return $free_list($free_type(type)*) ++ $free_list($free_import(import)*) ++ $free_list($free_func(func)*) ++ $free_list($free_global(global)*) ++ $free_list($free_table(table)*) ++ $free_list($free_mem(mem)*) ++ $free_list($free_tag(tag)*) ++ $free_list($free_elem(elem)*) ++ $free_list($free_data(data)*) ++ $free_opt($free_start(start)?) ++ $free_list($free_export(export)*).

funcidx_module module
1. Return $free_module(module).FUNCS.

dataidx_funcs func*
1. Return $free_list($free_func(func)*).DATAS.

with_locals C localidx* localtype*
1. If ((localidx* = []) /\ (localtype* = [])), then:
  a. Return C.
2. Assert: Due to validation, (|localtype*| >= 1).
3. Let [lct_1] :: lct* be localtype*.
4. Assert: Due to validation, (|localidx*| >= 1).
5. Let [x_1] :: x* be localidx*.
6. Return $with_locals(C with .LOCALS[x_1] replaced by lct_1, x*, lct*).

clos_deftypes deftype*
1. If (deftype* = []), then:
  a. Return [].
2. Let dt* :: [dt_n] be deftype*.
3. Let dt'* be $clos_deftypes(dt*).
4. Return dt'* :: [$subst_all_deftype(dt_n, dt'*)].

clos_valtype C t
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_valtype(t, dt*).

clos_deftype C dt
1. Let dt'* be $clos_deftypes(C.TYPES).
2. Return $subst_all_deftype(dt, dt'*).

clos_moduletype C mmt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_moduletype(mmt, dt*).

before typeuse x i
1. If typeuse is deftype, then:
  a. Return true.
2. If typeuse is some _IDX, then:
  a. Let (_IDX typeidx) be typeuse.
  b. Return (typeidx < x).
3. Assert: Due to validation, typeuse is some REC.
4. Let (REC j) be typeuse.
5. Return (j < i).

unrollht C heaptype
1. If heaptype is deftype, then:
  a. Return $unrolldt(heaptype).
2. If heaptype is some _IDX, then:
  a. Let (_IDX typeidx) be heaptype.
  b. Return $unrolldt(C.TYPES[typeidx]).
3. Assert: Due to validation, heaptype is some REC.
4. Let (REC i) be heaptype.
5. Return C.RECS[i].

default_ valtype
1. If valtype is Inn, then:
  a. Return ?((valtype.CONST 0)).
2. If valtype is Fnn, then:
  a. Return ?((valtype.CONST $fzero($size(valtype)))).
3. If valtype is Vnn, then:
  a. Return ?((valtype.CONST 0)).
4. Assert: Due to validation, valtype is some REF.
5. Let (REF NULL_opt_0 ht) be valtype.
6. If (NULL_opt_0 = ?(NULL)), then:
  a. Return ?((REF.NULL ht)).
7. Assert: Due to validation, NULL_opt_0 is not defined.
8. Return ?().

funcidx_nonfuncs (global* table* mem* elem*)
1. Return $funcidx_module((MODULE [] [] [] global* table* mem* [] elem* [] ?() [])).

relaxed2 i `X X_1 X_2
1. If $ND(), then:
  a. Return [X_1, X_2][i].
2. Return [X_1, X_2][0].

relaxed4 i `X X_1 X_2 X_3 X_4
1. If $ND(), then:
  a. Return [X_1, X_2, X_3, X_4][i].
2. Return [X_1, X_2, X_3, X_4][0].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

sx storagetype
1. If storagetype is consttype, then:
  a. Return ?().
2. Assert: Due to validation, storagetype is packtype.
3. Return ?(S).

zero lanetype
1. If lanetype is Jnn, then:
  a. Return 0.
2. Assert: Due to validation, lanetype is Fnn.
3. Return $fzero($size(lanetype)).

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

ineg_ N i_1
1. Return $invsigned_(N, (- $signed_(N, i_1))).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

iextend_ N M sx i
1. If (sx = U), then:
  a. Return (i \ (2 ^ M)).
2. Assert: Due to validation, (sx = S).
3. Return $invsigned_(N, $signed_(M, (i \ (2 ^ M)))).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

iadd_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

lpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $wrap__($size($lunpack(lanetype)), $psize(lanetype), c).

cpacknum_ storagetype c
1. If storagetype is consttype, then:
  a. Return c.
2. Assert: Due to validation, storagetype is packtype.
3. Return $wrap__($size($lunpack(storagetype)), $psize(storagetype), c).

lunpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $extend__($psize(lanetype), $size($lunpack(lanetype)), U, c).

cunpacknum_ storagetype c
1. If storagetype is consttype, then:
  a. Return c.
2. Assert: Due to validation, storagetype is packtype.
3. Return $extend__($psize(storagetype), $size($lunpack(storagetype)), U, c).

unop_ numtype unop_ i'
1. If numtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($sizenn(numtype), i')].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($sizenn(numtype), i')].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(numtype), i')].
  d. Assert: Due to validation, unop_ is some EXTEND.
  e. Let (EXTEND M) be unop_.
  f. Return [$iextend_($sizenn(numtype), M, S, i')].
2. Assert: Due to validation, numtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($sizenn(numtype), i').
4. If (unop_ = NEG), then:
  a. Return $fneg_($sizenn(numtype), i').
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($sizenn(numtype), i').
6. If (unop_ = CEIL), then:
  a. Return $fceil_($sizenn(numtype), i').
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($sizenn(numtype), i').
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($sizenn(numtype), i').
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($sizenn(numtype), i').

binop_ numtype binop_ i_1' i_2'
1. If numtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($sizenn(numtype), i_1', i_2')].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($sizenn(numtype), i_1', i_2')].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($sizenn(numtype), i_1', i_2')].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $idiv_($sizenn(numtype), sx, i_1', i_2').
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $irem_($sizenn(numtype), sx, i_1', i_2').
  f. If (binop_ = AND), then:
    1) Return [$iand_($sizenn(numtype), i_1', i_2')].
  g. If (binop_ = OR), then:
    1) Return [$ior_($sizenn(numtype), i_1', i_2')].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($sizenn(numtype), i_1', i_2')].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($sizenn(numtype), i_1', i_2')].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($sizenn(numtype), sx, i_1', i_2')].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($sizenn(numtype), i_1', i_2')].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($sizenn(numtype), i_1', i_2')].
2. Assert: Due to validation, numtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($sizenn(numtype), i_1', i_2').
4. If (binop_ = SUB), then:
  a. Return $fsub_($sizenn(numtype), i_1', i_2').
5. If (binop_ = MUL), then:
  a. Return $fmul_($sizenn(numtype), i_1', i_2').
6. If (binop_ = DIV), then:
  a. Return $fdiv_($sizenn(numtype), i_1', i_2').
7. If (binop_ = MIN), then:
  a. Return $fmin_($sizenn(numtype), i_1', i_2').
8. If (binop_ = MAX), then:
  a. Return $fmax_($sizenn(numtype), i_1', i_2').
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($sizenn(numtype), i_1', i_2').

testop_ Inn EQZ i
1. Return $ieqz_($sizenn(Inn), i).

relop_ numtype relop_ i_1' i_2'
1. If numtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($sizenn(numtype), i_1', i_2').
  b. If (relop_ = NE), then:
    1) Return $ine_($sizenn(numtype), i_1', i_2').
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($sizenn(numtype), sx, i_1', i_2').
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($sizenn(numtype), sx, i_1', i_2').
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($sizenn(numtype), sx, i_1', i_2').
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($sizenn(numtype), sx, i_1', i_2').
2. Assert: Due to validation, numtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($sizenn(numtype), i_1', i_2').
4. If (relop_ = NE), then:
  a. Return $fne_($sizenn(numtype), i_1', i_2').
5. If (relop_ = LT), then:
  a. Return $flt_($sizenn(numtype), i_1', i_2').
6. If (relop_ = GT), then:
  a. Return $fgt_($sizenn(numtype), i_1', i_2').
7. If (relop_ = LE), then:
  a. Return $fle_($sizenn(numtype), i_1', i_2').
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($sizenn(numtype), i_1', i_2').

cvtop__ numtype numtype'' cvtop__ i_1'
1. If (numtype is Inn /\ numtype'' is Inn), then:
  a. If cvtop__ is some EXTEND, then:
    1) Let (EXTEND sx) be cvtop__.
    2) Return [$extend__($sizenn1(numtype), $sizenn2(numtype''), sx, i_1')].
  b. If (cvtop__ = WRAP), then:
    1) Return [$wrap__($sizenn1(numtype), $sizenn2(numtype''), i_1')].
2. If (numtype is Fnn /\ numtype'' is Inn), then:
  a. If cvtop__ is some TRUNC, then:
    1) Let (TRUNC sx) be cvtop__.
    2) Return $trunc__($sizenn1(numtype), $sizenn2(numtype''), sx, i_1').
  b. If cvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be cvtop__.
    2) Return $trunc_sat__($sizenn1(numtype), $sizenn2(numtype''), sx, i_1').
3. If (numtype is Inn /\ (numtype'' is Fnn /\ cvtop__ is some CONVERT)), then:
  a. Let (CONVERT sx) be cvtop__.
  b. Return [$convert__($sizenn1(numtype), $sizenn2(numtype''), sx, i_1')].
4. If (numtype is Fnn /\ numtype'' is Fnn), then:
  a. If (cvtop__ = PROMOTE), then:
    1) Return $promote__($sizenn1(numtype), $sizenn2(numtype''), i_1').
  b. If (cvtop__ = DEMOTE), then:
    1) Return $demote__($sizenn1(numtype), $sizenn2(numtype''), i_1').
5. If (numtype is Inn /\ (numtype'' is Fnn /\ ((cvtop__ = REINTERPRET) /\ ($size(numtype) = $size(numtype''))))), then:
  a. Return [$reinterpret__(numtype, numtype'', i_1')].
6. Assert: Due to validation, numtype is Fnn.
7. Assert: Due to validation, numtype'' is Inn.
8. Assert: Due to validation, (cvtop__ = REINTERPRET).
9. Assert: Due to validation, ($size(numtype) = $size(numtype'')).
10. Return [$reinterpret__(numtype, numtype'', i_1')].

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

zeroop lanetype'' X M_1 lanetype X M_2 vcvtop__
1. If lanetype'' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Return ?().
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Return ?().
2. Assert: Due to validation, lanetype'' is Fnn.
3. If lanetype is Jnn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx zero?) be vcvtop__.
    2) Return zero?.
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx zero?) be vcvtop__.
    2) Return zero?.
4. Assert: Due to validation, lanetype is Fnn.
5. If vcvtop__ is some DEMOTE, then:
  a. Let (DEMOTE zero) be vcvtop__.
  b. Return ?(zero).
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Return ?().

halfop lanetype'' X M_1 lanetype X M_2 vcvtop__
1. If lanetype'' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop__.
    2) Return ?(half).
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop__.
    2) Return half?.
2. Assert: Due to validation, lanetype'' is Fnn.
3. If lanetype is Jnn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Return ?().
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Return ?().
4. Assert: Due to validation, lanetype is Fnn.
5. If vcvtop__ is some DEMOTE, then:
  a. Return ?().
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Return ?(LOW).

half half i j
1. If (half = LOW), then:
  a. Return i.
2. Assert: Due to validation, (half = HIGH).
3. Return j.

iswizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. Return 0.

irelaxed_swizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. If ($signed_(N, i) < 0), then:
  a. Return 0.
3. Return $relaxed2($R_swizzle(), `iN(N), 0, c*[(i \ |c*|)]).

ivunop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return [$invlanes_(Jnn X M, c*)].

fvunop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1)*).
3. Return $invlanes_(Fnn X M, c*)*.

ivbinop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), sx, c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsxnd_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c** be $setproduct_(`lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), sx, c_1, c_2)*).
4. Return $invlanes_(Jnn X M, c*)*.

fvbinop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2)*).
4. Return $invlanes_(Fnn X M, c*)*.

ivternopnd_ Jnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c_3* be $lanes_(Jnn X M, v_3).
4. Let c** be $setproduct_(`lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Jnn X M, c*)*.

fvternop_ Fnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c_3* be $lanes_(Fnn X M, v_3).
4. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Fnn X M, c*)*.

ivtestop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return $prod(c*).

fvtestop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c* be $f_($sizenn(Fnn), c_1)*.
3. Return $prod(c*).

ivrelop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

ivrelopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), sx, c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

fvrelop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Assert: Due to validation, $size^-1($size(Fnn)) is Inn.
4. Let Inn be $size^-1($size(Fnn)).
5. Let c* be $extend__(1, $sizenn(Fnn), S, $f_($sizenn(Fnn), c_1, c_2))*.
6. Return $invlanes_(Inn X M, c*).

ivshiftop_ Jnn X M $f_ v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivshiftopsx_ Jnn X M $f_ sx v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), sx, c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivbitmaskop_ Jnn X M v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c be $ibits__1^-1(32, $ilt_($lsizenn(Jnn), S, c_1, 0)* :: 0^(32 - M)).
3. Return $irev_(32, c).

ivswizzlop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1*, c_2)*.
4. Return $invlanes_(Jnn X M, c*).

ivshufflop_ Jnn X M i* v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be c_1* :: c_2*[i]*.
4. Return $invlanes_(Jnn X M, c*).

vvunop_ Vnn NOT v
1. Return [$inot_($vsizenn(Vnn), v)].

vvbinop_ Vnn vvbinop v_1 v_2
1. If (vvbinop = AND), then:
  a. Return [$iand_($vsizenn(Vnn), v_1, v_2)].
2. If (vvbinop = ANDNOT), then:
  a. Return [$iandnot_($vsizenn(Vnn), v_1, v_2)].
3. If (vvbinop = OR), then:
  a. Return [$ior_($vsizenn(Vnn), v_1, v_2)].
4. Assert: Due to validation, (vvbinop = XOR).
5. Return [$ixor_($vsizenn(Vnn), v_1, v_2)].

vvternop_ Vnn BITSELECT v_1 v_2 v_3
1. Return [$ibitselect_($vsizenn(Vnn), v_1, v_2, v_3)].

vunop_ lanetype X M vunop_ v
1. If lanetype is Fnn, then:
  a. If (vunop_ = ABS), then:
    1) Return $fvunop_(lanetype X M, $fabs_, v).
  b. If (vunop_ = NEG), then:
    1) Return $fvunop_(lanetype X M, $fneg_, v).
  c. If (vunop_ = SQRT), then:
    1) Return $fvunop_(lanetype X M, $fsqrt_, v).
  d. If (vunop_ = CEIL), then:
    1) Return $fvunop_(lanetype X M, $fceil_, v).
  e. If (vunop_ = FLOOR), then:
    1) Return $fvunop_(lanetype X M, $ffloor_, v).
  f. If (vunop_ = TRUNC), then:
    1) Return $fvunop_(lanetype X M, $ftrunc_, v).
  g. If (vunop_ = NEAREST), then:
    1) Return $fvunop_(lanetype X M, $fnearest_, v).
2. Assert: Due to validation, lanetype is Jnn.
3. If (vunop_ = ABS), then:
  a. Return $ivunop_(lanetype X M, $iabs_, v).
4. If (vunop_ = NEG), then:
  a. Return $ivunop_(lanetype X M, $ineg_, v).
5. Assert: Due to validation, (vunop_ = POPCNT).
6. Return $ivunop_(lanetype X M, $ipopcnt_, v).

vbinop_ lanetype X M vbinop_ v_1 v_2
1. If lanetype is Jnn, then:
  a. If (vbinop_ = ADD), then:
    1) Return $ivbinop_(lanetype X M, $iadd_, v_1, v_2).
  b. If (vbinop_ = SUB), then:
    1) Return $ivbinop_(lanetype X M, $isub_, v_1, v_2).
  c. If (vbinop_ = MUL), then:
    1) Return $ivbinop_(lanetype X M, $imul_, v_1, v_2).
  d. If vbinop_ is some ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $iadd_sat_, sx, v_1, v_2).
  e. If vbinop_ is some SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $isub_sat_, sx, v_1, v_2).
  f. If vbinop_ is some MIN, then:
    1) Let (MIN sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $imin_, sx, v_1, v_2).
  g. If vbinop_ is some MAX, then:
    1) Let (MAX sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $imax_, sx, v_1, v_2).
  h. If (vbinop_ = AVGRU), then:
    1) Return $ivbinopsx_(lanetype X M, $iavgr_, U, v_1, v_2).
  i. If (vbinop_ = Q15MULR_SATS), then:
    1) Return $ivbinopsx_(lanetype X M, $iq15mulr_sat_, S, v_1, v_2).
  j. If (vbinop_ = RELAXED_Q15MULRS), then:
    1) Return $ivbinopsxnd_(lanetype X M, $irelaxed_q15mulr_, S, v_1, v_2).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vbinop_ = ADD), then:
  a. Return $fvbinop_(lanetype X M, $fadd_, v_1, v_2).
4. If (vbinop_ = SUB), then:
  a. Return $fvbinop_(lanetype X M, $fsub_, v_1, v_2).
5. If (vbinop_ = MUL), then:
  a. Return $fvbinop_(lanetype X M, $fmul_, v_1, v_2).
6. If (vbinop_ = DIV), then:
  a. Return $fvbinop_(lanetype X M, $fdiv_, v_1, v_2).
7. If (vbinop_ = MIN), then:
  a. Return $fvbinop_(lanetype X M, $fmin_, v_1, v_2).
8. If (vbinop_ = MAX), then:
  a. Return $fvbinop_(lanetype X M, $fmax_, v_1, v_2).
9. If (vbinop_ = PMIN), then:
  a. Return $fvbinop_(lanetype X M, $fpmin_, v_1, v_2).
10. If (vbinop_ = PMAX), then:
  a. Return $fvbinop_(lanetype X M, $fpmax_, v_1, v_2).
11. If (vbinop_ = RELAXED_MIN), then:
  a. Return $fvbinop_(lanetype X M, $frelaxed_min_, v_1, v_2).
12. Assert: Due to validation, (vbinop_ = RELAXED_MAX).
13. Return $fvbinop_(lanetype X M, $frelaxed_max_, v_1, v_2).

vternop_ lanetype X M vternop_ v_1 v_2 v_3
1. If (lanetype is Jnn /\ (vternop_ = RELAXED_LANESELECT)), then:
  a. Return $ivternopnd_(lanetype X M, $irelaxed_laneselect_, v_1, v_2, v_3).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vternop_ = RELAXED_MADD), then:
  a. Return $fvternop_(lanetype X M, $frelaxed_madd_, v_1, v_2, v_3).
4. Assert: Due to validation, (vternop_ = RELAXED_NMADD).
5. Return $fvternop_(lanetype X M, $frelaxed_nmadd_, v_1, v_2, v_3).

vtestop_ Jnn X M ALL_TRUE v
1. Return $ivtestop_(Jnn X M, $inez_, v).

vrelop_ lanetype X M vrelop_ v_1 v_2
1. If lanetype is Jnn, then:
  a. If (vrelop_ = EQ), then:
    1) Return $ivrelop_(lanetype X M, $ieq_, v_1, v_2).
  b. If (vrelop_ = NE), then:
    1) Return $ivrelop_(lanetype X M, $ine_, v_1, v_2).
  c. If vrelop_ is some LT, then:
    1) Let (LT sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ilt_, sx, v_1, v_2).
  d. If vrelop_ is some GT, then:
    1) Let (GT sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $igt_, sx, v_1, v_2).
  e. If vrelop_ is some LE, then:
    1) Let (LE sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ile_, sx, v_1, v_2).
  f. If vrelop_ is some GE, then:
    1) Let (GE sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ige_, sx, v_1, v_2).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vrelop_ = EQ), then:
  a. Return $fvrelop_(lanetype X M, $feq_, v_1, v_2).
4. If (vrelop_ = NE), then:
  a. Return $fvrelop_(lanetype X M, $fne_, v_1, v_2).
5. If (vrelop_ = LT), then:
  a. Return $fvrelop_(lanetype X M, $flt_, v_1, v_2).
6. If (vrelop_ = GT), then:
  a. Return $fvrelop_(lanetype X M, $fgt_, v_1, v_2).
7. If (vrelop_ = LE), then:
  a. Return $fvrelop_(lanetype X M, $fle_, v_1, v_2).
8. Assert: Due to validation, (vrelop_ = GE).
9. Return $fvrelop_(lanetype X M, $fge_, v_1, v_2).

lcvtop__ lanetype'' X M_1 lanetype X M_2 vcvtop__ c_1
1. If lanetype'' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop__.
    2) Let c be $extend__($lsizenn1(lanetype''), $lsizenn2(lanetype), sx, c_1).
    3) Return [c].
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop__.
    2) Let c be $convert__($lsizenn1(lanetype''), $lsizenn2(lanetype), sx, c_1).
    3) Return [c].
2. Assert: Due to validation, lanetype'' is Fnn.
3. If lanetype is Inn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx zero?) be vcvtop__.
    2) Let c? be $trunc_sat__($lsizenn1(lanetype''), $lsizenn2(lanetype), sx, c_1).
    3) Return c?.
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx zero?) be vcvtop__.
    2) Let c? be $relaxed_trunc__($lsizenn1(lanetype''), $lsizenn2(lanetype), sx, c_1).
    3) Return c?.
4. Assert: Due to validation, lanetype is Fnn.
5. If (vcvtop__ = (DEMOTE ZERO)), then:
  a. Let c* be $demote__($lsizenn1(lanetype''), $lsizenn2(lanetype), c_1).
  b. Return c*.
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Let c* be $promote__($lsizenn1(lanetype''), $lsizenn2(lanetype), c_1).
8. Return c*.

vcvtop__ Lnn_1 X M' Lnn_2 X M'' vcvtop v_1
1. If ((M' = M'') /\ ($halfop(Lnn_1 X M'', Lnn_2 X M'', vcvtop) is not defined /\ $zeroop(Lnn_1 X M'', Lnn_2 X M'', vcvtop) is not defined)), then:
  a. Let c_1* be $lanes_(Lnn_1 X M'', v_1).
  b. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M'', Lnn_2 X M'', vcvtop, c_1)*).
  c. Let v be an element of $invlanes_(Lnn_2 X M'', c*)*.
  d. Return v.
2. If $halfop(Lnn_1 X M', Lnn_2 X M'', vcvtop) is defined, then:
  a. Let ?(half) be $halfop(Lnn_1 X M', Lnn_2 X M'', vcvtop).
  b. Let c_1* be $lanes_(Lnn_1 X M', v_1)[$half(half, 0, M'') : M''].
  c. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M', Lnn_2 X M'', vcvtop, c_1)*).
  d. Let v be an element of $invlanes_(Lnn_2 X M'', c*)*.
  e. Return v.
3. Assert: Due to validation, ($zeroop(Lnn_1 X M', Lnn_2 X M'', vcvtop) = ?(ZERO)).
4. Let c_1* be $lanes_(Lnn_1 X M', v_1).
5. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M', Lnn_2 X M'', vcvtop, c_1)* :: [$zero(Lnn_2)]^M').
6. Let v be an element of $invlanes_(Lnn_2 X M'', c*)*.
7. Return v.

vshiftop_ Jnn X M vshiftop_ v i
1. If (vshiftop_ = SHL), then:
  a. Return $ivshiftop_(Jnn X M, $ishl_, v, i).
2. Assert: Due to validation, vshiftop_ is some SHR.
3. Let (SHR sx) be vshiftop_.
4. Return $ivshiftopsx_(Jnn X M, $ishr_, sx, v, i).

vbitmaskop_ Jnn X M v
1. Return $ivbitmaskop_(Jnn X M, v).

vswizzlop_ I8 X M vswizzlop_ v_1 v_2
1. If (vswizzlop_ = SWIZZLE), then:
  a. Return $ivswizzlop_(I8 X M, $iswizzle_lane_, v_1, v_2).
2. Assert: Due to validation, (vswizzlop_ = RELAXED_SWIZZLE).
3. Return $ivswizzlop_(I8 X M, $irelaxed_swizzle_lane_, v_1, v_2).

vshufflop_ I8 X M i* v_1 v_2
1. Return $ivshufflop_(I8 X M, i*, v_1, v_2).

vnarrowop__ Jnn_1 X M_1 Jnn_2 X M_2 sx v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2).
3. Let c'_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_1)*.
4. Let c'_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_2)*.
5. Let v be $invlanes_(Jnn_2 X M_2, c'_1* :: c'_2*).
6. Return v.

ivadd_pairwise_ N i*
1. Let [j_1, j_2]* be $concat__1^-1(`N, i*).
2. Return $iadd_(N, j_1, j_2)*.

ivextunop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx v_1
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1)*.
3. Let c* be $f_($lsizenn2(Jnn_2), c'_1*).
4. Return $invlanes_(Jnn_2 X M_2, c*).

vextunop__ Jnn_1 X M_1 Jnn_2 X M_2 (EXTADD_PAIRWISE sx) v_1
1. Return $ivextunop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivadd_pairwise_, sx, v_1).

ivdot_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(`iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_(N, j_1, j_2)*.

ivdot_sat_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(`iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_sat_(N, S, j_1, j_2)*.

ivextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx_1 sx_2 i k v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1)[i : k].
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2)[i : k].
3. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_1, c_1)*.
4. Let c'_2* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_2, c_2)*.
5. Let c* be $f_($lsizenn2(Jnn_2), c'_1*, c'_2*).
6. Return $invlanes_(Jnn_2 X M_2, c*).

ivmul_ N i_1* i_2*
1. Return $imul_(N, i_1, i_2)*.

vextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 vextbinop__ v_1 v_2
1. If vextbinop__ is some EXTMUL, then:
  a. Let (EXTMUL half sx) be vextbinop__.
  b. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivmul_, sx, sx, $half(half, 0, M_2), M_2, v_1, v_2).
2. If (vextbinop__ = DOTS), then:
  a. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_, S, S, 0, M_1, v_1, v_2).
3. Assert: Due to validation, (vextbinop__ = RELAXED_DOTS).
4. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_sat_, S, $relaxed2($R_idot(), `sx, S, U), 0, M_1, v_1, v_2).

vextternop__ Jnn_1 X M_1 Jnn_2 X M_2 RELAXED_DOT_ADDS c_1 c_2 c_3
1. Let M be (2 * M_2).
2. Assert: Due to validation, $lsizenn^-1((2 * $lsizenn1(Jnn_1))) is Jnn.
3. Let Jnn be $lsizenn^-1((2 * $lsizenn1(Jnn_1))).
4. Let c' be $vextbinop__(Jnn_1 X M_1, Jnn X M, RELAXED_DOTS, c_1, c_2).
5. Let c'' be $vextunop__(Jnn X M, Jnn_2 X M_2, (EXTADD_PAIRWISE S), c').
6. Let c be an element of $vbinop_(Jnn_2 X M_2, ADD, c'', c_3).
7. Return c.

Ki
1. Return 1024.

packfield_ storagetype val'
1. If storagetype is valtype, then:
  a. Return val'.
2. Assert: Due to validation, storagetype is packtype.
3. Assert: Due to validation, val' is some CONST.
4. Let (numtype_0.CONST i) be val'.
5. Assert: Due to validation, (numtype_0 = I32).
6. Return (PACK storagetype $wrap__(32, $psize(storagetype), i)).

unpackfield_ storagetype sx'? fieldval
1. If (storagetype is valtype /\ (fieldval is val /\ sx'? is not defined)), then:
  a. Return fieldval.
2. Assert: Due to validation, fieldval is some PACK.
3. Let (PACK packtype i) be fieldval.
4. Assert: Due to validation, sx'? is defined.
5. Let ?(sx) be sx'?.
6. Assert: Due to validation, (storagetype = packtype).
7. Return (I32.CONST $extend__($psize(packtype), 32, sx, i)).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC a) be externaddr_0.
  b. Return [a] :: $funcsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $funcsxa(xa*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL a) be externaddr_0.
  b. Return [a] :: $globalsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $globalsxa(xa*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE a) be externaddr_0.
  b. Return [a] :: $tablesxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $tablesxa(xa*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM a) be externaddr_0.
  b. Return [a] :: $memsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $memsxa(xa*).

tagsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some TAG, then:
  a. Let (TAG a) be externaddr_0.
  b. Return [a] :: $tagsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $tagsxa(xa*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

tagaddr (s, f)
1. Return f.MODULE.TAGS.

moduleinst (s, f)
1. Return f.MODULE.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

taginst (s, f)
1. Return s.TAGS.

eleminst (s, f)
1. Return s.ELEMS.

datainst (s, f)
1. Return s.DATAS.

structinst (s, f)
1. Return s.STRUCTS.

arrayinst (s, f)
1. Return s.ARRAYS.

exninst (s, f)
1. Return s.EXNS.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

tag (s, f) x
1. Return s.TAGS[f.MODULE.TAGS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with ?(v).

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

with_struct (s, f) a i fv
1. Replace s.STRUCTS[a].FIELDS[i] with fv.

with_array (s, f) a i fv
1. Replace s.ARRAYS[a].FIELDS[i] with fv.

add_structinst (s, f) si*
1. Append si* to the s.STRUCTS.

add_arrayinst (s, f) ai*
1. Append ai* to the s.ARRAYS.

add_exninst (s, f) exn*
1. Append exn* to the s.EXNS.

growtable tableinst n r
1. Let { TYPE: (at ([ i .. j ]) rt); REFS: r'* } be tableinst.
2. If ((|r'*| + n) > j), then:
  a. Fail.
3. Let i' be (|r'*| + n).
4. Let tableinst' be { TYPE: (at ([ i' .. j ]) rt); REFS: r'* :: r^n }.
5. Return tableinst'.

growmem meminst n
1. Let { TYPE: at ([ i .. j ]) PAGE; BYTES: b* } be meminst.
2. If (((|b*| / (64 * $Ki())) + n) > j), then:
  a. Fail.
3. Let i' be ((|b*| / (64 * $Ki())) + n).
4. Let meminst' be { TYPE: at ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
5. Return meminst'.

inst_valtype moduleinst t
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_valtype(t, dt*).

inst_reftype moduleinst rt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_reftype(rt, dt*).

inst_globaltype moduleinst gt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_globaltype(gt, dt*).

inst_tabletype moduleinst tt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_tabletype(tt, dt*).

inst_memtype moduleinst mt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_memtype(mt, dt*).

blocktype_ z blocktype
1. If blocktype is some _IDX, then:
  a. Let (_IDX x) be blocktype.
  b. Assert: Due to validation, $Expand($type(z, x)) is some FUNC.
  c. Let (FUNC ft) be $Expand($type(z, x)).
  d. Return ft.
2. Assert: Due to validation, blocktype is some _RESULT.
3. Let (_RESULT t?) be blocktype.
4. Return [] -> t?.

alloctypes type''*
1. If (type''* = []), then:
  a. Return [].
2. Let type'* :: [type] be type''*.
3. Let (TYPE rectype) be type.
4. Let deftype'* be $alloctypes(type'*).
5. Let x be |deftype'*|.
6. Let deftype* be $subst_all_deftypes($rolldt(x, rectype), deftype'*).
7. Return deftype'* :: deftype*.

allocfunc s deftype funccode moduleinst
1. Let funcinst be { TYPE: deftype; MODULE: moduleinst; CODE: funccode }.
2. Let a be |s.FUNCS|.
3. Append funcinst to the s.FUNCS.
4. Return a.

allocfuncs s deftype* funccode''* moduleinst''*
1. If (deftype* = []), then:
  a. Assert: Due to validation, (funccode''* = []).
  b. Assert: Due to validation, (moduleinst''* = []).
  c. Return [].
2. Else:
  a. Let [dt] :: dt'* be deftype*.
  b. Assert: Due to validation, (|funccode''*| >= 1).
  c. Let [funccode] :: funccode'* be funccode''*.
  d. Assert: Due to validation, (|moduleinst''*| >= 1).
  e. Let [moduleinst] :: moduleinst'* be moduleinst''*.
  f. Let fa be $allocfunc(s, dt, funccode, moduleinst).
  g. Let fa'* be $allocfuncs(s, dt'*, funccode'*, moduleinst'*).
  h. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let globalinst be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append globalinst to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (at ([ i .. j ]) rt) ref
1. Let tableinst be { TYPE: (at ([ i .. j ]) rt); REFS: ref^i }.
2. Let a be |s.TABLES|.
3. Append tableinst to the s.TABLES.
4. Return a.

alloctables s tabletype''* ref''*
1. If ((tabletype''* = []) /\ (ref''* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref''*| >= 1).
3. Let [ref] :: ref'* be ref''*.
4. Assert: Due to validation, (|tabletype''*| >= 1).
5. Let [tabletype] :: tabletype'* be tabletype''*.
6. Let ta be $alloctable(s, tabletype, ref).
7. Let ta'* be $alloctables(s, tabletype'*, ref'*).
8. Return [ta] :: ta'*.

allocmem s at ([ i .. j ]) PAGE
1. Let meminst be { TYPE: at ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append meminst to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

alloctag s tagtype
1. Let taginst be { TYPE: tagtype }.
2. Let a be |s.TAGS|.
3. Append taginst to the s.TAGS.
4. Return a.

alloctags s tagtype''*
1. If (tagtype''* = []), then:
  a. Return [].
2. Let [tagtype] :: tagtype'* be tagtype''*.
3. Let ja be $alloctag(s, tagtype).
4. Let ja'* be $alloctags(s, tagtype'*).
5. Return [ja] :: ja'*.

allocelem s elemtype ref*
1. Let eleminst be { TYPE: elemtype; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append eleminst to the s.ELEMS.
4. Return a.

allocelems s elemtype* ref''*
1. If ((elemtype* = []) /\ (ref''* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref''*| >= 1).
3. Let [ref*] :: ref'** be ref''*.
4. Assert: Due to validation, (|elemtype*| >= 1).
5. Let [rt] :: rt'* be elemtype*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s OK byte*
1. Let datainst be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append datainst to the s.DATAS.
4. Return a.

allocdatas s datatype* byte*
1. If ((datatype* = []) /\ (byte* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|byte*| >= 1).
3. Let [b*] :: b'** be byte*.
4. Assert: Due to validation, (|datatype*| >= 1).
5. Let [ok] :: ok'* be datatype*.
6. Let da be $allocdata(s, ok, b*).
7. Let da'* be $allocdatas(s, ok'*, b'**).
8. Return [da] :: da'*.

allocexport moduleinst (EXPORT name externidx)
1. If externidx is some FUNC, then:
  a. Let (FUNC x) be externidx.
  b. Return { NAME: name; ADDR: (FUNC moduleinst.FUNCS[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL moduleinst.GLOBALS[x]) }.
3. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE moduleinst.TABLES[x]) }.
4. If externidx is some MEM, then:
  a. Let (MEM x) be externidx.
  b. Return { NAME: name; ADDR: (MEM moduleinst.MEMS[x]) }.
5. Assert: Due to validation, externidx is some TAG.
6. Let (TAG x) be externidx.
7. Return { NAME: name; ADDR: (TAG moduleinst.TAGS[x]) }.

allocexports moduleinst export*
1. Return $allocexport(moduleinst, export)*.

allocmodule s module externaddr* val_G* ref_T* ref_E**
1. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
2. Let fa_I* be $funcsxa(externaddr*).
3. Let ga_I* be $globalsxa(externaddr*).
4. Let aa_I* be $tagsxa(externaddr*).
5. Let ma_I* be $memsxa(externaddr*).
6. Let ta_I* be $tablesxa(externaddr*).
7. Let fa* be (|s.FUNCS| + i_F)^(i_F<|func*|).
8. Let ga* be (|s.GLOBALS| + i_G)^(i_G<|global*|).
9. Let ta* be (|s.TABLES| + i_T)^(i_T<|table*|).
10. Let aa* be (|s.TAGS| + i_A)^(i_A<|tag*|).
11. Let ma* be (|s.MEMS| + i_M)^(i_M<|mem*|).
12. Let ea* be (|s.ELEMS| + i_E)^(i_E<|elem*|).
13. Let da* be (|s.DATAS| + i_D)^(i_D<|data*|).
14. Let (MEMORY memtype)* be mem*.
15. Let dt* be $alloctypes(type*).
16. Let (TAG y)* be tag*.
17. Let (DATA byte* datamode)* be data*.
18. Let (GLOBAL globaltype expr_G)* be global*.
19. Let (TABLE tabletype expr_T)* be table*.
20. Let (ELEM elemtype expr_E* elemmode)* be elem*.
21. Let (FUNC x local* expr_F)* be func*.
22. Let xi* be $allocexports({ FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa* }, export*).
23. Let moduleinst be { TYPES: dt*; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: ea*; DATAS: da*; EXPORTS: xi* }.
24. Let funcaddr_0* be $allocfuncs(s, dt*[x]*, (FUNC x local* expr_F)*, moduleinst^|func*|).
25. Assert: Due to validation, (funcaddr_0* = fa*).
26. Let globaladdr_0* be $allocglobals(s, $subst_all_globaltype(globaltype, dt*)*, val_G*).
27. Assert: Due to validation, (globaladdr_0* = ga*).
28. Let tableaddr_0* be $alloctables(s, $subst_all_tabletype(tabletype, dt*)*, ref_T*).
29. Assert: Due to validation, (tableaddr_0* = ta*).
30. Let memaddr_0* be $allocmems(s, $subst_all_memtype(memtype, dt*)*).
31. Assert: Due to validation, (memaddr_0* = ma*).
32. Let tagaddr_0* be $alloctags(s, dt*[y]*).
33. Assert: Due to validation, (tagaddr_0* = aa*).
34. Let elemaddr_0* be $allocelems(s, $subst_all_reftype(elemtype, dt*)*, ref_E**).
35. Assert: Due to validation, (elemaddr_0* = ea*).
36. Let dataaddr_0* be $allocdatas(s, OK^|data*|, byte**).
37. Assert: Due to validation, (dataaddr_0* = da*).
38. Return moduleinst.

runelem_ x (ELEM rt e^n elemmode)
1. If (elemmode = PASSIVE), then:
  a. Return [].
2. If (elemmode = DECLARE), then:
  a. Return [(ELEM.DROP x)].
3. Assert: Due to validation, elemmode is some ACTIVE.
4. Let (ACTIVE y instr*) be elemmode.
5. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT y x), (ELEM.DROP x)].

rundata_ x (DATA b^n datamode)
1. If (datamode = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode is some ACTIVE.
3. Let (ACTIVE y instr*) be datamode.
4. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT y x), (DATA.DROP x)].

evalglobals z globaltype* expr''*
1. If ((globaltype* = []) /\ (expr''* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|expr''*| >= 1).
3. Let [expr] :: expr'* be expr''*.
4. Assert: Due to validation, (|globaltype*| >= 1).
5. Let [gt] :: gt'* be globaltype*.
6. Let (s, f) be z.
7. Let [val] be $Eval_expr(z, expr).
8. Let a be $allocglobal(s, gt, val).
9. Append a to the f.MODULE.GLOBALS.
10. Let val'* be $evalglobals((s, f), gt'*, expr'*).
11. Return [val] :: val'*.

instantiate s module externaddr*
1. Let xt_I* -> xt_E* be $Module_ok(module).
2. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
3. If not $Externaddr_ok(externaddr, xt_I)*, then:
  a. Fail.
4. Let instr_D* be $concat_(`instr, $rundata_(i_D, data*[i_D])^(i_D<|data*|)).
5. Let instr_E* be $concat_(`instr, $runelem_(i_E, elem*[i_E])^(i_E<|elem*|)).
6. Let (START x)? be start?.
7. Let moduleinst_0 be { TYPES: $alloctypes(type*); FUNCS: $funcsxa(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<|func*|); GLOBALS: $globalsxa(externaddr*) }.
8. Let (TABLE tabletype expr_T)* be table*.
9. Let (GLOBAL globaltype expr_G)* be global*.
10. Let (ELEM reftype expr_E* elemmode)* be elem*.
11. Let instr_S? be (CALL x)?.
12. Let z be (s, { MODULE: moduleinst_0 }).
13. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
14. Let val_G* be $evalglobals(z, globaltype*, expr_G*).
15. Pop the frame (FRAME_ 0 { f }) from the stack.
16. Push the frame (FRAME_ 0 { f }) to the stack.
17. Let [ref_T]* be $Eval_expr(z, expr_T)*.
18. Pop the frame (FRAME_ 0 { f }) from the stack.
19. Push the frame (FRAME_ 0 { f }) to the stack.
20. Let [ref_E]** be $Eval_expr(z, expr_E)**.
21. Pop the frame (FRAME_ 0 { f }) from the stack.
22. Let moduleinst be $allocmodule(s, module, externaddr*, val_G*, ref_T*, ref_E**).
23. Push the frame (FRAME_ 0 { { MODULE: moduleinst } }) to the stack.
24. Execute the sequence instr_E*.
25. Execute the sequence instr_D*.
26. If instr_S? is defined, then:
  a. Let ?(instr_0) be instr_S?.
  b. Execute the instruction instr_0.
27. Pop the frame (FRAME_ 0 { { MODULE: moduleinst } }) from the stack.
28. Return { MODULE: moduleinst }.MODULE.

invoke s funcaddr val*
1. Assert: Due to validation, $Expand(s.FUNCS[funcaddr].TYPE) is some FUNC.
2. Let (FUNC functype_0) be $Expand(s.FUNCS[funcaddr].TYPE).
3. Let t_1* -> t_2* be functype_0.
4. If not $Val_ok(val, t_1)*, then:
  a. Fail.
5. Let k be |t_2*|.
6. Push the frame (FRAME_ k { { MODULE: {} } }) to the stack.
7. Push the values val* to the stack.
8. Push the value (REF.FUNC_ADDR funcaddr) to the stack.
9. Execute the instruction (CALL_REF s.FUNCS[funcaddr].TYPE).
10. Pop the values val'^k from the stack.
11. Pop the frame (FRAME_ k { { MODULE: {} } }) from the stack.
12. Return val'^k.

allocXs `X `Y s X''* Y''*
1. If (X''* = []), then:
  a. Assert: Due to validation, (Y''* = []).
  b. Return [].
2. Else:
  a. Let [X] :: X'* be X''*.
  b. Assert: Due to validation, (|Y''*| >= 1).
  c. Let [Y] :: Y'* be Y''*.
  d. Let a be $allocX(`X, `Y, s, X, Y).
  e. Let a'* be $allocXs(`X, `Y, s, X'*, Y'*).
  f. Return [a] :: a'*.

var `X
1. Return 0.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
```
