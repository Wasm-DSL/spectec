;;
;; Numeric Primitives
;;

;; Binary operators

def $xor(bool, bool) : bool         hint(show %1 $xor %2)
def $xor(bl_1, bl_2) = $(bl_1 =/= bl_2)


;; Conversions

def $s33_to_u32(s33) : u32  hint(show %)

;; This is the `trunc` function as documented in the spec.
def $int(rat) : int                 hint(builtin "rat_to_int") hint(show $trunc(%))
;; def $int(q) = n                     -- if n <- nat /\ $(q - 1) < n <= q


;; Representation


;; no padding
def $ibits_np(nat) : bit*                            hint(show $ibits__np(%))
def $ibits_np(n) = 0                                 -- if n = 0
def $ibits_np(n) = 1                                 -- if n = 1
def $ibits_np(n) = 0 $ibits_np($(n / 2))             -- if n =/= 0 /\ $(n \ 2) = 0
def $ibits_np(n) = 1 $ibits_np($((n-1) / 2))         -- if n =/= 1 /\ $(n \ 2) = 1



def $ibits_(N, iN(N)) : bit*                         hint(partial) hint(show $bits_($IN(%),%))  hint(inverse $invibits_)
def $fbits_(N, fN(N)) : bit*                         hint(builtin) hint(show $bits_($FN(%),%))
def $ibytes_(N, iN(N)) : byte*                       hint(show $bytes_($IN(%),%))               hint(inverse $invibytes_)
def $fbytes_(N, fN(N)) : byte*                       hint(builtin) hint(show $bytes_($FN(%),%)) hint(inverse $invfbytes_)
def $nbytes_(numtype, num_(numtype)) : byte*         hint(builtin) hint(show $bytes_(%,%))      hint(inverse $invnbytes_)
def $vbytes_(vectype, vec_(vectype)) : byte*         hint(builtin) hint(show $bytes_(%,%))      hint(inverse $invvbytes_)
def $zbytes_(storagetype, lit_(storagetype)) : byte* hint(builtin) hint(show $bytes_(%,%))      hint(inverse $invzbytes_)
def $cbytes_(Cnn, lit_(Cnn)) : byte*                 hint(builtin) hint(show $bytes_(%,%))      hint(inverse $invcbytes_)


def $invibits_(N, bit*) : iN(N)                         hint(partial) hint(show $ibits_(%)^(-1)#((%)))
def $invibytes_(N, byte*) : iN(N)                       hint(show $bytes_($IN(%))^(-1)#((%)))
def $invfbytes_(N, byte*) : fN(N)                       hint(show $bytes_($FN(%))^(-1)#((%))) hint(builtin "inverse_of_fbytes")
def $invnbytes_(numtype, byte*) : num_(numtype)         hint(show $bytes_(%)^(-1)#((%)))      hint(builtin "inverse_of_nbytes")
def $invvbytes_(vectype, byte*) : vec_(vectype)         hint(show $bytes_(%)^(-1)#((%)))      hint(builtin "inverse_of_vbytes")
def $invzbytes_(storagetype, byte*) : lit_(storagetype) hint(show $bytes_(%)^(-1)#((%)))      hint(builtin "inverse_of_zbytes")
def $invcbytes_(Cnn, byte*) : lit_(Cnn)                 hint(show $bytes_(%)^(-1)#((%)))      hint(builtin "inverse_of_cbytes")


;; def $littleendian(bit*) : byte*
;; def $littleendian(eps) = eps
;; def $littleendian(d*) = $littleendian(d*[8:l-8]) $invibits_(8, d*[0:8])
;;                       -- if l = |d*|
;; FIXME(zilinc): if inline |d*|, interpreter backend runs into infinite loop.

def $littleendian(bit*) : byte*                      hint(partial)
def $littleendian(eps) = eps
def $littleendian(d^8 d'*) = $littleendian(d'*) $invibits_(8, d^8)


def $ibits_(N, i) = 0^(N - |d*|) d*
                  -- if d* = $rev_(bit, $ibits_np(i))
                  -- if |d*| <= N

def $ibytes_(N, i) = $littleendian($ibits_(N, i))

def $invibits_(0, eps) = 0
def $invibits_(N, d d'*) = $(2^(N-1) * d + $invibits_($(N-1), d'*))  -- if |d'*| = $(N-1)
;; FIXME(zilinc): The key 'N' is not in the map. e.g. i64.wast
;; def $invibits_(N, d d'^(N-1)) = $(2^(N-1) * d + $invibits_($(N-1), d'^(N-1)))


def $invibytes_(N, b) = b  -- if N = 8 ;; || N = 32
def $invibytes_(N, b_0 b*) = $($invibytes_($(N-8), b*) * 2^8 + b_0)
                           -- if $(N = |b*| * 8 + 8) /\ |b*| > 0 ;; || (N = 32 /\ |b*| <= 1)
;; NOTE(zilinc): The interpreter implementation has that N = 32 case for packtype, but it's
;; not in the Wasm spec. Also, would it make $invibytes a real inverse of ibytes?

;; def $invibytes_(N, b*) = n  -- if $ibytes_(N, n) = b*
;; def $invfbytes_(N, b*) = p  -- if $fbytes_(N, p) = b*



;; Signed numbers

def $signed_(N, nat) : int          hint(partial) hint(inverse $invsigned_)
def $signed_(N, i) = i              -- if $(i < 2^(N-1))
def $signed_(N, i) = $(i - 2^N)     -- if $(2^(N-1) <= i < 2^N)

def $invsigned_(N, int) : nat       hint(partial) hint(show $signed_(%)^(-1)#((%)))
def $invsigned_(N, i) = i           -- if $(0 <= i < 2^(N-1))
def $invsigned_(N, i) = $(i + 2^N)  -- if $(-2^(N-1) <= i < 0)

def $sx(storagetype) : sx?  hint(show $sx(%))
def $sx(consttype) = eps
def $sx(packtype) = S


;; Construction

def $zero(lanetype) : lane_(lanetype) hint(show 0)
def $zero(Jnn) = 0
def $zero(Fnn) = $fzero($size(Fnn))

def $bool(bool) : nat
def $bool(false) = 0
def $bool(true) = 1

def $bit2bool(bit) : bool
def $bit2bool(0) = false
def $bit2bool(1) = true



;; Bit-wise operators

def $bitsand_(N, bit*, bit*) : bit*    hint(show %2 $AND_(%1) %3)
def $bitsand_(N, d_1*, d_2*) = ($bool($bit2bool(d_1) /\ $bit2bool(d_2)))*

def $bitsor_(N, bit*, bit*) : bit*     hint(show %2 $OR_(%1) %3)
def $bitsor_(N, d_1*, d_2*) = ($bool($bit2bool(d_1) \/ $bit2bool(d_2)))*

def $bitsxor_(N, bit*, bit*) : bit*    hint(show %2 $XOR_(%1) %3)
def $bitsxor_(N, d_1*, d_2*) = ($bool($xor($bit2bool(d_1), $bit2bool(d_2))))*

def $bitsnot_(N, bit*) : bit*          hint(show $NOT_(%1) %2)
def $bitsnot_(N, d*) = ($bool(~ $bit2bool(d)))*


;; Saturation

def $sat_u_(N, int) : nat           hint(show $sat__u_(%,%))
def $sat_u_(N, i) = 0               -- if i < 0
def $sat_u_(N, i) = $(2^N - 1)      -- if i > $(2^N - 1)
def $sat_u_(N, i) = i               -- otherwise

def $sat_s_(N, int) : int           hint(show $sat__s_(%,%))
def $sat_s_(N, i) = $(-2^(N-1))     -- if i < $(-2^(N-1))
def $sat_s_(N, i) = $(2^(N-1) - 1)  -- if i > $(2^(N-1) - 1)
def $sat_s_(N, i) = i               -- otherwise


;; Integer operations

def $ineg_(N, iN(N)) : iN(N)
def $iabs_(N, iN(N)) : iN(N)
def $iclz_(N, iN(N)) : iLt(N)
def $ictz_(N, iN(N)) : iN(N)
def $ipopcnt_(N, iN(N)) : iN(N)
def $iextend_(N, M, sx, iN(N)) : iN(N)          hint(show $iextend_((%,%))^(%)#((%)))

def $iadd_(N, iN(N), iN(N)) : iN(N)
def $isub_(N, iN(N), iN(N)) : iN(N)
def $imul_(N, iN(N), iN(N)) : iN(N)
def $idiv_(N, sx, iN(N), iN(N)) : iN(N)?        hint(show $idiv_(%)^(%)#((%,%)))
def $irem_(N, sx, iN(N), iN(N)) : iN(N)?        hint(show $irem_(%)^(%)#((%,%)))
def $imin_(N, sx, iN(N), iN(N)) : iN(N)         hint(show $imin_(%)^(%)%((%,%)))
def $imax_(N, sx, iN(N), iN(N)) : iN(N)         hint(show $imax_(%)^(%)%((%,%)))
def $iadd_sat_(N, sx, iN(N), iN(N)) : iN(N)     hint(show $iadd__sat_(%)^(%)#((%,%)))
def $isub_sat_(N, sx, iN(N), iN(N)) : iN(N)     hint(show $isub__sat_(%)^(%)#((%,%)))
def $iq15mulr_sat_(N, sx, iN(N), iN(N)) : iN(N) hint(partial) hint(show $iq15mulr__sat_(%)^(%)#((%,%)))
def $irelaxed_q15mulr_(N, sx, iN(N), iN(N)) : iN(N)* hint(show $relaxed__iq15mulr_(%)^(%)#((%,%))) hint(builtin)
def $iavgr_(N, sx, iN(N), iN(N)) : iN(N)        hint(show $iavgr_(%)^(%)#((%,%)))

def $inot_(N, iN(N)) : iN(N)
def $irev_(N, iN(N)) : iN(N)
def $iand_(N, iN(N), iN(N)) : iN(N)
def $iandnot_(N, iN(N), iN(N)) : iN(N)
def $ior_(N, iN(N), iN(N)) : iN(N)
def $ixor_(N, iN(N), iN(N)) : iN(N)
def $ishl_(N, iN(N), u32) : iN(N)
def $ishr_(N, sx, iN(N), u32) : iN(N)    hint(show $ishr_(%)^(%)#((%,%)))
def $irotl_(N, iN(N), iN(N)) : iN(N)
def $irotr_(N, iN(N), iN(N)) : iN(N)

def $ibitselect_(N, iN(N), iN(N), iN(N)) : iN(N)
def $irelaxed_laneselect_(N, iN(N), iN(N), iN(N)) : iN(N)*  hint(builtin)

def $ieqz_(N, iN(N)) : u32
def $inez_(N, iN(N)) : u32

def $ieq_(N, iN(N), iN(N)) : u32
def $ine_(N, iN(N), iN(N)) : u32
def $ilt_(N, sx, iN(N), iN(N)) : u32     hint(show $ilt_(%)^(%)#((%,%)))
def $igt_(N, sx, iN(N), iN(N)) : u32     hint(show $igt_(%)^(%)#((%,%)))
def $ile_(N, sx, iN(N), iN(N)) : u32     hint(show $ile_(%)^(%)#((%,%)))
def $ige_(N, sx, iN(N), iN(N)) : u32     hint(show $ige_(%)^(%)#((%,%)))


def $ineg_(N, i) = $((2^N - i) \ 2^N)

def $iabs_(N, i) = i                   -- if $signed_(N, i) >= 0
def $iabs_(N, i) = $ineg_(N, i)        -- otherwise

;; TODO(_, zilinc)
;; def $clzbits(bit*) : nat               hint(partial)
;; def $clzbits(0^k) = k                  -- if k > 0 ;; -- if (d = 0)^k
;; def $clzbits(0^k' 1 d'*) = k'          ;; -- if (d = 0)^k'

;; def $clzbits(bit*) : nat               hint(partial)
;; def $clzbits(d^k) = k                  -- if k > 0
;;                                        -- if (d = 0)^k
;; def $clzbits(d^k' 1 d'*) = k'          -- if (d = 0)^k'

def $eqbitzero(bit) : bool             hint(show $eq__bit_0(%)) hint(show $eq__bit_0)
def $eqbitzero(d) = ~ $bit2bool(d)

def $eqbitone(bit): bool               hint(show $eq__bit_1(%)) hint(show $eq__bit_1)
def $eqbitone(d) = $bit2bool(d)

;; NOTE(zilinc): because `clzbits` doesn't work.
;; def $iclz_(N, i) = $clzbits(d*)        -- if d* = $ibits_(N, i)
def $iclz_(N, i) = |$takeWhile_(bit, $eqbitzero, d*)|   -- if d* = $ibits_(N, i)


def $ictz_(N, i) = |$takeWhile_(bit, $eqbitzero, d'*)|  -- if d*  = $ibits_(N, i)
                                                        -- if d'* = $rev_(bit, d*)

def $ipopcnt_(N, i) = |$filter_(bit, $eqbitone, d*)|    -- if d* = $ibits_(N, i)

def $iextend_(N, M, U, i) = $(i \ 2^M)
def $iextend_(N, M, S, i) = $invsigned_(N, $signed_(M, $(i \ 2^M)))


def $iadd_(N, i_1, i_2) = $((i_1 + i_2) \ 2^N)

def $isub_(N, i_1, i_2) = $((2^N + i_1 - i_2) \ 2^N)

def $imul_(N, i_1, i_2) = $((i_1 * i_2) \ 2^N)

def $idiv_(N, U, i_1, 0)   = eps
def $idiv_(N, U, i_1, i_2) = $int($(i_1 / i_2))
def $idiv_(N, S, i_1, 0)   = eps
def $idiv_(N, S, i_1, i_2) = eps  -- if $signed_(N, i_1) = $($signed_(N, i_2) * 2^(N-1))
def $idiv_(N, S, i_1, i_2) = $invsigned_(N, $int($($signed_(N, i_1) / $signed_(N, i_2))))

def $irem_(N, U, i_1, 0)   = eps
def $irem_(N, U, i_1, i_2) = $(i_1 - i_2 * $int($(i_1 / i_2)))
def $irem_(N, S, i_1, 0)   = eps
def $irem_(N, S, i_1, i_2) = $invsigned_(N, $(j_1 - j_2 * $int($(j_1 / j_2))))
                             -- if j_1 = $signed_(N, i_1)
                             -- if j_2 = $signed_(N, i_2)


def $imin_(N, sx, i_1, i_2) = i_1  -- if $ilt_(N, sx, i_1, i_2) = 1
def $imin_(N, sx, i_1, i_2) = i_2  -- otherwise

def $imax_(N, sx, i_1, i_2) = i_1  -- if $igt_(N, sx, i_1, i_2) = 1
def $imax_(N, sx, i_1, i_2) = i_2  -- otherwise

def $iadd_sat_(N, U, i_1, i_2) = $sat_u_(N, $(i_1 + i_2))
def $iadd_sat_(N, S, i_1, i_2) = $invsigned_(N, $sat_s_(N, $($signed_(N, i_1) + $signed_(N, i_2))))

def $isub_sat_(N, U, i_1, i_2) = $sat_u_(N, $(i_1 - i_2))
def $isub_sat_(N, S, i_1, i_2) = $invsigned_(N, $sat_s_(N, $($signed_(N, i_1) - $signed_(N, i_2))))

;; Q15.1 multiplication: https://en.wikipedia.org/wiki/Q_(number_format)
def $iq15mulr_sat_(N, S, i_1, i_2) = $invsigned_(N, j_2)
                                   -- if N = 16
                                   -- if N' = 32
                                   -- if j_0 = $($signed_(N, i_1) * $signed_(N, i_2) + 2^14)
                                   -- if j_1 = $ishr_(N', S, $invsigned_(N', j_0), 15)
                                   -- if j_2 = $sat_s_(N, $signed_(N', j_1))  ;; $sat_s_ only works on signed int


def $iavgr_(N, U, i_1, i_2) = $int($((i_1 + i_2 + 1) / 2))
def $iavgr_(N, S, i_1, i_2) = $int($((i_1' + i_2' + 1) / 2))    -- if i_1' = $signed_(N, i_1)
                                                                -- if i_2' = $signed_(N, i_2)

def $inot_(N, i) = $invibits_(N, $bitsnot_(N, $ibits_(N, i)))

def $irev_(N, i) = $invibits_(N, $rev_(bit, $ibits_(N, i)))

def $iand_(N, i_1, i_2) = $invibits_(N, $bitsand_(N, $ibits_(N, i_1), $ibits_(N, i_2)))

def $iandnot_(N, i_1, i_2) = $iand_(N, i_1, $inot_(N, i_2))

def $ior_(N, i_1, i_2) = $invibits_(N, $bitsor_(N, $ibits_(N, i_1), $ibits_(N, i_2)))

def $ixor_(N, i_1, i_2) = $invibits_(N, $bitsxor_(N, $ibits_(N, i_1), $ibits_(N, i_2)))

def $ishl_(N, i_1, i_2) = $invibits_(N, d* 0^k)
                        -- if k = $(i_2 \ N)
                        -- if d* = $drop'_(bit, k, $ibits_(N, i_1))

def $ishr_(N, U, i_1, i_2) = $invibits_(N, 0^k d*)
                           -- if k = $(i_2 \ N)
                           -- if d* = $take'_(bit, $(N-k), $ibits_(N, i_1))
def $ishr_(N, S, i_1, i_2) = $invibits_(N, d_0 d_0^k d_1*)
                           -- if k = $(i_2 \ N)
                           -- if d_0 d_1* = $take'_(bit, $(N-k), $ibits_(N, i_1))

def $irotl_(N, i_1, i_2) = $invibits_(N, d_2* d_1*)
                         -- if k = $(i_2 \ N)
                         -- if d_1* = $take'_(bit, k, $ibits_(N, i_1))
                         -- if d_2* = $drop'_(bit, k, $ibits_(N, i_1))

def $irotr_(N, i_1, i_2) = $invibits_(N, d_2* d_1*)
                         -- if k = $(i_2 \ N)
                         -- if d_1* = $take'_(bit, $(N-k), $ibits_(N, i_1))
                         -- if d_2* = $drop'_(bit, $(N-k), $ibits_(N, i_1))

;; FIXME(zilinc): type inference failure on k
;; def $irotr_(N, i_1, i_2) = $invibits_(N, d_2^k d_1^(N-k))
;;                          -- var k : nat
;;                          -- if k = $(i_2 \ N) 
;;                          -- if d_1^(N-k) d_2^k = $ibits_(N, i_1)


def $ieqz_(N, i_1) = $bool(i_1 = 0)

def $inez_(N, i_1) = $bool(i_1 =/= 0)


def $ieq_(N, i_1, i_2) = $bool(i_1 = i_2)

def $ine_(N, i_1, i_2) = $bool(i_1 =/= i_2)

def $ilt_(N, U, i_1, i_2) = $bool(i_1 < i_2)
def $ilt_(N, S, i_1, i_2) = $bool($signed_(N, i_1) < $signed_(N, i_2))

def $igt_(N, U, i_1, i_2) = $bool(i_1 > i_2)
def $igt_(N, S, i_1, i_2) = $bool($signed_(N, i_1) > $signed_(N, i_2))

def $ile_(N, U, i_1, i_2) = $bool(i_1 <= i_2)
def $ile_(N, S, i_1, i_2) = $bool($signed_(N, i_1) <= $signed_(N, i_2))

def $ige_(N, U, i_1, i_2) = $bool(i_1 >= i_2)
def $ige_(N, S, i_1, i_2) = $bool($signed_(N, i_1) >= $signed_(N, i_2))


def $ibitselect_(N, i_1, i_2, i_3) = $ior_(N, j_1, j_2)
                                   -- if j_1 = $iand_(N, i_1, i_3)
                                   -- if j_3 = $inot_(N, i_3)
                                   -- if j_2 = $iand_(N, i_2, j_3)


;; Floating-point operations

def $fabs_(N, fN(N)) : fN(N)*                  hint(builtin)
def $fneg_(N, fN(N)) : fN(N)*                  hint(builtin)
def $fsqrt_(N, fN(N)) : fN(N)*                 hint(builtin)
def $fceil_(N, fN(N)) : fN(N)*                 hint(builtin)
def $ffloor_(N, fN(N)) : fN(N)*                hint(builtin)
def $ftrunc_(N, fN(N)) : fN(N)*                hint(builtin)
def $fnearest_(N, fN(N)) : fN(N)*              hint(builtin)

def $fadd_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fsub_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fmul_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fdiv_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fmin_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fmax_(N, fN(N), fN(N)) : fN(N)*           hint(builtin)
def $fpmin_(N, fN(N), fN(N)) : fN(N)*          hint(builtin)
def $fpmax_(N, fN(N), fN(N)) : fN(N)*          hint(builtin)
def $frelaxed_min_(N, fN(N), fN(N)) : fN(N)*   hint(builtin) hint(show $frelaxed__min_(%,%,%))
def $frelaxed_max_(N, fN(N), fN(N)) : fN(N)*   hint(builtin) hint(show $frelaxed__max_(%,%,%))
def $fcopysign_(N, fN(N), fN(N)) : fN(N)*      hint(builtin)

def $feq_(N, fN(N), fN(N)) : u32               hint(builtin)
def $fne_(N, fN(N), fN(N)) : u32               hint(builtin)
def $flt_(N, fN(N), fN(N)) : u32               hint(builtin)
def $fgt_(N, fN(N), fN(N)) : u32               hint(builtin)
def $fle_(N, fN(N), fN(N)) : u32               hint(builtin)
def $fge_(N, fN(N), fN(N)) : u32               hint(builtin)

def $frelaxed_madd_(N, fN(N), fN(N), fN(N)) : fN(N)*   hint(builtin) hint(show $frelaxed__madd_(%,%,%))
def $frelaxed_nmadd_(N, fN(N), fN(N), fN(N)) : fN(N)*  hint(builtin) hint(show $frelaxed__nmadd_(%,%,%))


;; TODO(3, rossberg): implement numerics internally


;; Conversions

def $wrap__(M, N, iN(M)) : iN(N)
def $extend__(M, N, sx, iN(M)) : iN(N)               hint(show $extend_((%,%))^(%)#((%)))
def $trunc__(M, N, sx, fN(M)) : iN(N)?               hint(builtin) hint(show $trunc_((%,%))^(%)#((%)))
def $trunc_sat__(M, N, sx, fN(M)) : iN(N)?           hint(builtin) hint(show $trunc__sat_((%,%))^(%)#((%)))
def $relaxed_trunc__(M, N, sx, fN(M)) : iN(N)?       hint(builtin) hint(show $relaxed__trunc_((%,%))^(%)#((%)))
def $demote__(M, N, fN(M)) : fN(N)*                  hint(builtin)
def $promote__(M, N, fN(M)) : fN(N)*                 hint(builtin)
def $convert__(M, N, sx, iN(M)) : fN(N)              hint(builtin) hint(show $convert_((%,%))^(%)#((%)))
def $narrow__(M, N, sx, iN(M)) : iN(N)               hint(show $narrow_((%,%))^(%)#(%))

def $reinterpret__(numtype_1, numtype_2, num_(numtype_1)) : num_(numtype_2)  hint(builtin)


;; TODO(3, rossberg): implement numerics internally

def $wrap__(M, N, i) = $(i \ 2^N)

def $extend__(M, N, U, i) = i
def $extend__(M, N, S, i) = $invsigned_(N, $signed_(M, i))

def $narrow__(M, N, U, i) = $sat_u_(N, $signed_(M, i))
def $narrow__(M, N, S, i) = $invsigned_(N, $sat_s_(N, $signed_(M, i)))


;; Packed numbers

def $lpacknum_(lanetype, num_($lunpack(lanetype))) : lane_(lanetype)
    hint(show $pack_(%,%)) hint(macro "packnum")
def $cpacknum_(storagetype, lit_($cunpack(storagetype))) : lit_(storagetype)
    hint(show $pack_(%,%)) hint(macro "packnum")

def $lpacknum_(numtype, c) = c
def $lpacknum_(packtype, c) = $wrap__($size($lunpack(packtype)), $psize(packtype), c)

def $cpacknum_(consttype, c) = c
def $cpacknum_(packtype, c) = $wrap__($size($lunpack(packtype)), $psize(packtype), c)


def $lunpacknum_(lanetype, lane_(lanetype)) : num_($lunpack(lanetype))
    hint(show $unpack_(%,%)) hint(macro "unpacknum")
def $cunpacknum_(storagetype, lit_(storagetype)) : lit_($cunpack(storagetype))
    hint(show $unpack_(%,%)) hint(macro "unpacknum")

def $lunpacknum_(numtype, c) = c
def $lunpacknum_(packtype, c) = $extend__($psize(packtype), $size($lunpack(packtype)), U, c)

def $cunpacknum_(consttype, c) = c
def $cunpacknum_(packtype, c) = $extend__($psize(packtype), $size($lunpack(packtype)), U, c)


;; Operator dispatch

def $unop_(numtype, unop_(numtype), num_(numtype)) : num_(numtype)*
    hint(show %2#$_(%1,%3))
def $binop_(numtype, binop_(numtype), num_(numtype), num_(numtype)) : num_(numtype)*
    hint(show %2#$_(%1,%3,%4))
def $testop_(numtype, testop_(numtype), num_(numtype)) : u32
    hint(show %2#$_(%1,%3))
def $relop_(numtype, relop_(numtype), num_(numtype), num_(numtype)) : u32
    hint(show %2#$_(%1,%3,%4))
def $cvtop__(numtype_1, numtype_2, cvtop__(numtype_1, numtype_2), num_(numtype_1)) : num_(numtype_2)*
    hint(show %3#$__(%1,%2,%4))

def $unop_(Inn, CLZ, i) = $iclz_($sizenn(Inn), i)
def $unop_(Inn, CTZ, i) = $ictz_($sizenn(Inn), i)
def $unop_(Inn, POPCNT, i) = $ipopcnt_($sizenn(Inn), i)
def $unop_(Inn, EXTEND M, i) = $iextend_($sizenn(Inn), M, S, i)

def $unop_(Fnn, ABS, f) = $fabs_($sizenn(Fnn), f)
def $unop_(Fnn, NEG, f) = $fneg_($sizenn(Fnn), f)
def $unop_(Fnn, SQRT, f) = $fsqrt_($sizenn(Fnn), f)
def $unop_(Fnn, CEIL, f) = $fceil_($sizenn(Fnn), f)
def $unop_(Fnn, FLOOR, f) = $ffloor_($sizenn(Fnn), f)
def $unop_(Fnn, TRUNC, f) = $ftrunc_($sizenn(Fnn), f)
def $unop_(Fnn, NEAREST, f) = $fnearest_($sizenn(Fnn), f)

def $binop_(Inn, ADD, i_1, i_2) = $iadd_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, SUB, i_1, i_2) = $isub_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, MUL, i_1, i_2) = $imul_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, DIV sx, i_1, i_2) = $idiv_($sizenn(Inn), sx, i_1, i_2)
def $binop_(Inn, REM sx, i_1, i_2) = $irem_($sizenn(Inn), sx, i_1, i_2)
def $binop_(Inn, AND, i_1, i_2) = $iand_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, OR, i_1, i_2) = $ior_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, XOR, i_1, i_2) = $ixor_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, SHL, i_1, i_2) = $ishl_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, SHR sx, i_1, i_2) = $ishr_($sizenn(Inn), sx, i_1, i_2)
def $binop_(Inn, ROTL, i_1, i_2) = $irotl_($sizenn(Inn), i_1, i_2)
def $binop_(Inn, ROTR, i_1, i_2) = $irotr_($sizenn(Inn), i_1, i_2)

def $binop_(Fnn, ADD, f_1, f_2) = $fadd_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, SUB, f_1, f_2) = $fsub_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, MUL, f_1, f_2) = $fmul_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, DIV, f_1, f_2) = $fdiv_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, MIN, f_1, f_2) = $fmin_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, MAX, f_1, f_2) = $fmax_($sizenn(Fnn), f_1, f_2)
def $binop_(Fnn, COPYSIGN, f_1, f_2) = $fcopysign_($sizenn(Fnn), f_1, f_2)

def $testop_(Inn, EQZ, i) = $ieqz_($sizenn(Inn), i)

def $relop_(Inn, EQ, i_1, i_2) = $ieq_($sizenn(Inn), i_1, i_2)
def $relop_(Inn, NE, i_1, i_2) = $ine_($sizenn(Inn), i_1, i_2)
def $relop_(Inn, LT sx, i_1, i_2) = $ilt_($sizenn(Inn), sx, i_1, i_2)
def $relop_(Inn, GT sx, i_1, i_2) = $igt_($sizenn(Inn), sx, i_1, i_2)
def $relop_(Inn, LE sx, i_1, i_2) = $ile_($sizenn(Inn), sx, i_1, i_2)
def $relop_(Inn, GE sx, i_1, i_2) = $ige_($sizenn(Inn), sx, i_1, i_2)

def $relop_(Fnn, EQ, f_1, f_2) = $feq_($sizenn(Fnn), f_1, f_2)
def $relop_(Fnn, NE, f_1, f_2) = $fne_($sizenn(Fnn), f_1, f_2)
def $relop_(Fnn, LT, f_1, f_2) = $flt_($sizenn(Fnn), f_1, f_2)
def $relop_(Fnn, GT, f_1, f_2) = $fgt_($sizenn(Fnn), f_1, f_2)
def $relop_(Fnn, LE, f_1, f_2) = $fle_($sizenn(Fnn), f_1, f_2)
def $relop_(Fnn, GE, f_1, f_2) = $fge_($sizenn(Fnn), f_1, f_2)

def $cvtop__(Inn_1, Inn_2, EXTEND sx, i_1) =
  $extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, i_1)
def $cvtop__(Inn_1, Inn_2, WRAP, i_1) =
  $wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), i_1)
def $cvtop__(Fnn_1, Inn_2, TRUNC sx, f_1) =
  $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1)
def $cvtop__(Fnn_1, Inn_2, TRUNC_SAT sx, f_1) =
  $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1)
def $cvtop__(Inn_1, Fnn_2, CONVERT sx, i_1) =
  $convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, i_1)
def $cvtop__(Fnn_1, Fnn_2, PROMOTE, f_1) =
  $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1)
def $cvtop__(Fnn_1, Fnn_2, DEMOTE, f_1) =
  $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1)
def $cvtop__(Inn_1, Fnn_2, REINTERPRET, i_1) =
  $reinterpret__(Inn_1, Fnn_2, i_1) -- if $size(Inn_1) = $size(Fnn_2)  ;; TODO(3, rossberg): make implicit
def $cvtop__(Fnn_1, Inn_2, REINTERPRET, f_1) =
  $reinterpret__(Fnn_1, Inn_2, f_1) -- if $size(Fnn_1) = $size(Inn_2)  ;; TODO(3, rossberg): make implicit
